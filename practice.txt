class Solution{
    public :
         ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
             if(l1 == NULL) return l2;
             if(l2 == NULL) return l1;


            ListNode* finalHead = NULL;
             if(l1-> val < l2->val){
                finalHead = l1;
                l1 = l1->next;
             }else{
                 finalHead = l2;
                 l2 = l2->next;
             }

             ListNode* p = finalHead;
             while(l1 && l2){
                 if(l1->val < l2->val){
                     p->next = l1;
                     l1 = l1->next;
                 }else{
                     p->next = l2;
                     l2 = l2->next;
                 }
                 p = p->next;
             }
            if(l1){
                p->next = l1;
            }else{
                p->next = l2;
            }
            return finalHead;
         }

         ListNode* sortList(ListNode* head) {
             if(head == NULL ) return head;
             ListNode* slow= head;
             ListNode* fast = head->next;
            while(fast && fast->next){
                slow = slow->next;
                fast = fast->next->next;
            }
             if(fast){
                ListNode* n = slow->next;
                slow->next = NULL;
             }else{
                 ListNode* n = slow;
                 slow = NULL;
             }
             ListNode* a = sortList(head);
             ListNode* b = sortList(n);
            head = mergeTwoLists(a,b);            
            return head;

         }
        ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
            if(l1 == NULL) return l2;
            if(l2 == NULL) return l1;
            ListNode* finalHead = NULL;
            if(l1->val < l2->val){
                finalHead = l1;
                finalHead->next = mergeTwoLists(l1->next,l2);
            }else{
                finalHead = l2;
                finalHead->next = mergeTwoLists(l1,l2->next);
            }
            return finalHead;
        }

}


template<typename T>
class Stack{
    T *arr;
    int nextIndex;
    int capacity;
    public :
        Stack(){
            capacity = 5;
            arr = new T[capacity];
            nextIndex = 0;
        }
        int size(){
            return nextIndex;
        }
        bool isEmpty(){
            return nextIndex == 0;
        }
        T top(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return -1;
            }
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }
            nextIndex--;
        }
        void push(T element){
            if(capacity == nextIndex){
                int *newArr = new T[capacity*2];
                for(int i = 0;i < nextIndex;i++){
                    newArr[i] = arr[i];
                }
                delete []arr;
                arr = newArr;
                capacity = 2*capacity;
            }
            arr[nextIndex] == element;
            nextIndex++;
        }
}

template<typename T>
class Node{
    public :
        T data;
        Node<T> *next;
        Node(T element){
            this->data = element;
            this->next = NULL;
        }
}

template<typename T>
class Stack{
    int size = 0;
    Node<T> *head;
    public :
        Stack(){
            head = NULL;
            size = 0;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size==0;
        }
        void push(T element){
            Node<T> *n = new Node<T>(element);
            n->next = head;
            head = n;
            size++;
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }
            Node<T> *temp = head;
            head = head->next;
            temp->next = NULL;
            delete temp;
            size--;
        }
        T top(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return 0;
            }
            return head->data;
        }
}


bool isValid(String a){
    stack<char> c;
    for(int i = 0;i < a.size();i++){
        if(a[i] == '(' || a[i] == '{' || a[i] == '[' ){
            c.push(a[i]);
        }else{
            if(s.empty()){
                return false;
            }else if(a[i] == ')'){
                if(s.top() == a[i]){
                    s.pop();
                }else{
                    return false;
                }
            }else if(a[i] == '}'){
                if(s.top() == a[i]){
                    s.pop();
                }else{
                    return false;
                }
            }else if(a[i] == ']'){
                if(s.top() == a[i]){
                    s.pop();
                }else{
                    return false;
                }
            }
        }
    }
}

int evalRPN(vector<string> &tokens){
    stack<int> st;
    for(int i = 0;i < tokens.size();i++){
        if(tokens[i] == "+" ||tokens[i] == "-" ||tokens[i] == "*" ||tokens[i] == "/"){
            int v1 = st.top();
            st.pop();
            int v2 = st.top();
            st.pop();
            if(tokens[i] == "+"){
                st.push(v2+v1);
            }else if(tokens[i] == "-"){
                st.push(v2-v1);
            }else if(tokens[i] == "*"){
                st.push(v2*v1);
            }else if(tokens[i] == "/"){
                st.push(v2/v1);
            }
        }else{
            st.push(atoi(tokens[i].c_str()));
        }
    }
    return st.top();
}


string removeAdj(string A){
    stack<char> a;
    for(int i = 0;i < A.size();i++){
        if(a.empty() || a.top() != A[i]){
            a.push(A[i])
        }else{
            a.pop();
        }
    }
    string ans = "";
    while(!s.empty()){
        ans.push_back(a.top());
        a.pop();
    }
    reverse(ans.begin(),ans.end());
    return ans;
}


string removeAdj(string A){
    int stkptr = -1;
    for(int i = 0;i < A.size();i++){
        if(stkptr == -1 || A[stkptr] != A[i]){
            stkptr++;
            A[stkptr] = A[i];
        }else{
            stkptr--;
        }
    }
    string ans = "";
    for(int i = 0;i <= stkptr;i++){
        ans.push_back(A[i]);
    }
    return ans;
}


int partition(int a[],int s,int e){
    int i = s;
    int pivot = a[e];
    for(int j = s;j <= e-1;j++){
        if(a[j] < pivot){
            swap(a[j],a[i]);
            i++;
        }
    }
    swap(a[e],a[i]);
    return i;
}
void quickSort(int a[],int s,int e){
    if(s >= e){
        return ;
    }
    int p = partition(a,s,e);
    quickSort(a,s,p-1);
    quickSort(a,p+1,e);
}

void printPermu(char name[],int i = 0){
    if(name[i] == '\0'){
        cout<<name;
        return ;
    }
    for(int j = i; name[j] != '\0' ;j++){
        swap(name[i],name[j]);
        printPermu(name,i+1);
        swap(name[i],name[j]);
    }
}
class Node{
    public : 
    int data;
    Node *next;
    
    Node(int data){
        this->data = data;
        next = NULL;
    }
}
void print(Node *head){
    if(head == NULL) return ;

    Node *temp = head;
    while(temp){
        cout<<temp->data<<endl;
        temp = temp->next;
    }
}
void takeInput2(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* tail = NULL;
    while(data != -1){
        Node *n = new Node(data);
        if(head == NULL){
            head = n;
            tail = n;
        }else{
            n->next = head;
            head = n;
        }
        cin>>data;
    }
    return head;
}
int length(Node * head){
    if(head == NULL) return ;

    int count = 0;
    Node *temp = head;
    while(temp != NULL){
        count++;
        temp = temp->next;
    }
    return count;
}

void printIthNode(Node * head){
    if(head == NULL) return ;

    Node *temp = head;
    int count = 1;
    while(count <= i && temp != NULL){
        temp = temp->next;
        count++;
    }
    if(temp){
        cout<<temp->data;
    }else{
        cout<<"-1";
    }
}

void insertAtIthPos(Node* head,int data,int i){
    if(head == NULL) return ;

    Node *temp = head;
    int count = 1;
    if(i == 0){
        Node *n = new Node(data);
        n->next = head;
        head = n;
        return head;
    }
    while(count < i && temp != NULL){
        temp=temp->next;
        count++;
    }
    if(temp){
        Node *n = new Node(data);
        Node *hello = temp->next;
        temp->next = n;
        n->next = hello;
        return head;
    }
}

void deleteIthNode(Node *head,int i){
    if(head == NULL) return ;

    int count = 1;
    Node *temp = head;
    if(i == 0){
        Node *hello = head->next;
        head = head->next;
        hello->next = NULL;
        delete hello;
        return head;
    }
    while(count < i && temp != NULL){
        temp = temp->next;
        count++;
    }
    if(temp && temp->next){
        Node *hello = temp->next;
        temp->next = temp->next->next;
        hello->next = NULL;
        delete hello;
        return head;
    }
}

int length2(Node *head){
    if(head == NULL) return 0;

    int small = length2(head->next);
    return small+1;
}
bool isPresent(Node *head,int data){
    if(head == NULL) return false;
    if(head->data == data) return true;
    return isPresent(head->next,data);
}

int middleLL(Node *head){
    if(head == NULL) return -1;

    Node *slow = head;
    Node *fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    if(fast){
        return slow->next->data;
    }else{
        return slow->data;
    }
}

Node* removeKthNode(Node *head , int k){
    if(head == NULL) return NULL;

    Node *first = head;
    Node *second = head;
    while(k--){
        second = second->next;
    }
    if(second == NULL){
        return first->next;
    }
    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }
    first->next = first->next->next;
    return head;
}

Node *reverseLL(Node *head){
    if(head == NULL) return ;

    Node *prev = NULL;
    Node *curr = NULL;
    
    while(curr != NULL){
        Node *n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;   
    }

    return prev;

}
void takeInput(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* currNode = NULL;
    while(data != -1){
        Node *n = new Node(data);
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            currNode->next = n;
            currNode = n;
        }
        cin>>data;
    }
    return head;
}

listNode* mergeList(listNode *a , listNode *b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    listNode *finalHead = NULL;
    if(a->val < b->val){
        finalHead = a;
        finalHead->next = mergeList(a->next,b);
    }else{
        finalHead = b;
        finalHead->next = mergeList(a,b->next);
    }
    return finalHead;
}

listNode* sortList(listNode *head){
    if(head == NULL) return NULL;

    listNode *slow = head;
    listNode *fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    listNode *n = slow->next;
    slow->next = NULL;
    
    listNode *a = sortList(head);
    listNode *b = sortList(n);

    head = mergeTwoLists(n,head);
    return head;
    
}


int partition(int a[],int s,int e){
    int i = s;
    int pivot = a[e];
    for(int j = s;j <= e-1;j++){
        if(a[j] < pivot){
            swap(a[j],a[i]);
            i++;
        }
    }
    swap(a[i],a[e]);
    return i;
}

void quickSort(int a[],int s,int e){
    if(s >= e){
        return ;
    }
    int i = partition(a,s,e);
    quickSort(a,s,p-1);
    quickSort(a,p+1,e);
    
}

class Queue{
    public :
        int nextIndex = 0;
        int firstIndex = -1;
        int capacity = 0;
        int size = 0;
        int *arr;

        Queue(){
            nextIndex= 0;
            firstIndex = -1;
            capacity = 0;
            size = 0;
            arr = new int[5];
        }

        Queue(int cap){
            nextIndex= 0;
            firstIndex = -1;
            capacity = cap;
            size = 0;
            arr = new int[cap];
        }

        int getSize(){
            return size;
        }
        
        bool isEmpty(){
            return size == 0;
        }

        void push(int element){
            if(size == capacity){
                int *newArr  =  new int[2*capacity];
                int j = 0;
                for(int i = firstIndex;i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0;i < firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                firstIndex = 0;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex = (nextIndex+1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
        }

        void pop(){
            if(isEmpty()){
                cout<<"Queue is empty"<<endl;
                return ;
            }
            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }

        int front(){
            if(isEmpty()){
                cout<<"queue is empty"<<endl;
                return -1;
            }
            return arr[nextIndex - 1];
            

        }
}


class Queue{
    int nextIndex;
    int firstIndex;
    int capacity;
    int size;
    int *arr;
    Queue(){
        arr = new int[5];
        firstIndex = -1;
        nextIndex = 0;
        capacity = 5;
        size = 0;
    }
    Queue(int c){
        arr = new int[c];
        firstIndex = -1;
        nextIndex = 0;
        capacity = c;
        size = 0;
    }

    bool isEmpty(){
        return size == 0;
    }
    int getSize(){
        return size;
    }
    void push(int elem){
        if(size == capacity){
            cout<<"Queue is full"<<endl;
            return ;
        }
        arr[nextIndex] = elem;
        nextIndex = (nextIndex+1)%capacity;
        if(firstIndex == -1){
            firstIndex = 0;
        }
        size++;
    }
    void pop(){
        if(isEmpty()){
            cout<<"Queue is empty"<<endl;
            return ;
        }
        firstIndex = (firstIndex+1)%capacity;
        size--;
        if(size == 0){
            firstIndex = -1;
            nextIndex = 0;
        }
    }
    int front(){
        if(isEmpty()){
            cout<<"Queue is empty"<<endl;
            return -1;
        }
        return arr[firstIndex];
    }
}

int partition(int arr[],int s,int e){
    int i = s;
    int pivot = arr[e];
    for(int j = s;j <= e-1;j++){
        if(a[j] < pivot){
            swap(a[j],a[i]);
            i++;
        }
    }
    swap(a[e],a[i]);
    return i ;
}
void quickSort(int arr[],int s,int e){
    if(s >= e){
        return ;
    }
    int p = partition(arr,s,e);
    quickSort(arr,s,p-1);
    quickSort(arr,p+1,e);
}

class Stack{
    int capacity;
    int nextIndex;
    int *arr;

    Stack(){
        capacity = 5;
        arr = new int[capacity];
        nextIndex = 0;
    }
    Stack(int c){
        capacity = c;
        arr = new int[capacity];
        nextIndex = 0;
    }

    int getSize(){
        return nextIndex;
    }

    bool isEmpty(){
        return nextIndex == 0;
    }
    void push(int element){
        if(nextIndex == capacity){
            cout<<"Stack is full";
            return ;
        }
        arr[nextIndex] = element;
        nextIndex++;
    }
    void pop(){
        if(isEmpty()){
            cout<<"Stack is empty"<<endl;
            return ;
        }
        nextIndex--;
    }
    int top(){
        if(isEmpty()){
            cout<<"Stack is empty"<<endl;
            return 0;
        }
        return arr[nextIndex -1];
    }

}


tree practice from here

template<typename T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> children;

        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(){
            for(int i = 0;i < children.size();i++){
                delete children[i];
            }
        }
}

TreeNode* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    TreeNode<int> *root = new TreeNode<int>(rootData);
    if(root == -1){
        return NULL;
    }
    int numChild;
    cout<<"Enter number of child of "<<rootData<<" : ";
    cin>>numChild;
    for(int i = 1;i <= numChild;i++){
        TreeNode<int>* child = takeInput();
        root->children.push_back(child);
    }
    return root;
}

TreeNode* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root Data : ";
    cin>>rootData;
    TreeNode<int> *root = new TreeNode<int>(rootData);
    queue<TreeNode<int>*> q;
    q.push(root);

    while(!q.empty()){
        TreeNode<int>* front = q.front();
        q.pop();
        int numChild;
        cout<<"Enter number of child for "<<front->data<<" : ";
        cin>>numChild;
        int childData;
        for(int i = 1;i <= numChild;i++){
            cout<<"Enter "<<i<<"th child data : ";
            cin>>childData;
            TreeNode<int> *child = TreeNode<int>(childData);
            front->children.push_back(child);
            q.push(child);
        }
    }
    return root;
}

void print(TreeNode<int>* root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<" , ";
    }
    for(int i = 0;i < root->children.size();i++){
        print(root->children[i]);
    }
}

int countNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int count = 1;
    for(int i = 0;i < root->children.size();i++){
        count += countNode(root->children[i]);
    }
    return count;
}

void printLevelWise(TreeNode<int>* root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int>* front= q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->children.size();i++){
            cout<<front->children[i]->data<<", ";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

int getFirst(vector<int> &nums,int target){
    int s = 0;
    int e = nums.size() -1;
    int ans = 0;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }else if(nums[mid] < target){
            s = mid+1;
        }else{
            end = mid-1;
        }
    }
    return ans;
}

int searchMajority(vector<int> &a){
    int cand = a[0];
    int count = 1;
    int n = a.size();
    for(int i = 1;i < a.size();i++){
        if(a[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                cand = a[i];
                count = 1;
            }
        }
    }
    int count2 = 0;
    for(int i = 0;i < a.size();i++){
        if(cand == a[i]){
            count2++;
        }
    }
    if(count2 >= n/2){
        return cand;
    }else{
        return -1;
    }
}
int mySearch(vector<int> &a , int key){
    int s = 0;
    int e = a.size() -1;
    int n = a.size();
    while(s >= e){
        int mid = (s+e)/2;
        if(a[mid] == key){
            return  mid;
        }else if(a[s] <= a[mid]){
            if(key >= a[s] && key <= mid){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(key >= a[mid] && key <= a[e]){
                s = mid+1;
            }else{
                e = mid-1;
            }
        }
    }
    return -1;   
}

int removeDuplicates(vector<int> &a){
    int n = a.size();
    int pos = 0;
    for(int i = 0;i < n-1;i++){
        if(a[i] != a[i+1]){
            a[++pos] = a[i+1];
        }
    }
    return pos+1;
}

int height(TreeNode* root){
    if(root == NULL){
        return 0;
    }
    int mx = 0;
    for(int i = 0;i <root->children.size();i++){
        mx = max(mx,height(root->children[i]));
    }
    return mx+1;
}

void printAtLevelK(TreeNode* root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data;
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k-1);
    }
}

Node* reverseLL(Node* head){
    if(head == NULL){
        return NULL;
    }
    Node *curr = head;
    Node *prev = NULL;  
    while(curr != NULL){
        Node *n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }
    return prev;
}

Node* mergeList(Node *a,Node *b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    Node *copyhead = NULL;
    if(a->data < b->data){
        copyhead = a;
        copyhead->next = mergeList(a->next,b);
    }else{
        copyhead = b;
        copyhead->next = mergeList(a,b->next);
    }
    return copyhead;
}

Node* sortList(Node *a){
    if(a == NULL) return NULL;

    Node *slow = a;
    Node *fast = a->next;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    Node *n = slow->next;
    slow->next = NULL;

    Node *hel = sortList(n);
    Node *wor = sortList(a);
    
}
int countLeafNode(TreeNode* root){
    if(root == NULL){
        return 0;
    }
    if(root->children.size() == 0){
        return 1;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNode(root->children[i]);
    }
    return ans+1;
}

void preOrder(TreeNode* root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<endl;
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }
}
void postOrder(TreeNode* root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        postOrder(root->children[i]);
    }
    cout<<root->data<<endl;
}

void deleteTree(TreeNode *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        delete root->children[i];
    }
    delete root;
}

template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;

        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }

        ~BTNode(){
            delete left;
            delete right;
        }
}
void printBTreeRecursive(BTNode *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    if(root->left != NULL){
        cout<<root->left->data<<", ";
    }
    if(root->right != NULL){
        cout<<root->right->data;
    }
    cout<<endl;
    printBTreeRecursive(root->left);
    printBTreeRecursive(root->right);
    
}

void printBTreeLevelWise(TreeNode* root){
    if(root == NULL){
        return ;
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        cout<<front->left->data<<", ";
        cout<<front->right->data<<;
        cout<<endl;
        q.push(front->left);
        q.push(front->right);
    }
}

BTNode* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = takeInput();
    root->right = takeInput();
    return root;
}

BTNode* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = new BTNode<int>(rootData);
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int>* front = q.front();
        q.pop();
        cout<<"Enter left data for <<front->data<<" : ";
        int leftData;
        cin>>leftData;
        if(leftData != -1){
            BTNode<int> *left = new BTNode<int>(leftData);
            front->left = left;
            q.push(left);
        }
        cout<<"Enter right data for <<front->data<<" : ";
        int rightData;
        cin>>rightData;
        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            front->right = right;
            q.push(right);
        }
    }
    cout<<endl;
    return root;
}

bool searchNode(BTNode<int> *root,int key){
    if(root == NULL){
        return false;
    }
    if(root->data == key){
        return true;
    }
    return (searchNode(root->left,key) || searchNode(root->right,key) );
}

int minValue(BTNode<int>* root){
    if(root == NULL){
        return INT_MAX;
    }
    int leftMin = minValue(root->left);
    int rightMin = minValue(root->right);
    return min(root->data,min(leftMin,rightMin));
}
int maxValue(BTNode<int>* root){
    if(root == NULL){
        return INT_MIN;
    }
    int leftMax = maxValue(root->left);
    int rightMax = maxValue(root->right);
    return max(root->data,max(leftMax,rightMax));
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right) ;
}
template<typename T>
class TreeNode{
    public :
    T data;
    vector<TreeNode<T>*> children;
    TreeNode(T data){
        this->data = data;
    }
    ~TreeNode(){
        for(int i = 0;i < children.size();i++){
            delete children[i];
        }
    }
}

void printRecursive(TreeNode* root){
    if(root == NULL) return ;

    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<", ";
    }
    cout<<endl;
    for(int i =0 ;i< root->children.size();i++){
        printRecursive(root->children[i]);
    }
}

TreeNode<int>* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        TreeNode<int>* root = new TreeNode<int>(rootData);
    }
    int numChildren;
    cout<<"Enter number of children of "<<rootData;
    cin>>numChildren;

    for(int i = 1;i <= numChildren;i++){
        TreeNode<int> *child = takeInput();
        root->children.push_back(child);
    }
    return root;
}
int countNodes(TreeNode<int>* root){
    if(root == NULL) return 0;
    ans = 1;
    for(int i = 0;i < root->children.size();i++){
        ans += countNode(root->children[i]);
    }
    return ans+1;
}

void printLevelWise(TreeNode<int>* root){
    if(root == NULL) return ;
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->children.size();i++){
            cout<<front->children[i]->data<<" ,";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

int height(TreeNode<int>* root){
    if(root == NULL) return 0;

    int mx = 0;
    for(int i = 0;i < root->children.size();i++){
        mx = max(mx,root->children[i]);
    }
    return mx+1;
}

void printAtLevelK(TreeNode<int>* root,int k){
    if(root == NULL) return ;
    if(k == 0){
        cout<<root->data<<endl;
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k-1);
    }
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL) return 0;
    if(root->children.size() == 0){
        return 1;
    }
    ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNode(root->children[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL) return ;
    cout<<root->data;
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL) return ;
    for(int i = 0;i < root->children.size();i++){
        deleteTree(root->children[i]);
    }
    delete root;
}

template<typname T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> children;
        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(){
            for(int i = 0;i < children.size();i++){
                delete children[i];
            }
        }
}

void print(TreeNode<int>* root){
    if(root == NULL) return ;
    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<" ";
    }
    cout<<endl;
    for(int i = 0;i < root->children.size();i++){
        print(root->children[i]);
    }
}
TreeNode<int>* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    TreeNode<int> *root = new TreeNode<int>(rootData);
    cout<<"Enter number of childrens for "<<rootData<<" : ";
    int numChild;
    cin>>numChild;
    for(int i = 0;i < numChild;i++){
        TreeNode<int> *child = takeInput();
        root->children.push_back(child);
    }
    return root;
}
TreeNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    TreeNode<int> *root = new TreeNode<int>(rootData);
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        int numChild;
        cout<<"Enter num of child of "<<front->data<<" : ";
        cin>>numChild;
        for(int i = 0;i < numChild;i++){
            int childData;
            cout<<"Enter "<<i<<"th child of <<front->data<<" : ";
            cin>>childData;
            TreeNode<int> *child = new TreeNode<int>(childData);
            front->children.push_back(child);
            q.push(child);
        }
    }
    return root;
}

int countNodes(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countNodes(root->children[i]);
    }
    return small+1;
}

void printLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int>* front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->children.size();i++){
            cout<<front->children[i]->data<<", ";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

int height(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans = max(ans,height(root->children[i]));
    }
    return ans+1;
}

void printAtLevelK(TreeNode<int> *root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data<<endl;
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k-1);
    }
}

int countLeafNodes(TreeNode<int>* root){
    if(root == NULL){
        return 0;
    }
    if(root->children.size() == 0){
        return 1;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNodes(root->children[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" ";
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }
}
void postOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        postOrder(root->children[i]);
    }
    cout<<root->data<<" ";
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL) return ;

    for(int i = 0;i < root->children.size();i++){
        delete root->children[i];
    }
    delete root;
}

template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
        ~BTNode(){
            delete left;
            delete right;
        }
}

void printBTreeRecursive(BTNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : L "<<root->left->data<<" R "<<root->right->data;
    cout<<endl;
    printBTreeRecursive(root->left);
    printBTreeRecursive(root->right);
}

void printBTreeLevelWise(BTNode<int> *root){
    if(root == NULL) return ; 
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : "<<"L "<<front->left->data<<" R "<<front->right->data;
        q.push(front->left);
        q.push(front->right);
    }
    cout<<endl;
}

BTNode<int>* takeInputRecursive(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        BTNode<int> *root = new BTNode<int>(rootData);
        root->left = takeInputRecursive();
        root->right = takeInputRecursive();
    }else{
        return NULL;
    }
    return root;
}


BTNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        BTNode<int> *root = new BTNode<int>(rootData);
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left data for "<<front->data<<" : ";
        cin>>leftData;
        if(leftData != -1){
            BTNode<int> *left = new BTNode<int>(leftData);
            front->left = left;
            q.push(left)
        }
        int rightData;
        cout<<"Enter right data for "<<front->data<<" : ";
        cin>>rightData;
        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            front->right = right;
            q.push(right)
        }
    }
    cout<<endl;
    return root;
}

bool searchNode(BTNode<int> *root,int key){
    if(root == NULL) return false;
    if(root == key) return true;
    return searchNode(root->left,key) || searchNode(root->right,key);
}


int minValue(BTNode<int> *root){
    if(root == NULL){
        return INT_MAX;
    }
    return min(root->data,min(minValue(root->right),minValue(root->left)));
}

int countLeafNode(BTNode<int> *root){
    if(root == NULL) return -1;
    if(root->left == NULL && root->right == NULL ){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right); 
}

template<typename T>
class Queue{
    public :
        T *arr;
        int nextIndex = 0;
        int firstIndex = -1;
        int size;
        int capacity;
        Queue(){
            capacity = 5;
            arr = new T[capacity];
            size = 0;
            firstIndex = -1;
            nextIndex = 0;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size==0;
        }
        void push(T element){
            if(size == capacity){
                T *newArr = new T[2*capacity];
                int j = 0;
                for(int i = firstIndex;i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0;i < firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                firstIndex = 0;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex = (nextIndex + 1)%capacity;
            if(firstIndex == -1){
                firstIndex = 0
            }
            size++;
        }
        void pop(){
            if(isEmpty()){
                cout<<"queue is empty ";
                return ;
            }
            firstIndex = (firstIndex + 1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }
        T front(){
            if(isEmpty()){
                cout<<"queue is empty";
                return ;
            }
            return arr[firstIndex] ;
        }
}

template<typename T>
Class BTNode{
    T data;
    BTNode *left;
    BTNode *right;
    BTNode(int data){
        this->data = data;
        left = NULL;
        right = NULL;
    }
    ~BTNode(){
        delete left;
        delete right;
    }
}

BTNode<int>* takeInput(){
    int data;
    cout<<"Enter root value : ";
    cin>>data;
    if(data != NULL){
        BTNode<int>* root = new BTNode(data);
    }
    root->left = takeInput();
    root->right = takeInput();
    return root;
}

BTNode<int>* takeInputLevelWise(){
    int data;
    cout<<"Enter root data : ";
    cin>>data;
    if(data != NULL){
        BTNode<int> *root = new BTNode<int>(data);
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left data for "<<front->data<<" : ";
        cin>>leftData;
        if(leftData != NULL){
            front->left = BTNode<int>(leftData);
            q.push(front->left);
        }
        int rightData;
        cout<<"Enter right data for "<<front->data<<" : ";
        cin>>rightData;
        if(rightData != NULL){
            front->right = BTNode<int>(rightData);
            q.push(front->right);    
        }
    }
    cout<<endl;
    return root;
}

bool searchNode(BTNode<int> *root,int data){
    if(root == NULL){
        return false;
    }
    if(root->data == data){
        return true;
    }
    return searchNode(root->left) || searchNode(root->right);
}

int minValue(BTNode<int> *root){
    if(root == NULL){
        return INT_MAX;
    }

    return  min(root->data , min(minValue(root->left),minValue(root->right)));
}

int countLeafNode(BTNode<int>* root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right);
}

BTNode<int>* buildTreeHelper(vector<int> &inOrder,vector<int> &preOrder,int inS,int inE,int preS,int preE){
    if(inS > inE){
        return NULL;
    }   
    int rootData = preOrder[preS];
    int rootIndex = -1;
    for(int i = inS ; i <= inE;i++){
        if(inOrder[i] == rootData){
            rootIndex = i;
        }
    }

    int leftPreS = preS + 1;
    int leftPreE = leftPreS + leftInE - leftInS;
    int leftInS = inS;
    int leftInE = rootIndex -1;


    int rightPreS = leftPreE + 1;
    int rightPreE = preE;
    int rightInS = rootIndex+1;
    int rightInE = inE;

    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = buildTreeHelper(inOrder,preOrder,leftInS,leftInE,leftPreS,leftPreE);
    root->right = buildTreeHelper(inOrder,preOrder,rightInS,rightInE,rightPreS,rightPreE);
    return root;
}

BTNode<int>* buildTree(vector<int> &inorder,vector<int> &preorder){
    int n = inorder.size();
    BTNode<int>* root = buildTreeHelper(inorder,preorder,0,n-1,0,n-1);
}




#include<bits/stdc++.h>
template<typename T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> child;
        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(){
            for(int i = 0;i < child.size();i++){
                delete child[i];
            }
        }
}

void printRecursive(TreeNode<int>* root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    for(int i = 0;i < root->child.size();i++){
        cout<<root->child[i]->data<<", ";
    }
    cout<<endl;
    for(int i = 0;i < root->child.size();i++){
        printRecursive(root->child[i]);
    }
}

void printLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->child.size();i++){
            cout<<front->child[i]->data<<", ";
            q.push(front->child[i]);
        }
        cout<<endl;
    }
}

TreeNode<int>* takeInputRecursive(){
    int data;
    cout<<"Enter data : ";
    cin>>data;
    if(data != -1){
        TreeNode<int> *root = new TreeNode<int>(data);
    }
    int n;
    cout<<"Enter number of child of "<<root->data;
    cin>>n;
    for(int i = 1;i <= n;i++){
        cout<<"Enter "<<i<<"th data of "<<root->data<<" : ";
        TreeNode<int> *children = takeInputRecursive();
        root->child.push_back(children);
    }
    return root;
}


TreeNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        TreeNode<int> *root = new TreeNode<int>(rootData);
    }    
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<"Enter number of children of "<<front->data<<;
        int n;
        cin>>n;
        int childData;
        for(int i = 1;i <= n;i++){
            cout<<"Enter "<<i<<"th child data for "<<front->data;
            cin>>childData;
            if(childData != -1){
                TreeNode<int> *child = new TreeNode<int>(childData);
                q.push(child);
                front->child.push_back(child);
            }
        }
    }
    return root;
}

int countNodes(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->child.size();i++){
        ans += countNodes(root->child[i]);
    }
    return ans+1;
}

int height(TreeNode<int>* root){
    if(root == NULL){
        return 0;
    }
    int mx = 0;
    for(int i = 0 ;i < root.child.size();i++){
        mx = max(mx,height(root->child[i]));
    }
    return mx+1;
}

void printAtLevelK(TreeNode<int> *root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data;
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        printAtLevelK(root->child[i],k-1);
    }
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->child.size() == 0){
        return 1;
    }
    int ans = 0;
    for(int i = 0;i < root->child.size();i++){
        ans += countLeafNode(root->child[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<", ";
    for(int i = 0;i < root->child.size();i++){
        preOrder(root->child[i]);
    }
}
void postOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        preOrder(root->child[i]);
    }
    cout<<root->data<<", ";
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        delete root->child[i];
    }
    delete root;
}

template<typename T>
class BTNode{
    public :
        T data;
        BTNode *left;
        BTNode *right;
        BTNode(int data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
}

void printBTreeRecursive(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    cout<<root->left->data<<","<<root->right->data;
    cout<<endl;
    printBTreeRecursive(root->left);
    printBTreeRecursive(root->right);
}


void printTreeLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        if(front->left != NULL){
            cout<<" L "<<front->left->data<<", ";
            q.push(front->left);
        }
        if(front->right != NULL){
            cout<<" R "<<front->right->data<<", ";
            q.push(front->right);
        }
        cout<<endl;
    }
}

BTNode<int> * takeInputRecursive(){
    int rootData ;
    cout<<"Enter data ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = BTNode<int>(rootData);
    root->left = takeInputRecursive();
    root->right = takeInputRecursive();
    return root;
}


BTNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    BTNode<int> *root = new BTNode<int>(rootData);
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left data for "<<front->data;
        cin>>leftData;
        if(leftData != -1){
            BTNode<int> *left = new BTNode<int>(leftData);
            front->left = left;
            q.push(left);
        }
        int rightData;
        cout<<"Enter right data for "<<front->data;
        cin>>rightData;
        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            front->left = right;
            q.push(right);
        }
        cout<<endl;
    }
    return root;
}


bool searchNode(BTNode<int> *root,int key){
    if(root == NULL){
        return false;
    }
    if(root->data == key){
        return true;
    }
    return searchNode(root->left) || searchNode(root->right);
}

int minValue(TreeNode<int>* root){
    if(root == NULL){
        return INT_MAX;
    }
    return min(root->data,min(minValue(root->left),minValue(root->right)));
}

int countLeafNode(BTNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right) ;
}

// implementing BST

template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
}

class Pair{
    BTNode<int> *head;
    BTNode<int> *tail;
}

class BST{
    BTNode<int> *root;
    void printTree(BTNode<int> *root){
        if(root == NULL){
            return ;
        }
        cout<<root->data<<" : ";
        if(root->left != NULL){
            cout<<" L "<<root->left->data<<",";
        }
        if(root->right != NULL){
            cout<<" R "<<root->right->data<<;
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }   
    bool hasData(BTNode<int> *root,int data){
        if(root == NULL){
            return false;
        }
        if(root->data == data){
            return true;
        }
        if(root->data > data){
            return hasData(root->left);
        }else{
            return hasData(root->left)    
        }
    }
    BTNode<int>* insert(BTNode<int> *root , int data){
        if(root == NULL){
            BTNode<int> *n = new BTNode<int>(data);
            return n;
        }
        if(root->data < data){
            root->right = insert(root->right,data);
        }else{
            root->left = insert(root->left,data);
        }
        return root;
    }
    BTNode<int>* deleteData(BTNode<int>* root , int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data > data){
            return deleteData(root->left,data);
        }else if(root->data < data){
            return deleteData(root->right,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                delete root;
                return NULL;
            }else if(root->right == NULL){
                BTNode<int> *temp = root->left;
                root->left = NULL;
                delete root;
                return temp;
            }else if(root->left == NULL){
                BTNode<int> *temp = root->right;
                root->right = NULL;
                delete root;
                return temp;
            }else{
                int minNode = root->right;
                while(minNode->left != NULL){
                    minNode = minNode->left;
                }
                int rightMin = minNode->data;
                root->data = rightMin;
                root->right = deleteData(root->right,rightMin);
            }
        }
        return root;
    }
    Pair convertToLL(BTNode<int>* root){
        if(root == NULL){
            Pair ans ;
            ans.head = NULL;
            ans.tail = NULL;
            return ans;
        }
        if(root->right == NULL && root->left == NULL){
            Pair ans;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->right == NULL && root->left != NULL){
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;

        }else if(root->right != NULL && root->left == NULL){
            Pair rightLL = convertToLL(root->right);
            root->right = rightLL.head;
            Pair ans;
            ans.head = root;
            ans.tail = rightLL.tail;
            return ans;
        }else{
            Pair leftLL = convertToLL(root->left);
            Pair rightLL = convertToLL(root->right);
            leftLL.tail->right = root;
            root->right = rightLL.head;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }

}

TreeNode* buildTreeHelper(vector<int> &inorder , vector<int> &postOrder, int inS,int inE,int postS,int postE){
    if(inS > inE){
        return NULL;
    }

    int rootData = postOrder[postE];
    int rootIndex = -1;
    for(int i = inS,i <= inE;i++){
        if(inorder[i] == rootData){
            rootIndex = i;
            break ;
        }
    }

    int leftInS = inS;
    int leftInE = rootIndex -1;
    int leftPostS = postS;
    int leftPostE = leftPostS + leftInE - leftInS ;

    int rightInS = rootIndex + 1;
    int rightInE = inE;
    int rightPostS = leftPostE +1;
    int rightPostE = postE - 1;

    TreeNode* root = new TreeNode(rootData);
    root->left = buildTreeHelper(inorder,postOrder,leftInS,leftInE,leftPostS,leftPostE);
    root->right = buildTreeHelper(inorder,postOrder,rightInS,rightInE,rightPostS,rightPostE);
    return root;
}


TreeNode* buildTree(vector<int> &postOrder , vector<int> &inOrder){
    int n = postOrder.size();
    TreeNode* root = buildTreeHelper(inOrder,postOrder,0,n-1,0,n-1);
    return root;
}

bool isSymmetricHelper(TreeNode* leftTree,TreeNode* rightTree){
    if(leftTree == NULL && rightTree != NULL ) return false;
    if(leftTree != NULL && rightTree == NULL ) return false;
    if(leftTree == NULL && rightTree == NULL ) return true;
    if(leftTree->val != rightTree->val) return false;

    return isSymmetricHelper(leftTree->left,rightTree->right) && isSymmetricHelper(leftTree->right,rightTree->left);
}

bool isSymmetric(TreeNode* root){
    if(root == NULL) return true;
    return isSymmetricHelper(root->left,root->right);
}


bool getPath(TreeNode* root, int val ,vector<int> &ans){
    if(root == NULL) return false;
    ans.push_back(root->val);
    if(root-> val == val){
        returnt true;
    }
    bool left = getPath(root->left,val,ans);
    bool right = getPath(root->right,val,ans);

    if(left || right){
        return true;
    }
    ans.pop_back();
    return false;
}

int getDiameter(TreeNode* root){
    if(root == NULL){
        return 0;
    }

    int option1 = height(root->left) + height(root->right);
    int option2 = getDiameter(root->left);
    int option3 = getDiameter(root->right);

    return max(option1,max(option2,option3));
}


template<typename T>
class Queue{
    public :
        int nextIndex ;
        int firstIndex ;
        int capacity;
        int size;
        T *arr;
        Queue(int capacity){
            this->capacity = capacity;
            size = 0;
            nextIndex = 0;
            firstIndex = -1;
            arr = new T[capacity];
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size == 0;
        }
        void push(T element){
            if(size == capacity){
                T *newArr = new T[2*capacity];
                int j =0;
                for(int i = firstIndex ; i<capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0 ; i<firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
                firstIndex = 0;
            }
            arr[nextIndex] = element;
            nextIndex = (nextIndex+1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
        }
        void pop(){
            if(isEmpty()){
                cout<<"queue is empty";
                return ;
            }
            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }
        T front(){
            if(isEmpty()){
                cout<<"queue is empty";
                return 0;
            }
            return arr[firstIndex];
        }


}

class Node{
    public :
        int data;
        Node* next;
        Node(int data){
            this->data = data;
            next = NULL;
        }
}

class Queue{
    Node* head;
    Node* tail;
    int size;
    public :
        Queue(){
            head = NULL;
            tail = NULL;
            size = 0;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size == 0;
        }
        void push(int data){
            Node *n = new Node(data);
            if(head == NULL){
                head = n;
                tail = n;
            }else{
                tail->next = n;
                tail = n;
            }
            size++;
        }
        int front(){
            if(isEmpty()){
                cout<<"queue is empty";
                return 0;
            }
            return head->data;
        }
        void pop(){
            if(isEmpty()){
                cout<<"queue is empty";
                return ;
            }
            Node *temp = head;
            head = head->next;
            temp->next = NULL;
            delete temp;
            size--;
        }

}


template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
        ~BTNode(){
            delete left;
            delete right;
        }
}

class Pair{
    public :
    BTNode<int> *head;
    BTNode<int> *tail;
}


class BST{
    BTNode<int> *head;

    void printTree(BTNode<int>* root){
        if(root == NULL){
            return ;
        }
        cout<<root->data<<" : ";
        
        if(root->left != NULL){
            cout<<" L "<<root->left->data<<", ";
        }
        if(root->right != NULL){
            cout<<" R "<<root->right->data;
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }

    bool hasData(BTNode<int> *root,int data){
        if(root == NULL){
            return false;
        }
        if(root->data == data){
            return true;
        }
        if(root->data > data){
            return hasData(root->left , data)
        }else{
            return hasData(root->right,data);
        }
    }

    BTNode<int>* insert(BTNode<int>* root,int data){
        if(root == NULL){
            BTNode<int> *n = new BTNode<int>(data);
            return n;
        }
        if(root->data > data){
            root->left = insert(root->left,data);
        }else{
            root->right = insert(root->right,data);
        }
        return root;
    }

    BTNode<int>* deleteData(BTNode<int>* root , int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data > data){
            root->left = deleteData(root->left , data);
        }else if(root->data < data){
            root->right = deleteData(root->right,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                delete root;
                return NULL;
            }else if(root->left == NULL){
                BTNode<int> *temp = root->right;
                root->right = NULL;
                delete root;
                return temp;
            }else if(root->right == NULL){
                BTNode<int> *temp = root->left;
                root->left = NULL;
                delete root;
                return temp;
            }else{
                BTNode<int> *minNode = root->right;
                while(minNode->left != NULL){
                    minNode = minNode->left;
                }
                int minData = minNode->data;
                root->data = minData;
                root->right = deleteData(root->right,minData);
                return root;
            }
        }
        return root;
    }
    Pair convertToLL(BTNode<int> *root){
        if(root == NULL){
            Pair ans ;
            ans.head = NULL;
            ans.tail = NULL;
            return ans;
        }
        if(root->left == NULL && root->right == NULL){
            Pair ans ;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->left != NULL){
            Pair ans;
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;
        }else if(root->right != NULL){
            Pair ans;
            Pair rightLL = convertToLL(root->right);
            root->right = rightLL.head;
            ans.head = root;
            ans.tail = rightLL.tail;
            return ans;
        }else{
            Pair leftLL = convertToLL(root->left);
            Pair rightLL = convertToLL(root->right);
            leftLL.tail->right = root;
            root->right = rightLL.head;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }
}


int rangeSumInBST(BTNode<int> *root,int L,int R){
    if(root == NULL){
        return 0;
    }
    int sum = 0;
    if(root->val >= L && root->val <= R){
        sum += root->val;
    }
    if(root->val < L){
        sum += rangeSumInBST(root->right,L,R);
    }else if(root->val > R){
        sum += rangeSumInBST(root->left,L,R);
    }else{
        sum += rangeSumInBST(root->right,L,R) + rangeSumInBST(root->left,L,R);
    }
    return sum;
}

BTNode<int>* convertSortedArrToBST(vector<int> &nums,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    int rootData = nums[mid];
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = convertSortedArrToBST(nums,s,mid-1);
    root->right = convertSortedArrToBST(nums,mid+1,e);
    return root;
}

bool rootToNodePath(BTNode<int> *root , int data,vector<int> &ans ){
    if(root == NULL){
        return false;
    }
    ans.push_back(root->val);
    if(root->val == data){
        return true;
    }
    bool left = rootToNodePath(root->left,data,ans);
    bool right = rootToNodePath(root->right,data,ans);
    if(left || right){
        return true;
    }
    ans.pop_back();
    return false;
}


class Stack{
    public :
        int *arr;
        int capacity;
        int nextIndex;
        Stack(){
            arr = new int[5];
            capacity = 5;
            nextIndex = 0;
        }
        Stack(int cap){
            arr = new int[cap];
            capacity = cap;
            nextIndex = 0;
        }
        int getSize(){
            return nextIndex;
        }
        bool isEmpty(){
            return nextIndex == 0;
        }
        void push(int data){
            if(nextIndex == capacity){
                int *newArr = new int[2*capacity];
                for(int i = 0;i < capacity;i++){
                    newArr[i] = arr[i];
                }
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex++;
        }
        int top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            return arr[nextIndex - 1];
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            nextIndex--;
        }
}

class Stack{
    public :
        Node *head;
        int size;
        Stack(){
            head = NULL;
            size = 0;
        }
        bool isEmpty(){
            return size == 0;
        }
        int getSize(){
            return size;
        }
        void push(int data){
            Node *n = new Node(data);
            n->next = head;
            head = n;
            size++;
        }
        void pop(){
            Node *temp = head;
            temp->next = NULL;
            delete temp;
            head = head->next;
            size--;
        }
        int top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return 0;
            }
            return head->data;
        }
}


template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
        ~BTNode(){
            delete left;
            delete right;
        }
}


class Pair{
    public :
        BTNode<int> *head;
        BTNode<int> *tail;
}

class BST{
    BTNode<int> *root;

    void printTree(BTNode<int> *root){
        if(root == NULL) return ;
        cout<<root->data<<" : ";
        if(root->left){
            cout<<root->left->data<<", ";
        }
        if(root->right){
            cout<<root->right->data<<", ";
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }

    bool hasData(BTNode<int> *root,int data){
        if(root == NULL) return false;
        if(root->data == data) return true;
        if(data < root->data){
            return hasData(root->left);
        }else{
            return hasData(root->right);
        }
    }

    BTNode<int>* insert(BTNode<int> *root ,int data){
        if(root == NULL){
            BTNode<int> *n = new BTNode<int>(data);
            return n;
        }
        if(root->data > data){
            root->left = insert(root->left,data);
        }else{
            root->right = insert(root->right,data);
        }
        return root;
    }

    BTNode<int>* deleteData(BTNode<int> *root,int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data < data){
            root->right = deleteData(root->right,data);
        }else if(root->data > data){
            root->left = deleteData(root->left,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                root->data = NULL;
                return root;
            }else if(root->left == NULL){
                Node<int> *temp = root;
                root = root->right;
                temp->right = NULL;
                delete temp;
                return root;
            }else if(root->right == NULL){
                Node<int> *temp = root;
                root = root->left;
                temp->left = NULL;
                delete temp;
                return root;
            }else{
                BTNode<int> *minNode = root->right;
                while(minNode->left != NULL){
                    minNode = minNode->left;
                }
                int minData = minNode->data;
                root->data = minData;
                root->right = deleteData(root->right,minData);
                return root;
            }
        }
    }
    Pair convertToLL(BTNode<int> *root){
        if(root == NULL){
            Pair ans;
            ans.head = NULL;
            ans.tail = NULL;
            retur ans;    
        }
        if(root->left == NULL && root->right == NULL){
            Pair ans;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->left == NULL){
            Pair ans;
            Pair rightLL= convertToLL(root->right);
            root->right = rightLL.head;
            ans.head = root;
            ans.tail = rightLL.tail;
            return ans;
        }else if(root->right == NULL){
            Pair ans;
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;
        }else{
            Pair rightLL = convertToLL(root->right);
            Pair leftLL = convertToLL(root->left);
            lefLL.tail->right = root;
            root->right = rightLL.head;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }

    public :
        BST(){
            root = NULL;
        }
        ~BST(){
            delete root;
        }
        BTNode<int>* insert(int data){
            return insert(root,data);
        }
        BTNode<int>* delete(int data){
            return deleteData(root,data);
        }
        bool hasData(int data){
            return hasData(root,data);
        }
        void printTree(){
            printTree(root);
        }
        BTNode<int>* convertToLL(){
            Pair p = convertToLL(root);
            BTNode<int> *tmp = p.head;
            while(tmp != NULL){
                tmp->left = NULL;
                tmp = tmp->right;
            }
            return p.head;
        }
}

BTNode<int>* helper(vector<int> &nums,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    int rootData = nums[mid];
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);
    return root;
}


BTNode<int>* convertSortedArrayToBST(vector<int> &nums){
        n = nums.size();
        BTNode<int> *root = helper(nums,0,n-1);
        return root;
}

int maxInBST(BTNode<int> *root){
    if(root = NULL){
        return -1;
    }

    int max = INT_MIN;
    while(root != NULL){
        max = root->data;
        root = root->right;
    }
    return max;
}
bool searchInBST(BTNode<int> *root,int data){
    if(root == NULL) return false;
    if(root->data == data) return true;
    if(root->data < data){
        return searchInBST(root->right,data);
    }else{
        return searchInBST(root->left,data);
    }
}

int rangeSumInBST(BTNode<int> *root,int L,int R){
    if(root == NULL) return 0;
    int sum = 0;
    if(root->data >= L && root->data <= R){
        sum += root->data;
    }
    if(root->data < L){
        sum += rangeSumInBST(root->right,L,R);
    }else if(root->data > R){
        sum += rangeSumInBST(root->left,L,R);
    }else{
        sum += rangeSumInBST(root->right,L,R) + rangeSumInBST(root->left,L,R);
    }
    return sum;
}

bool helper(BTNode<int> *root,long long minV = -10000000000,long long maxV = 10000000000){
    if(root == NULL) return true;
    bool left = helper(root->left,minV,root->val);
    bool right = helper(root->right,root->val,maxV);
    if(left && right && root->val > minV && root->val < maxV) return true;
    else return false;
}

bool validateBST(BTNode<int> *root){
    return helper(root);
}

class Stack{
    public :
        int nextIndex;
        int *arr;
        int capacity;
        Stack(){
            capacity = 5;
            arr = new int[capacity];
            nextIndex= 0;
        }
        Stack(int cap){
            capacity = cap;
            arr = new int[capacity];
            nextIndex= 0;
        }
        int getSize(){
            return nextIndex;
        }
        bool isEmpty(){
            return nextIndex == 0;
        }
        void push(int data){
            if(capacity == nextIndex){
                int *newArr = new int[2*capacity];
                for(int i=0;i < nextIndex;i++){
                    newArr[i] = arr[i];
                }
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = data;
            nextIndex++;
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            nextIndex--;
        }
        int top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return -1;
            }
            return arr[nextIndex-1];
        }
}



void removeAdjacentDuplicates2(string input){
    stack<char> s;
    for(int i = 0;i < input.size();i++){
        if(s.empty() || s.top() != input[i]){
            s.push_back(input[i]);
        }
    }
    
}
void removeAdjacentDuplicates(string input){
    int strptr = -1;
    int n = input.size();
    //string ans;
    for(int i = 0;i < n;i++){
        if(strptr == -1 || input[i] != input[strptr]){
            strptr++;
            input[strptr] = input[i];
        }else{
            strptr--;
        }
    }
    string ans = "";
    for(int i = 0;i <= strptr;i++){
        ans.push_back(input[i]);
    }
    return ans;
}


template<typename T>
class MapNode{
    public :
        string key;
        T value;
        MapNode* next;
        MapNode(string key,V value){
            this->key = key;
            this->value = value;
            this->next = NULL;
        }
        ~MapNode(){
            delete next;
        }
}

template<typename T>
class Mymap{
    int numBuckets ;
    MapNode<T> ** buckets;
    int count;
    int getBucketIndex(string key){
        int hashcode = 0;
        int base = 1;
        int p = 37;
        for(int i = 0;i < key.size();i++){
            hashcode += key[i] * base;
            base = base*p;
            hashcode = hashcode%numBuckets;
            base = base%numBuckets;
        }
        return hashcode%numBuckets;
    }

    void rehash(){
        MapNode<T> **temp = buckets;
        buckets = new MapNode<T>*[2*numBuckets];
        int oldBucketSize = numBuckets;
        numBuckets *= 2;
        count = 0;
        for(int i = 0;i < 2*numBuckets;i++){
            buckets[i] = NULL;
        }
        for(int i=0;i <oldBucketSize;i++){
            MapNode<T> *head = temp[i];
            while(head != NULL){
                V value = head->value;
                string key = head->key;
                insert(key,value);
                head=head->next;
            }
        }
        for(int i = 0;i < oldBucketSize;i++){
            delete temp[i];
        }
        delete []temp;
    }
    public :
        Mymap(){
            count = 0;
            numBuckets = 5;
            buckets = new MapNode<T>*[numBuckets];
            for(int i = 0;i < numBuckets;i++){
                buckets[i] = NULL;
            }
        }
        ~Mymap(){
            for(int i = 0;i < numBuckets;i++){
                delete buckets[i];
            }
            delete []buckets;
        }
        int size(){
            return count;
        }
        V getValue(string key){
            int keyIndex = getBucketIndex(key);
            MapNode<T> *head = buckets[keyIndex];
            while(head != NULL){
                if(head->key = key){
                    return head->value;
                }
                head = head->next;
            }
            return NULL;
        }
        void insert(string key, T value){
            int keyIndex = getBucketIndex(key);
            MapNode<T> *head = buckets[keyIndex];
            while(head != NULL){
                if(head->key == key){
                    head->value = value;
                }
                head = head->next;
            }
            MapNode<T> *n = new MapNode<T>(key,value);
            n->next = buckets[keyIndex];
            bucket[keyIndex] = n;
            count++;
            if(getLoadFactor() > 0.7){
                rehash();
            }
        }
        V remove(string key){
            int keyIndex = getBucketIndex(key);
            MapNode<V> *head = buckets[keyIndex];
            MapNode<V> *prev = NULL;
            while(head != NULL){
                if(head->key == key){
                    if(prev == NULL){
                        buckets[keyIndex] = head->next
                    }else{
                        prev->next = head->next;
                    }
                    V value = head->value;
                    head->next = NULL;
                    delete head;
                    count--;
                    return value;
                }
                prev = head;
                head = head->next;
            }
        }
        double getLoadFactor(){
            return (1.0)*count/numBuckets;
        }
}

template<typename T>
class MapNode{
    public :
        string key;
        T value;
        MapNode<T> *next;
        MapNode(string key,T value){
            this->key = key;
            this->value = value;
        }
        ~MapNode(){
            delete next;
        }
}

template<typename T>
class MyMap{
    private : 
        MapNode<T>** buckets;
        int count;
        int numBuckets;

        int getBucketIndex(string key){
            int hashcode = 0;
            int p = 37;
            int base = 1;
            for(int i = key.size() - 1;i >= 0;i--){
                hashcode += key[i]*base;
                base = base*p;
                hashcode = hashcode%numBuckets;
                base = base%numBuckets;
            }
            return hashcode%numBuckets;
        }

        void rehash(){
            MapNode<T> **
        }

    public :
        MyMap(){
            numBuckets = 5;
            buckets = new MapNode*<T>[numBuckets];
            size = 0;
        }
        ~MyMap(){
            for(int i = 0;i < numBuckets;i++){
                delete buckets[i];
            }
        }
        int size(){
            return count;
        }
        V getValue(string key){
            int bucketIndex = getBucketIndex(key);
            MapNode<V> *head = buckets[bucketIndex];
            while(head != NULL){
                if(head->key == key){
                    return head->value;
                }
                head = head->next;
            }
            return 0;
        }
        void insert(string key,V value){
            int bucketIndex = getBucketIndex(key);
            MapNode<T> *head = buckets[bucketIndex];
            while(head != NULL){
                if(head->key == key){
                    head->value = value;
                    return ;
                }
                head = head->next;
            }
            MapNode<V>* n = new MapNode<V>(key,value);
            n->next = buckets[bucketIndex];
            bucket[bucketIndex] = n;
            count++;
            if(getLoadFactor() >= 0.7){
                rehash();
            }
        }
        V remove(string key){
            int bucketIndex = getBucketIndex(key);
            MapNode<T> *head = bucket[bucketIndex];
            MapNode<T> *prev;
            while(head != NULL){
                if(head->key == key){
                    if(prev == NULL){
                        bucket[bucketIndex] = head->next;
                    }else{
                        prev->next = head->next;
                    }
                    head->next = NULL;
                    V value = head->value;
                    delete head;
                    count--;
                    return value;
                }
                prev = head;
                head = head->next;
            }
            return 0;
        }
        double getLoadFactor(){
            return (1.0)*count/numBuckets;
        }
}


void rehash(){
    MapNode<T> **temp = buckets;
    buckets = new MapNode<T>*[2*numBuckets];
    int oldBucketSize = numBuckets;
    numBuckets = 2*numBuckets;
    count = 0;
    for(int i = 0;i < oldBucketSize;i++){
        buckets[i] = NULL;
    }
    for(int i = 0;i < oldBucketSize;i++){
        MapNode<T> *head = temp[i];
        while(head != NULL){
            string key = head->key;
            T value = head->value;
            insert(key,value);
            head = head->next;
        }
    }
    for(int i = 0;i < oldBucketSize;i++){
        delete temp[i];
    }
    delete []temp;
}

int getBucketIndex(string key){
    int hashcode = 0;
    int base = 1;
    int p = 37;
    for(int i = key.size() - 1 ;i >= 0;i--){
        hashcode += key[i]*base;
        base = base *p;
        hashcode %= numBuckets;
        base %= numBuckets;
    }
    return hashcode%numBuckets;
}

void insert(string key,T value){
    int bucketIndex = getBucketIndex(key);
    MapNode<V> *bucketHead = buckets[bucketIndex];
    while(bucketHead != NULL){
        if(buckHead->key == key){
            bucketHead->value = value;
            return ;
        }
        bucketHead = bucketHead->next;
    }
    MapNode<V> *node = new MapNode<V>(key,value);
    node->next = buckets[bucketIndex];
    buckets[bucketIndex] = node;
    count++;
    double loadFactor = (1.0*count)/numBuckets;
    if(loadFactor > 0.7){
        rehash();
    }
}

class PriorityQueue{
    vector<int> pq;
    public :
        PriorityQueue(){

        }
        int getMin(){
            return pq[0];
        }
        bool isEmpty(){
            return pq.size() == 0;
        }
        int getSize(){
            return pq.size();
        }
        void insert(int element){
            pq.push_back(element);
            int CI = pq.size() - 1;
            while(CI > 0){
                int PI = (CI -1)/2;
                if(pq[PI] > pq[CI]){
                    swap(pq[PI],pq[CI]);
                    CI = PI;
                }else{
                    break;
                }
            }
            return CI;
        }
        void removeMin(){
            if(isEmpty()){
                return 0;
            }
            int ans = pq[0];
            swap(pq[0],pq[pq.size() - 1]);
            pq.pop_back();

            int pi = 0;
            while(true){
                int lci = 2*pi + 1;
                int rci = 2*pi +2;
                int mini = pi;

                if(pq[lci] < pq.size() && pq[lci] < pq[mini]){
                    mini = lci
                }
                if(pq[rci] < pq.size() && pq[rci] < pq[mini]){
                    mini = rci;
                }
                if(mini == pi){
                    break;
                }

                swap(pq[mini],pq[pi]);
                p = mini;
           }
        }
}

template<typename T>
class MapNode{
    public :
        string key;
        T value;
        Mapnode<T> *next;
        MapNode(string key,V value){
            this->key = key;
            this->value = value;
            next = NULL;
        }
        ~MapNode(){
            delete next;
        }
}


template<typename T>
class MyMap{
    int size;
    int numBuckets;
    MapNode<T> **buckets;
    int getBucketIndex(string key){
        int hashcode = 0;
        int base = 1;
        int p = 37;
        for(int i = key.size() -1;i > 0;i--){
            hashcode += key[i]*base;
            base = base*p;
            hashcode = hashcode%numBuckets;
            base = base%numBuckets;
        }
        return hashcode%numBuckets;
    }
    void rehash(){
        MapNode<T> **temp = buckets;
        buckets = new buckets<T>*[2*numBuckets];
        int oldBucketSize = numBuckets;
        numBuckets = numBuckets*2;
        size = 0;
        for(int i = 0;i < oldBucketSize;i++){
            buckets[i] = NULL;
        }
        for(int i = 0;i < oldBucketSize;i++){
            MapNode<T> *head = buckets[i];
            while(head != NULL){
                string key = head->key;
                T value = head->value;
                insert(key,value);
                head = head->next;
            }
        }
        for(int i = 0;i <oldBucketSize;i++){
            delete temp[i];
        }
        delete []temp;
    }
    public : 
    MyMap(){
        size = 0;
        numBuckets = 5;
        buckets = new MapNode<T>*[numBuckets];
        for(int i = 0;i < numBuckets;i++){
            buckets[i] = NULL;
        }
    }
    ~MyMap(){
        for(int i = 0;i < numBuckets;i++){
            delete buckets[i];
        }
        delete []buckets;
    }
    int getSize(){
        return size;
    }
    V getValue(string key){
        int bIndex = getBucketIndex(key);
        MapNode<T> *head = buckets[bIndex];
        while(head != NULL){
            if(head->key == key){
                return head->value;
            }
            head = head->next;
        }
        return NULL;
    }
    void insert(string key, V value){
        int bIndex = getBucketIndex(key);
        MapNode<T> *head = buckets[bIndex];
        while(head != NULL){
            if(head->key == key){
                head->value = value;
            }
            head = head->next;
        }

        MapNode<T> *node = MapNode<T>(key,value);
        node->next = bucket[bIndex];
        buckets[bIndex] = node;
        size++;
        int loadFactor = (1.0*size)/numBuckets;
        if(loadFactor > 0.7){
            rehash();
        }
    }
    V remove(string key){
        int bIndex = getBucketIndex(key);
        MapNode<T> *head = buckets[bIndex];
        MapNode<T> *prev = NULL;
        while(head != NULL){
            if(head->key == key){
                if(prev == NULL){
                    buckets[bIndex] = head->next;
                }else{
                    prev->next = head->next;
                }
                V value = head->value;
                head->next = NULL;
                delete head;
                count--;
                return value;
            }
            prev = head;
            head = head->next;
        }
        return NULL;    
    }
}

template<typename T>
class BTNode{
    T data;
    BTNode<T> *left;
    BTNode<T> *right;
    BTNode(T data){
        this->data = data;
        left = NULL;
        right = NULL;
    }
    ~BTNode(){
        delete left;
        delete right;
    }
}

template<typename T>
class Pair{
    BTNode<T> *head;
    BTNode<T> *tail;
}


template<typename T>
class BST{
    BTNode<T> *root;
    
    void printTree(BTNode<T> *root){
        if(root == NULL){
            return ;
        }
        cout<<root->data<<" : ";
        if(root->left){
            cout<<" L "<<root->left->data;
        }
        if(root->right){
            cout<<" R "<<root->right->data;
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }

    bool hasData(BTNode<T> *root;int data){
        if(root == NULL){
            return false;
        }
        if(root->data == data){
            return true;
        }
        if(root->data < data){
            return hasData(root->right);
        }
        if(root->data > data){
            return hasData(root->left);
        }
    }

    BTNode<T>* insert(BTNode<T>* root,int data){
        if(root== NULL){
            BTNode<T> *n = new BTNode<T>(data);
            return n;
        }
        if(root->data > data){
            root->left = insert(root->left,data);
        }
        if(root->data < data){
            root->right = insert(root->right,data);
        }
        return root;
    }
    BTNode<T>* delete(BTNode<T> *root,int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data > data){
            root->left = delete(root->left,data);
        }else{
            root->right = delete(root->right,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                delete root;
                return NULL;
            }else if(root->left == NULL){
                BTNode<T> *temp = root->right;
                root->right = NULL;
                delete root;
                return temp;
            }else if(root->right == NULL){
                BTNode<T> *temp = root->left;
                root->left = NULL;
                delete root;
                return temp;
            }else{
                BTNode<T> *minRight = root->right;
                while(minRight != NULL){
                    minRight = minRight->left;
                }
                int minData = minRight->data;
                root->data = minData;
                root->right = delete(root->right,minData);
                return root;
            }
        }
    }

    Pair convertToLL(BTNode<T> *root){
        if(root == NULL){
            Pair ans;
            ans.head = NULL;
            ans.tail = NULL;
            return ans;
        }
        if(root->left == NULL && root->right == NULL){
            Pair ans;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->left == NULL){
            Pair ans;
            Pair rightLL = convertToLL(root->right);
            root->right = rightLL.head;
            ans.head = root;
            ans.tail = rightLL.tail
            return ans;
        }else if(root->right == NULL){
            Pair ans;
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;
        }else{
            Pair rightLL = convertToLL(root->right);
            Pair leftLL = convertToLL(root->left);
            Pair ans;
            leftLL.tail->right = root;
            root->right = rightLL.head;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }
    public :
        BST(){
            root == NULL;
        }
        ~BST(){
            delete root;
        }

        void deleteData(int data){
            return delete(root,data);
        }

        void insert(int data){
            return insert(root,data);
        }

        bool hasData(int data){
            return hasData(root,data);
        }

        void print(){
            printTree(root);
        }

        BTNode<T>* convertToLL(){
            Pair p = convertToLL(root);
            BTNode<T> *tmp = p.head;
            while(tmp != NULL){
                tmp->left = NULL;
                tmp = tmp->right;
            }
            return p.head;
        }
}


void inplaceHeapSort(int *pq,int n){


    //building min heap
    for(int i = 1;i < n;i++){
        int CI = i;
        while(CI > 0){
            int PI = (CI-1)/2;
            if(pq[PI] > pq[CI]){
                swap(pq[PI],pq[CI]);
                CI = PI;
            }else{
                break;
            }
        }
    }
    int size = n;
    while(size >= 1){
        swap(pq[0],pq[size-1]);
        size--;

        int pi = 0;
        while(true){
            int lci = 2*pi + 1;
            int rci = 2*pi + 2;
            int mini = pi;

            if(lci < size && pq[lci] < pq[mini]){
                lci = mini;
            }
            if(rci < size && pq[rci] < pq[mini]){
                rci = mini;
            }
            if(mini == pi){
                break;
            }
            swap(pq[mini],pq[pi]);
            pi = mini;
        }
    }
}


BTNode<T>* helper(vector<int> &input,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    BTNode<T> *root = input[mid];
    root->left = helper(root->left,s,mid-1);
    root->right = helper(root->right,mid+1,e);
    return root;
}

BTNode<T>* convertToBST(vector<int> a){
    int n = a.size();
    return helper(a,0,n-1);
}

int maxInBST(BTNode<int> *root){
    if(root == NULL){
        return NULL;
    }
    int ans = 0;
    while(root != NULL){
        ans = root->val;
        root = root->right;
    }
    return ans;
}

int minInBST(BTNode<int> *root){
    if(root == NULL){
        return -1;
    }
    int ans = INT_MAX;
    while(root != NULL){
        ans = root->val;
        root = root->left;
    }
    return ans;
}


int rangeSumInBST(BTNode<int> *root,int L, int R){
    if(root == NULL){
        return 0;
    }
    int sum = 0;
    if(root->val >= L && root->val <= R){
        sum += root->val;
    }
    if(root->val < L){
        sum += rangeSumInBST(root->right,L,R) ;
    }else if(root->val > R){
        sum += rangeSumInBST(root->left,R);
    }else{
        sum += rangeSumInBST(root->right,L,R) + rangeSumInBST(root->left,R);
    }
    return sum;
}

bool searchInBST(BTNode<int> *root,int data){
    
    
    while(root != NULL){
        if(root->val == data){
            return true;
        }
        if(root->val > data){
            root = root->left;
        }else{
            root= root->right;
        }
    }
    return NULL;
}

template<typename T>
class BTNode{
    public :
        BTNode<T> *left;
        BTNode<T> *right;
        T data;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
}


void printTreeRecursive(BTNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    if(root->left){
        cout<<" L "<<root->left->data;
    }
    if(root->right){
        cout<<" R "<<root->right->data;
    }
    cout<<endl;
    printBTreeLevelWise(root->left);
    printBTreeRecursive(root->right);
}


void printBTreeLevelWise(BTNode<T> *root){
    if(root == NULL){
        return ;
    }
    queue<int> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        if(front != NULL){
            cout<<front->data<<" : ";
        }
        if(front->left){
            cout<<front->left->data;
            q.push(front->left);
        }
        if(front->right){
            cout<<front->right->data;
            q.push(front->right);
        }
        cout<<endl;
    }
}


BTNode<int> *takeInputRecursive(){
    int rootData;
    cout<<"Enter data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = takeInputRecursive();
    root->right = takeInputRecursive();
    
    return root;

}


BTNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left child for "<<front->data;
        cin>>leftData;
        if(leftData != NULL){
            BTNode<int> *left = new BTNode<int>(leftData);
            root->left = left;
            q.push(left);
        }
        int rightData;
        cout<<"Enter right child for "<<front->data;
        cin>>rightData;
        if(rightData != NULL){
            BTNode<int> *right = new BTNode<int>(rightData);
            root->right = right;
            q.push(right);
        }
        cout<<endl;
    }
    return root;
}


bool searchNode(BTNode<int> *root,int data){
    if(root == NULL){
        return false;
    }
    if(root->val == data){
        return true;
    }
    return searchNode(root->left,data) || searchNode(root->right,data);

}


int minValue(BTNode<int> *root){
    if(root == NULL){
        return INT_MAX;
    }
    ans = min(root->val,min(minValue(root->right),minValue(root->left)));
    return ans;
}

int maxValue(BTNode<int> *root){
    if(root == NULL){
        return INT_MIN;
    }
    int leftMax = maxValue(root->left);
    int rightMax = maxValue(root->right);
    return max(root->val,max(leftMax,rightMax));
}


int countLeafNode(BTNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    int left = countLeafNode(root->left);
    int right = countLeafNode(root->right);
    return left + right;
}

BTNode<int>* buildTreeHelper(vector<int> &in,vector<int> &post,inS,inE,postS,postE){

    if(inS > inE){
        return NULL;
    }

    int rootData = post[postE];
    int rootIndex = -1;
    for(int i = 0;i < in.size();i++){
        if(rootData == in[i]){
            rootIndex = i;
        }
    }
    
    int leftInS = inS;
    int leftInE = rootIndex - 1;
    int leftPostS = postS;
    int leftPostE = leftPostS + leftInE - leftInS ;

    int rightInS = rootIndex +1;
    int rightInE = inE;
    int rightPostS = leftPostE + 1;
    int rightPostE = postE - 1;

    BTode<int> *root = BTNode<int>(rootData);
    root->left = buildTreeHelper(in,post,leftInS,leftInE,leftPostS,leftPostE);
    root->right = buildTreeHelper(in,post,rightInS,rightInE,rightPostS,rightPostE);

    return root;



}

void rootToNodePath(BTNode<int> *root,int data,vector<int> &ans){
    if(root == NULL){
        return false;
    }

    ans.push_back(root->data);
    if(root->val == data){
        return true;
    }

    bool left = rootToNodePath(root->left,data,ans);
    bool right = rootToNodePath(root->right,data,ans);

    if(left || right){
        return true;
    }
    ans.pop_back();
    return false;
    
}




template<typename T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> child;
        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(T data){
            for(int i = 0;i < child.size();i++){
                delete child[i];
            }
        }
}

void print(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    for(int i = 0;i < root->child.size();i++){
        cout<<root->child[i]->data<<" " ;
    }
    cout<<endl;
    for(int i = 0;i < root->child.size();i++){
        print(root->child[i]);
    }
}

TreeNode<int>* takeInput(){
    int data ;
    cout<<"Enter data : ";
    cin>>data;
    if(data == -1){
        return NULL;
    }
    if(data != -1){
        TreeNode<int> *root = new TreeNode<int>(data);
        int n;
        cout<<"Enter number of children of "<<root->data;
        cin>>n;
        for(int i = 0;i < n;i++){
            root->child.push_back() = takeInput();
        }
    }
    return root;
}

TreeNode<int>* takeInputLevelWise(){
    int data;
    cout<<"Enter root data : ";
    cin>>data;
    if(data == -1){
        return NULL;
    }
    if(data != -1){
        TreeNode<int> *root = new TreeNode<int>(data);
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<"Enter number of child of "<<front->data;
        int n;
        cin>>n;
        int childData = 0;
        for(int i = 1;i <= n;i++){
            cout<<"Enter "<<i<<"th child of "<<front->data;
            cin>>childData;
            TreeNode<int> *child = new TreeNode<int>(childData);
            root->child.push_back(child);
            q.push(child);
        }
        cout<<endl;
    }
    return root;

}


int countNodes(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->child.size();i++){
        ans += countNodes(root->child[i]);
    }
    return ans+1;
}

void printLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < root->child.size();i++){
            cout<<front->child[i]->data;
            q.push(front->child[i]);
        }
        cout<<endl;
    }
}

int height(TreeNod<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 1;
    for(int i = 0;i < root->child.size();i++){
        ans = max(ans,height(root->child[i]));
    }
    return ans;
    
}

void printAtLevelK(TreeNode<int> *root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data;
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        printAtLevelK(root->child[i],k-1);
    }   
    
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->child.size() == 0){
        return 1;
    }
    ans = 0;
    for(int i = 0;i < root->child.size();i++){
        ans += countLeafNode(root->child[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data;
    for(int i = 0;i <root->child.size();i++){
        preOrder(root->child[i]);
    }   
}

void postOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i <root->child.size();i++){
        preOrder(root->child[i]);
    }   
    cout<<root->data;
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        delete root->child[i];
    }
    delete root;
}


template<typename T>
class Queue{
    public :
        int firstIndex;
        int nextIndex;
        int capacity;
        T *arr;
        int size;

        Queue(){
            capacity = 5;
            arr = new T[capacity];
            size = 0;
            nextIndex = 0;
            firstIndex = -1;
        }
        ~Queue(){
            delete arr;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size == 0;
        }
        void push(T data){
            if(size == capacity){
                T *newArr = new T[2*capacity];
                int j= 0;
                for(int i = firstIndex ; i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0;i < firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                capacity = 2*capacity;
                arr = newArr;
                delete []arr;
                firstIndex = 0;
            }
            arr[nextIndex] = data;
            nextIndex = (nextIndex + 1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
        }
        void pop(){
            if(isEmpty()){
                return 0;
            }
            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }
        T front(){
            if(isEmpty()){
                return 0;
            }
            return arr[firstIndex];
        }
}

template<typename T>
class Node{
    public :
        T data;
        Node<T> *next;

        public :
            Node(T data){
                this->data = data;
                next = NULL;
            }
            ~Node(){
                delete next;
            }
}

template<typename T>
class Queue{
    public :
        Node<T> *head;
        Node<T> *tail;
        int size;
        Queue(){
            size = 0;
            head = NULL;
            tail = NULL;
        }
        ~Queue(){
            delete head;
            delete tail;
        }

        int getSize(){
            return size;
        }
        
        bool isEmpty(){
            return size == 0;
        }
        
        void push(T element){
            Node<T> *n = new Node<T>(element);
            if(head == NULL){
                head = n;
                tail = n;
            }else{
                tail->next = n;
                tail = n;               
            }
        }

        void pop(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return ;
            }
            Node<T> *temp = head;
            head = head->next;
            temp->next = NULL;
            delete temp;
        }

        T front(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return ;
            }
            return head->data;
        }
}

template<typename T>
class Stack{
    public :
        T *arr;
        int nextIndex;
        int capacity;

        Stack(){
            capacity = 5;
            nextIndex = 0;
            arr = new T[capacity];
        }
        ~Stack(){
            delete arr;
        }

        int getSize(){
            return nextIndex;
        }

        bool isEmpty(){
            return nextIndex == 0;
        }

        void push(T element){
            if(nextIndex == capacity){
                T *newArr = new T[2*capacity];
                for(int i = 0;i < nextIndex ;i++){
                    newArr[i] = arr[i];
                }
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex++;
        }

        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            nextIndex--;
        }

        T top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            return arr[nextIndex];
        }
}

template<typename T>
class Node{
    public :
        int data;
        Node<T> *next;

        Node(T data){
            this->data = data;
            next = NULL;
        }
        ~Node(){
            delete next;
        }
}

void print(Node<int> *head){
    if(head != NULL){
        Node<int> *temp = head;
        while(temp != NULL){
            cout<<temp->head<<" ";
            temp = temp->next;
        }
    }
}

Node<int>* takeInput(){
    int data;
    cin>>data;
    Node<int> *head = NULL;
    Node<int> *temp = NULL;
    while(data != -1){
        Node<int> *n = new Node<int>(data);
        if(head == NULL){
            head = n;
            temp = n;
        }else{
            temp->next = n;
            temp = n;
        }
        cin>>data;
    }
    return head;
}


int length(Node<int> *head){
    if(head == NULL){
        return 0;
    }

    Node<int> *temp = head;
    int count = 0;
    while(temp != NULL){
        count++;
        temp = temp->next;
    }
    return count;
}

void printIthNode(Node<int> *head,int i){
    if(head == NULL){
        return ;
    }
    if(i == 0){
        cout<<head->data;
        return ;
    }
    printIthNode(head->next,i--);
}

void insertAtIthPos(Node<int> *head,int i,int data){
    if(head == NULL){
        return ;
    }
    Node<int> *temp = head;
    int count = 1;
    while(count <= i){
        count++;
        temp = temp->next;
    }
    if(temp){
        Node<int> *n = new Node<int>(data);
        Node<int> *hello = temp->next;
        temp->next = n;
        n->next = hello;
    }
}

Node<int>* reverseLL(Node<int> *head){
    if(head != NULL){
        return ;
    }
    Node<int> *curr = head;
    Node<int> *prev = NULL;
    while(curr != NULL){
        Node<int> *n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }
    return prev;
}

int middleLL(Node<int> *head){
    if(head == NULL){
        return 0;
    }

    Node<int> *slow = head;
    Node<int> *fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    if(fast){
        return slow->next->data;
    }
    return slow->data;
}

class Stack{
    public :
        int *arr;
        int nextIndex;
        int capacity;

        Stack(int capacity){
            this->capacity = capacity;
            nextIndex = 0;
            arr = new int[capacity];
        }
        Stack(){
            capacity = 5;
            nextIndex = 0;
            arr = new int[capacity];
        }

        int getSize(){
            return nextIndex;
        }

        bool isEmpty(){
            return capacity == nextIndex;
        }

        void push(int element){
            if(nextIndex == capacity){
                int *newArr = new int[2*capacity];
                for(int i = 0;i < nextIndex;i++){
                    newArr[i] = arr[i];
                }

                delete []arr;
                capacity = 2*capacity;
                arr = newArr;
                nextIndex = capacity;
            }
            arr[nextIndex] = element;
            nextIndex++;
        }
}


Node* sortList(Node* a){
    if(a == NULL) return NULL;

    Node* slow = head;
    Node* fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    Node *n = slow->next;
    slow->next = NULL;

    Node* c = sortList(head);
    Node* d = sortList(n);

    Node* newHead = mergeTwoLists(c,d);
    return newHead;


}


Node* mergeTwoLists(Node* a, Node* b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    Node *newList = NULL;
    if(a->val < b->val){
        newList = a;
        newList->next = mergeTwoLists(a->next,b);
    }else{
        newList = b;
        newList->next = mergeTwoLists(a,b->next);
    }
    return newList;
} 

int removeDuplicates(vector<int> &a){
    int n= a.size();
    int pos = 0;
    for(int i = 0;i < n -1;i++){
        if(a[i] != a[i+1]){
            a[++pos] = a[i+1];
        }
    }
    return pos+1;
}

string removeAdjacentDuplicates(string &a){
    int strptr= -1;
    for(int i =0;i < a.size();i++){
        if(strptr == -1 || a[strptr] != a[i]){
            strptr++;
            a[strptr] = a[i];
        }
    }
}


//to reverse a number 
int reverse = 0;
while(number > 0){
    reverse = reverse*10 + number % 10;
    number /= 10;
}
return reverse;


//1->2->3->3->2->1

vector<int> twoSum(vector<int> &nums,int target){
    vector<int> ans;
    for(int i = 0;i < nums.size()- 1;i++){
        for(int j = i+1;j < nums.size();j++){
            if(nums[i] + nums[j] == target){
                ans.push_back(i);
                ans.push_back(j);
                return ans;
            }
        }
    }
    return ans;
}


vector<int> twoSum(vector<int> &ans,int target){
    vector<int> ans;
    unordered_map<int,int> inMap;
    for(int i = 0;i < nums.size();i++){
        int requiredIndex = target - nums[i];
        if(inMap.count(requiredIndex)){
            ans.push_back(i);
            ans.push_back(inMap[requiredIndex]);
            return ans;
        }
        inMap[nums[i]] = i; 
    }
}

int removeDuplicates(vector<int> &nums){
    int n = nums.size();
    int pos = 0;
    for(int i = 0;i < n-1;i++){
        if(nums[i] != nums[i+1]){
            nums[++pos] = nums[i+1];
        }
    }
    return pos+1;
}

vector<int> plusOne(vector<int> &nums){
    int n = nums.size();
    if(!n) return nums;
    for(int i = n-1;i >= 0;--i){
        if(nums[i]+1 > 9){
            nums[i] = nums[i]+1 - 10;
            if(i == 0) nums.insert(nums.begin(),1);
        }else{
            nums[i] = nums[i] +1;
            break;
        }
    }
    return nums;
}

// merge sorted sorted arrays
// m = number of elements in nums1 other than 0's
// n = number of elements in nums2 other than 0's
void mergeArrays(vector<int> &nums1,int m,vector<int> &nums2,int n){
    int i = m-1;
    int j = n-1;
    int k = (m+n) -1;
    while(i >= 0 && j >= 0){
        if(nums1[i] > nums2[j]){
            nums1[k--] = nums1[i--];
        }else{
            nums1[k--] = nums2[j--];
        }
    }
    while(j >= 0){
        nums1[k--] = nums2[j--];
    } 
}


TreeNode* helper(vector<int> &nums,int s,int e){
    int mid = (s+e)/2;
    int rootData = nums[mid];
    TreeNode *root = new TreeNode(rootData);
    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);
    return root;
}

TreeNode* sortedArrayToBST(vector<int> &nums,int s,int e){
    TreeNode *root = helper(nums,s,e);
    return root;
}

vector<vector<int>> pascal(int numRows){
    vector<vector<int>> outer;
    for(int i = 0;i < numRows;i++){
        vector<int> inner(i+1,1);
        for(int j = 1;j < i ;j++){
            inner[j] = outer[i-1][j] + outer[i-1][j-1];
        }
        outer.push_back(inner);
    }
    return outer;
}


int maxProfit(vector<int> &nums){
    int min = INT_MAX;
    int pist = 0;
    int op = 0;
    for(int i = 0;i < nums.size();i++){
        if(nums[i] < min){
            min = nums[prices];
        }

        pist = prices[i] - min
        if(pist > op){
            op = pist;
        }
    }   
    return op;
}


string getRange(int lower,int upper){
    if(lower == upper){
        return to_string(lower)+"->";
    }else{
        return to_string(lower)+"->"+to_string(upper);
    }
}

vector<string> missingRanges(vector<int> &nums,int lower,int upper){
    vector<string> ans;
    for(int i = 0;i < nums.size();i++){
        if(nums[i] > lower){
            ans.push_back(getRange(lower,nums[i]-1));
            lower = nums[i]+1;
        }
        if(i == nums.size()-1){
            if(nums[i] < upper){
                ans.push_back(getRange(nums[i]+1,upper));
            }
        }
    }
    return ans;
}

bool containsDuplicates(vector<int> &nums){
    int n = nums.size();
    sort(nums.begin(),nums.end());
    for(int i = 0;i < nums.size();i++){
        if(i != 0){
            if(nums[i] != nums[i-1]){
                continue;
            }else{
                return true;
            }
        }
    }
    return false;
}

int searchMajority(vector<int> &nums){
    int cand = nums[0];
    int count = 1;
    int n = nums.size();
    for(int i = 1;i < nums.size();++i){
        if(nums[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                cand = nums[i];
                count = 1;
            }
        }
    }

    int count2 = 0;
    for(int i = 0;i < nums.size();i++){
        if(nums[i] == cand){
            count2++;
        }
    }
    if(count2 > n/2){
        return cand;
    }else{
        return -1;
    }
}


vector<int> twoSum(vector<int> nums,int target){

    unordered_map<int,int> inMap;
    vector<int> ans;
    int requiredIndex = 0;
    for(int i = 0;i < nums.size();i++){
        requiredIndex = target-nums[i];

        if(inMap.count(requiredIndex)){
            ans.push_back(nums[requiredIndex]);
            ans.push_back(i);
            return ans;
        }
        inMap[nums[i]] = i;
    }
    return ans;

}



// longest consecutive sequence

// Input:
// N = 7
// a[] = {2,6,1,9,4,5,3}
// Output:
// 6
// Explanation:
// The consecutive numbers here
// are 1, 2, 3, 4, 5, 6. These 6 
// numbers form the longest consecutive
// subsquence.



int longestConsecutiveSequence(int arr[],int n){
    set<int> s;
    for(int i = 0;i < n;i++){
        s.insert(arr[i]);
    }
    int ans = 0;
    for(int i = 0;i < s.size();i++){
        if(s.find(arr[i]-1) != s.end()){
            continue;
        }else{
            int count = 0;
            int current = arr[i];
            while(s.find(current) != s.end()){
                count++;
                current++;
            }
            ans = max(ans,count);
        }
    }
    return ans;
}


//long product sub array


long long maxProduct(vector<int> arr, int n){
    long long maxp = INT_MIN,prod = 1;

    for(int i = 0;i < arr.size();i++){
        prod *= arr[i];
        if(prod > maxp){
            maxp = prod;
        }
        if(prod == 0){
            prod = 1;
            continue;
        }
    }

    prod = 1;
    for(int i = n-1;i >= 0;i--){
        prod *= arr[i];
        if(prod > sum){
            sum = prod;
        }
        if(prod == 0){
            prod = 1;
            continue;
        }
    }
    return maxp;
}



//large factorial


class Node{
    public :
        int data;
        Node* prev;

        Node(int n){
            data = n;
            prev = NULL;
        }
}


class Solution{
    public :
        void multiply(Node *tail,int n){
            Node* temp = tail;
            Node* tempPrev = tail;
            int carry = 0;

            while(temp != NULL){
                int data = temp->data*n + carry;
                temp->data = data%10;
                carry = data/10;
                tempPrev = temp;
                temp = temp->prev;
            }
            
            while(carry != 0){
                prevTemp->prev = new Node((int)carry%10);
                carry /= 10;
                prevTemp = prevTemp->prev;
            }
        }

        void makeVector(Node* tail,vector<int> &ans){
            if(tail == NULL){
                return ;
            }
            makeVector(tail->prev,ans);
            ans.push_back(tail->data);
        }

        vector<int> factorial(int n){

            Node tail = new Node(1);
            for(int i = 2;i <= n;i++){
                multiply(tail,n);
            }

            vector<int> ans;
            makeVector(tail,ans);
            return ans;
        }
}



long long maxSubarraySum(int arr[], int n){
    int max_current = 0,max_global = 0;
    for(int i = 0;i < n;i++){
        max_current = max(arr[i],arr[i]+max_current);
        if(max_current > max_global){
            max_global = max_current;
        }
    }
    return max_global;   
}

bool subArrayExists(int arr[], int n){
    bool ans = false;
    int pre_sum = 0;
    set<int> s;
    for(int i = 0;i < n;i++){
        pre_sum += arr[i];

        if(pre_sum == 0){
            ans = true;
            break;
        }

        if(s.find(pre_sum) != s.end()){
            ans = true;
            break;
        }else{
            s.insert(pre_sum);
        }
    }
    return ans;
}

long long int countSubarrWithEqualZeroAndOne(int arr[], int n){
    int sum = 0;
    unordered_map<int,int> mp;
    int res = 0;
    mp[0] = 1;
    for(int i = 0;i <n;i++){
        if(arr[i] == 0){
            sum += -1;
        }else{
            sum += 1;
        }

        if(mp.count(sum)){
            res += mp[sum];
            mp[sum]++;
        }else{
            mp[sum]++;
        }
    }
    return res;
}


int firstNonRepeating(int arr[],int n){
    unordered_map<int,int> mp;
    int ans = -1;
    for(int i = 0;i < n;i++){
        mp[arr[i]]++;
    }

    for(int i = 0;i < n;i++){
        auto it = mp.find(arr[i]);
        if(it->second == 1){
            ans = arr[i];
            break;
        }
    }
    return ans;
}



int partition(int arr[],int s,int e){
    int j = 0;
    int pivot = arr[e];
    for(int i = 0;i < e;i++){
        if(arr[i] < pivot){
            swap(arr[i],arr[j]);
            j++;
        }
    }
    swap(arr[e],arr[j]);
    return j;
}


void quickSort(int a[],int s,int e){
    if(s >= e){
        return ;
    }
    int p = partition(a,s,e);
    quickSort(a,s,p-1);
    quickSort(a,p+1,e);
}


int countSubArrayswith0sand1s(int arr[],int n){
    int sum = 0;
    int result = 0;
    unordered_map<int,int> mp;
    for(int i = 0;i < n;i++){
        if(arr[i] < 0){
            sum +=  -1;
        }else{
            sum += 1;
        }       


        if(mp.count(sum)){
            result += mp[sum];
            mp[sum]++;
        }else{
            mp[sum]++;
        }
    }
    return result;
}

bool subArraySum0(int arr[],int n){
    int presum = 0;
    set<int> sum;
    bool ans = false;
    for(int i = 0;i < n;i++){
        presum += arr[i];


        if(presum == 0){
            return true;
        }
        if(sum.find(presum) != sum.end()){
            ans = true;
            break;
        }else{
            sum.insert(presum);
        }
    }
}



int maxSubArraySum(int arr[],int n){
    int current_sum = arr[0];
    int global_sum = arr[0];
    for(int i = 1;i < n;i++){
        current_sum = max(arr[i],current_sum+arr[i]);
        if(current_sum > global_sum){
            global_sum = current_sum;
        }
    }
    return global_sum;
}


class Node{
    public :
        int data;
        Node* prev;

        Node(int data){
            this->data = data;
            prev = NULL;
        }
}

class Solution{
    public :
        void makeVector(vector<int>& result,Node *tail){
            if(tail == NULL){
                return NULL;
            }
            makeVector(result,tail->prev);
            result.push_back(tail->data);
            
        }
        void multiply(Node *tail,int n){
            int data = 0;
            int carry = 0;
            Node *temp = tail;
            Node *prevTemp = tail;
            while(temp != NULL){
                data = temp->data*n +carry;
                temp->data = data%10;
                carry = data/10;
                prevTemp = temp;
                temp = temp->prev;
            }

            while(carry != 0){
                Node* next = new Node((int)carry%10);
                carry /= 10;
                prevTemp->prev = next;
                prevTemp = next;
            }
        }
        int factorial(int n){

            Node *tail = new Node(1);
            for(int i = 2;i <= n;i++){
                multiply(tail,i);
            }
        }
}




int containersWithMaxWater(vector<int> &containers){
    int i = 0;int j = 0;
    int water = 0;
    while(i < j){
        water = max(water,(j-i)*min(containers[i],containers[j]));
        if(containers[i] < containers[j]){
            i++;
        }else{
            j--;
        }
    }
    return water;
}


int trappingWater(vector<int> containers){
    int n = container.size();
    int lmax[n];lmax[0] = containers[0];
    int rmax[n];rmax[n-1] = containers[n-1];
    int temp = arr[0];
    int ans = 0;
    for(int i = 1;i < n;i++){
        temp = max(temp,arr[i]);
        lmax[i] = temp;
    }

    temp = arr[n-1];
    for(int i = n-2;i >= 0;i--){
        temp = max(temp,arr[i]);
        rmax[i] = temp;
    }
    int minm = 0;
    for(int i = 1;i < n-1;i++){
        minm = lmax[i] <= rmax[i] ? lmax[i] : rmax[i] ;
        ans += minm-arr[i];
    }
    return ans;
}




#include<bits/stdc++.h>
using namespace std;
it getMinDiff(vector<int> &nums,int k){

    sort(nums.begin(),nums.end());
    int n = nums.size();
    int smallest = nums[0]+k;
    int largest = nums[n-1]-k;

    int ans = nums[n-1]-nums[0];

    for(int i = 0;i < n-1;i++){
        int st = min(smallest,nums[i+1]-k);
        int lt = max(largest,arr[i]+k);

        if(st < 0){
            continue;
        }

        ans = min(ans,lt-st);
    }
    return ans;
}
int main(){

}


int minJumps(int arr[],int n){
    if(n == 1){
        return 0;
    }
    if(arr[0] == 0){
        return -1;
    }


    int jumps = 1;
    int maxReact = arr[0];
    int steps = arr[0];

    for(int i = 0;i < n;i++){
        if(i == n-1){
            return jumps;
        }

        steps--;
        maxReach = max(maxReach,arr[i]+i);
        if(steps == 0){
            jumps++;
            if(i >= maxReach){
                return -1;
            }
            steps = maxReach-i;
        }
    }
    return -1;
}





int maxArea(vector<int> &heights){
    int n = height.size();
    int left = 0;
    int right = n-1;
    int ans = 0;

    while(left <= right){
        ans = max(min(heights[left],heights[right])*(right-left),ans);
        if(heights[left] < heights[right]){
            left++;
        }else{
            right--;
        }
    }
    return ans;
}


vector<vector<int>> threeSum(vector<int> &sums){

    vector<vector<int>> ans;
    sort(sums.begin(),sums.end());
    for(int i = 0;i < nums.size();i++){

        int front = i+1;
        int back = nums.size()-1;
        int target = -nums[i];
        while(front < back){
            int sum = sums[front] + sums[back];

            if(sum < target){
                front++;
            }else if(sum > target){
                back--;
            }else{

                vector<int> triplet = {{nums[i],nums[front],nums[back]}};
                ans.push_back(triplet);
                while(front < back && triplet[1] == nums[front]) front++;

                while(back > front && triplet[2] == nums[back]) back--;
            }
            
        }

        while(i+1 < nums.size() && nums[i+1] == nums[i]) i++;
    }
}

int search(vector<int> nums,int target){

    int s= 0;
    int e = nums.size()-1;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[s] <= nums[mid]){
            if(target >= nums[s] && target <= nums[mid]){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(target >= nums[mid] && target <= nums[e]){
                s = mid+1;
            }else{
                e = mid-1;
            }
        }
    }
    return -1;
}


int getFirst(vector<int> &nums,int target){

    int s = 0;
    int e = nums.size()-1;

    while(s <= e){
        int mid = (s+e)/2;

        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }else if(nums[mid] < target){
            s = mid+1;
        }else{
            e = mid-1;
        }
    }
    return ans;
}

int getLast(vector<int>&nums ,int target){

    int s= 0;
    int e = nums.size()-1;
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            s = mid+1;
        }else if(nums[mid] < target){
            s = mid+1;
        }else{
            e = mid-1;
        }
    }
    return ans;
}


vector<int> searchRange(vector<int> &nums,int target){

    vector<int> ans;
    int first =  getFirst(nums,target);
    int last =  getLast(nums,target);

    ans.push_back(first,last);
    return ans;
}


bool isValidSudoku(vector<vector<char>>& board){

    map<string,bool> mp;

    for(int i = 0;i < board.size();i++){
        for(int j = 0; j < board[i].size();j++){

            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];


                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = true;
                }

                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
            }
        }

        return true;
    }
}



void helper(vector<int> nums,int i ,vector<vector<int>>& ans){
    if(i == nums.size()){
        ans.push_back(nums)
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[j],nums[i]);
        helper(nums,i+1,ans);
        swap(nums[j],nums[i]);
    }
}

vector<vector<int>> permute(vector<int> &nums){

    vector<vector<int>> ans;
    heper(nums,0,ans);
    return ans;
}


void rotate(vector<vector<int>> &matrix){
    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }


    for(int i = 0;i < matrix.size();i++){
        reverse(matrix[i].begin(),matrix[i].end());
    }
}



vector<vector<string>> groupAnagrams(vector<string> &strs){
    unordered_map<string,vector<string>> mp;

    for(string s : strs){
        string sorted = s;

        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(s);
    }

    vector<vector<string>> ans;

    for(auto el : mp){
        ans.push_back(el.second);
    }

    return ans;

}


vector<vector<string>> groupAnagrams(vector<string> &strs){
    unordered_map<string,vector<string>> mp;

    for(string s : strs){
        string sorted = s;
        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(s);
    }

    vector<vector<int>> ans;
    for(auto el : mp){
        ans.push_back(el.second);
    }

    return ans;
}


int maxSubArray(vector<int> &sums){

    int current_sum = sums[0];
    int global_sum = nums[0];

    for(int i = 1;i < nums.size();i++){
        current_sum = max(current_sum+nums[i],nums[i]);
        if(current_sum > global_sum){
            global_sum = current_sum;
        }
    }
    return global_sum;
}


{-2,2};


void spiralMatrix()



int maxArea(vector<int>&heights){
    int n = heights.size();

    int left = 0;
    int right = n-1;
    int ans =  0;
    while(low < high){
        ans = max(min(hieghts[left],heights[right])*(right-left),ans);
        if(heights[left] < heights[right]){
            left++;
        }else{
            right--;
        }
    }
    return ans;
}

vector<vector<int>> threeSome(vector<int> &nums){
    vector<vector<int>> ans;
    sort(nums.begin(),nums.end());
    for(int i = 0;i < nums.size();i++){
        int target = -nums[i];
        int front = i+1;
        int back = nums.size()-1;
        
        while(front < back){

            int sum = nums[front] + nums[back];

            if(sum > target){
                back--;
            }else if(sum < target){
                front++;
            }else{
                vector<int> triplet = {nums[i],nums[front],nums[back]};
                ans.push_back(triplet);

                while(front < back && nums[front] == triplet[1]) front++;

                while(front < back && nums[back] == triplet[2]) back--;
            }
        }

        while(i+1 < nums.size() && nums[i] == nums[i+1]) i++;
    }
    return ans;
}




int search(vector<int> &nums,int target){

    int s = 0;
    int e = nums.size()-1;

    while(s <= e){
        int mid = (s+e)/2;
        if(target == nums[mid]){
            return mid;
        }
        if(nums[s] <= nums[mid]){
            if(target >= nums[s] && target <= nums[e]){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(target >= nums[mid] && target <= nums[e]){
                s = mid+1;
            }else{
                e = mid-1;
            }
        }
    }
    return -1;
}



int getFirst(vector<int> &nums,int target){

    int s = 0;
    int e = nums.size()-1;
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }else if(nums[mid] < target){
            s = mid+1;
        }else{
            e = mid-1;
        }
    }
    return ans;
}

int getLast(vector<int> &nums,int target){
    int s= 0;
    int e = nums.size()- 1;

    while(s < e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            s = mid+1;
        }else if(nums[mid] > target){
            e = mid-1;
        }else{
            s = mid+1;
        }
    }
    return ans;
}


vector<int> searchRange(vector<int> &nums,int target){

    vector<int> ans;
    int first = getFirst(nums,target);
    int last = getLast(nums,target);
    ans.push_back(first);
    ans.push_back(last);

    return ans;

}


bool isValidSudoku(vector<vector<char>> &board){
    map<string,bool> mp;

    for(int i = 0;i < board.size();i++){
        for(int j =0;j < board[i].size();j++){
            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = true;
                }

                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }
            }
        }
    }
    return true;
}




bool isValidSudoku(vector<vector<char>>& board){


    map<string,bool> mp;
    for(int i = 0;i < board.size();i++){
        for(int j = 0;j < board[i].size();j++){
            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];


                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = false;
                }

                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
            }
        }
    }
    return true;
}


void helper(int i,vector<vector<int>> &ans,vector<int> nums){

    if(i == nums.size()){
        ans.push_back(nums);
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[i],nums[j]);
        helper(i+1,ans,nums);
        swap(nums[i],nums[j]);
    }
}

vector<vector<int>> permutations(vector<int> nums){
    int n = nums.size();

    vector<vector<int>> ans;

    helper(0,ans,nums);

    return ans;
}





void rotateImage(vector<vector<int>> &matrix){

    reverse(matrix.begin(),matrix.end());

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
}



vector<vector<string>> groupAnagrams(vector<strig> &strs){

    map<string,vector<string>> mp;
    for(auto str : strs){
        string sorted = str;
        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(str);
    }


    vector<vector<string>> ans;

    for(auto el : mp){
        ans.push_back(el.second);
    }

    return ans;
}



int maxSubArraySum(vector<int> &nums){
    int n = nums.size();
    int max_current = nums[0];
    int max_global = nums[0];
    for(int i = 0;i < nums.size();i++){

        max_current = max(max_current+nums[i],nums[i]);

        if(max_current > max_global){
            max_global = max_current;
        }
    }
    return max_global;
}


vector<int> spiralMatrix(vector<vector<int>> nums){

    int k = 0,l = 0,last_row=nums.size()-1,last_col=nums[0].size()-1;
    vector<int> ans;
    while(k <= last_row && l <= last_col){


        for(int i = l;i <= last_col;i++){
            ans.push_back(nums[k][i]);
        }
        k++;

        for(int i = k;i <= last_row;i++){
            ans.push_back(nums[i][last_col]);
        }

        last_col--;

        if(k <= last_row){
            for(int i = last_col;i >= l;i--){
                ans.push_back(nums[last_row][i]);
            }
            last_row--;
        }

        if(l <= last_col){
            for(int i = last_row ;i >= k;i--){
                ans.push_back(nums[i][l]);
            }
            l++;
        }
    }
}



bool canJump(vector<int> &nums){

    if(nums.size() == 1){
        return true;
    }

    if(nums[0] == 0){
        return false;
    }
    int jump = 1;
    int steps = nums[0];
    int maxReach = nums[0];
    int n = nums.size();

    for(int i = 1;i < nums.size();i++){
        if(i == n-1){
            return true;
        }
        steps--;
        maxReach = max(maxReach,nums[i]+i);
        if(steps == 0){
            jump++;
            if(i >= maxReach){
                return false;
            }
            steps = maxReach -i;
        }   
    }
}



bool canJump(vector<int> &nums){

    if(nums[0] == 0){
        return false;
    }
    if(nums.size() == 1){
        return true;
    }

    int jump = 1;
    int steps = nums[0];
    int maxReach = nums[0];
    int n = nums.size();

    for(int i = 1;i < n;i++){

        if(i == n-1){
            return true;
        }

        steps--;
        maxReach = max(maxReach,nums[i]+i);
        if(steps == 0){
            jump++;
            if(i >= maxReach){
                return false;
            }
            steps = maxReach -i;
        }
    }
}



vector<vector<int>> merge(vector<vector<int>> &intervals){

    vector<vector<int>> ans;
    sort(intervals.begin(),intervals.end());
    ans.push_back(intervals[0]);
    for(int i = 1;i < intervals.size();i++){

        if(ans.back()[1] > intervals[i][0]){
            ans.back()[1] = max(ans.back()[1],intervals[i][1]);
        }else{
            ans.push_back(intevals[i]);
        }
        
    }

    return ans;
}



//find duplicate number

int findDuplicate(vector<int> &nums){

    int dupli = 0;
    sort(nums.begin(),nums.end());

    for(int i = 1;i < nums.size();i++){
        if(nums[i] == nums[i-1]){
            dupli = nums[i];
            break;
        }
    }
    return dupli;
}



vector<int> productExceptSelf(vector<int> &nums){
    int n = nums.size();
    vector<int> op(n,1);
    int product = 1;

    for(int i = 0;i < nums.size();i++){
        product *= nums[i];
        op[i] = product;
    }

    product = 1;

    for(int i = n-1;i > 0;i--){
        op[i] = product*op[i-1];
        product *= nums[i];
    }


    op[0] = produdct;

    return op;
}


int countPrime(int n){

    vector<bool> passed(n,false);
    int count = 0;
    for(int i = 2;i < n;i++){
        if(passed[i]){
            continue;
        }
        count++;
        for(long long multi = (long)i*i; multi < n;multi += i){
            passed[multi] = true;
        }
    }

    return count;


}


int rob(vector<int> &nums){

    int n = nums.size();
    int amount1 = 0;
    int amount2 = 0;
    for(int i = 0;i < n;i++){
        if(i%2 == 0){
            amount1 = max(amount2,amount1+nums[i]);
        }else{
            amount2 = max(amount1,amount2+nums[i]);
        }
    }

    return max(amount1,amount2);
}


void rotate(vector<int> &nums,int k){

    k %= nums.size();

    reverse(nums.begin(),nums.end());
    reverse(nums.begin(),nums.begin()+k);
    reverse(nums.begin()+k,nums.end());

}


int findPeak(vector<int> &nums){
    int low = 0;
    int high = nums.size()-1;

    while(low < high){

        int mid1 = (low+high)/2;
        int mid2 = mid1+1;

        if(nums[mid1] > nums[mid2]){
            high = mid1;
        }else{
            low = mid2;
        }
    }

    return low;
}


int maxProduct(vector<int> &nums){
    int n = nums.size();
    int l = 0;
    int r = nums.size()-1;

    for(int i = 0;i < n;i++){
        l = (l ? l : 1)*nums[i];
        r = (r ? r : 1)*nums[n-1-i];


        ans = max(ans,max(l,r));
    }

    return ans;
}


int evalRPN(vector<int> &tokens){

    stack<int> st;
    for(int i = 0;i < tokens.size();i++){
        if(tokens[i] != "*" && tokens[i] != "/" && tokens[i] != "+" && tokens[i] != "-"){
            st.push_back(atoi(tokens[i].c_str()));
        }else{
            int v1 = st.top();
            st.pop();
            int v2 = st.top();
            st.pop();
            if(tokens[i] == "+"){
                st.push(v2+v1);
            }else if(tokens[i] == "-"){
                st.push(v2-v1);
            }else if(tokens[i] == "*"){
                st.push(v2*v1);
            }else{
                st.push(v2/v1);
            }
        }
    }
    return st.top();
}


int canComplete(vector<int> gas,vector<int> cost){
    int total_fuel = 0,total_cost = 0,n = gas.size();

    for(int i = 0;i < n;i++){
        total_fuel += gas[i];
        total_cost += cost[i];
    }

    if(total_cost > total_fuel){
        return -1;
    }

    int curr_fuel = 0;
    int start = 0;
    for(int i = 0;i <n ;i++){
        if(curr_fuel < 0){
            start  = i;
            curr_fuel = 0;
        }    

        curr_fuel += (gas[i]-cost[i]);
    }

    return start;
}



int canComplete(vector<int> gas,vector<int> cost){
    int total_cost = total_fuel =0;int n = gas.size();

    for(int i = 0;i < n;i++){
        total_cost += cost[i];
        total_fule += gas[i];
    }

    if(total_cost > total_fuel){
        return -1;
    }

    int curr_fuel = 0,start = 0;
    for(int i = 0;i < n;i++){

        if(curr_fuel < 0){
            start = i;
            curr_fuel = 0;
        }

        curr_fuel += (gas[i]-cost[i]);
    }

    return start;
}

int longestConsecutiveSequence(vector<int> &nums){

    int n = nums.size();

    set<int> s;
    int ans = 0;
    for(int i = 0;i < n;i++){
        s.insert(nums[i]);
    }

    for(int i = 0;i < nums.size();i++){

        if(s.find(nums[i]-1) != s.end()){
            continue;
        }else{
            int count = 0;
            int current = nums[i];

            while(s.find(curent) != s.end()){
                count++;
                current++;
            }

            ans = max(ans,count);
        }
    }
    return ans;
}



int longestConsecutiveSequence(vector<int> &nums){

    set<int> s;
    int ans = 0;
    int n = nums.size();
    for(int i = 0;i < n;i++){
        s.insert(nums[i]);
    }

    for(int i = 0;i < nums.size();i++){
        if(s.find(nums[i]-1) != s.end()){
            continue;
        }else{
            int count = 0;
            int current = nums[i];

            while(s.find(current) != s.end()){
                count++;
                current++;
            }

            ans = max(ans,count);
        }
    }
    return ans;
}



int maxProfit(vector<int> &prices){
    int n =prices.size(),buy,sell,profit=0;
    int i = 0;
    while(i < n){

        while(i < n && prices[i+1] <= prices[i]) i++;

        buy = prices[i];


        while(i < n && prices[i+1] >= prices[i]) i++;

        sell = prices[i];


        profit += sell-buy;
    }

    return profit;
}


TreeNode* helper(preorder,inorder,int preS,int preE,int inS,int inE){

    if(inS > inE){
        return NULL;
    }

    int rootIndex = -1;
    int rootData = preorder[preS];

    for(int i = inS;i < inorder.size();i++){
        if(inorder[i] == rootData){
            rootIndex = i;
            break;
        }
    }

    int leftPreS = preS + 1;
    int leftPreE = leftPreS+leftInE-leftInS;

    int rightPreS = leftPreE +1;
    int rightPreE = preE;


    int leftInS = inS;
    int leftInE = rootIndex-1;
    

    int rightInS = rootIndex +1;
    int rightInE = inE;

    TreeNode *root = new TreeNode(rootData);

    root->left = helper(preorder,inorder,leftPreS,leftPreE,leftInS,leftInE);
    root->right = helper(preorder,inorder,rightPreS,rightPreE,rightInS,rightInE);

    return root;
}


TreeNode* buildTree(vector<int> preorder,vector<int> inorder){

    int n = inorder.size();
    TreeNode* root = helper(preorder,inorder,0,n-1,0,n-1);

    return root;
}



void helper(vector<int> &nums,int i,vector<int> &sub,vector<vector<int>> ans){

    ans.push_back(sub);

    for(int j = i;j < nums.size();j++){

        sub.push_back(nums[j]);
        helper(nums,i+1,sub,ans);
        sub.pop_back();
    }
}

vector<vector<int>> subsets(vector<int> nums){

    vector<vector<int>> ans;
    vector<int> sub;

    helper(nums,0,sub,ans);
    return ans;

}


void sortColors(vector<int> &nums){
    int n = nums.size();
    int low=mid=0;int high = n-1;
    while(mid <= high){
        if(nums[mid] == 0){
            swap(nums[low++],nums[mid++]);
        }else if(nums[mid] == 2){
            swap(nums[mid],nums[high++]);
        }else{
            mid++;
        }
    }
}


void setZero(vector<vector<int>> &matrix){


    bool r=c=false;

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < matrix[i].size();j++){
            if(i == 0) r = true;
            if(j == 0) c = true;

            matrix[i][0] = matrix[0][j] = 0;
        }
    }


    for(int i = 1;i < matrix.size();i++){
        for(int j = 1;j < matrix.size();j++){
            if(matrix[0][j] == 0 || matrix[i][0] == 0){
                matrix[i][j] = 0;
            }
        }
    }


    if(c){
        for(int i = 0;i < matrix.size();i++){
            matrix[i][0] = 0;
        }
    }

    if(r){
        for(int i = 0;i < matrix[0].size();i++){

            matrix[0][i] = 0;
        }
    }
}

void setZeros(vector<vector<int> &matrix){
    bool row=col=false;

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < matrix[i].size();j++){
            if(matrix[i][j] == 0){
                if(i == 0) r = true;
                if(j == 0) c = true;

                matrix[i][0] = matrix[0][j] = 0;
            }
        }
    }


    for(int i = 1;i < matrix.size();i++){
        for(int j = 1;j < matrix[i].size();j++){

            if(matrix[i][0] == 0 || matrix[0][j] == 0){
                matrix[i][j] = 0;
            }
        }
    }

    if(r){
        for(int i = 0;i < matrix[0].size();i++){
            matrix[0][i] = 0;
        }
    }

    if(c){
        for(int i = 0;i < matrix.size();i++){
            matrix[i][0] = 0;
        }
    }
}



void setZero(vector<vector<int>> &matrix){

    bool r=c=false;
    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < matrix[i].size();j++){

            if(matrix[i][j] == 0){
                if(i == 0) r = true;
                if(j == 0) c = true;

                matrix[0][j] = matrix[i][0] = 0;
            }
        }
    }


    for(int i = 1;i < matrix.size();i++){
        for(int j = 1;j < matrix[i].size();j++){
            if(matrix[0][j] == 0 || matrix[i][0] == 0){
                matrix[i][j] = 0;
            }
        }
    }

    if(r){
        for(int i = 0;i < matrix[0].size();i++){
            matrix[0][i] = 0;
        }
    }

    if(c){
        for(int i = 0;i < matrix.size();i++){
            matrix[i][0] = 0;
        }
    }
}


vector<vector<int>> merge(vector<vector<int>> &intervals){

    vector<vector<int>> ans;
    sort(interval.begin(),intervals.end());
    ans.push_back(intervals[0]);

    for(int i = 1;i < intervals.size();i++){
        if(ans.back()[1] >= intervals[i][0]){
            ans.back()[1] = max(intervals[i][1],ans.back()[1]);
        }else{
            ans.push_back(intervals[i]);
        }
    }

    return ans;
}


bool canJum(vector<int> &nums){

    if(nums[0] == 0){
        return false;
    }

    if(nums.size() == 1){
        return true;
    }

    int steps = nums[0],maxReach = nums[0],jump = 0,n = nums.size();

    for(int i = 0;i < nums.size();i++){
        if(i == n-1){
            return true;
        }

        maxReach = max(maxReach,nums[i]+i);
        steps--;

        if(steps == 0){
            jump++;
            if(i >= maxReach){
                return false;
            }

            steps = maxReach - i;
        }
    }
    return true;
}


vector<vector<string>> groupAnagrams(vector<string> &strs){

    unordered_map<string,vector<string>> mp;
    for(string str : strs){
        string sorted = str;
        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(str);
    }

    vector<vector<string>> ans;

    for(auto el : mp){
        ans.push_back(el.second);
    }
    return ans;
}


void rotateImage(vector<vector<int>> &matrix){

    reverse(matrix.begin(),matrix.end());

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
}


void rotateImage(vector<vector<int>> &matrix){


    reverse(matrix.begin(),matrix.end());

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }

    // 2nd approach
    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }

    for(int i = 0;i < matrix.size();i++){
        reverse(matrix[i].begin(),matrix[i].end());
    }
}



//rotating anti-clockwise
void rotateImage(vector<vector<int>> &matrix){
    for(auto ev : matrix){
        reverse(ev.begin(),ev.end());
    }

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
}

//approach 2

void rotateImage(vector<vector<int>> &matrix){
 

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
    reverse(matrix.begin(),matrix.end());
}


void helper(vector<int> arr,int i,vector<vector<int>> ans){
    if(i == arr.size()){
        ans.push_back(arr);
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[j],nums[i]);
        helper(arr,i+1,ans);
        swap(nums[j],nums[i]);
    }
}

vector<vector<int>> permute(vector<int> &nums){

    vector<vector<int>> ans;
    helper(nums,0,ans);

    return ans;
}



bool validSudoku(vector<vector<char>> &board){

    unordered_map<string,bool> mp;

    for(int i = 0;i < board.size();i++){
        for(int j = 0;j < board[i].size();j++){
            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = true;
                }
                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }
            }
        }
    }
    return true;
}


int getFirst(vector<int> nums,int target){
    int low = 0;
    int high = nums.size()-1;
    int ans = -1;
    while(low <= high){
        int mid = (low+high)/2;
        if(nums[mid] == target){
            ans = mid;
            high = mid-1;
        }
        if(nums[mid] < target){
            low = mid+1;
        }else{
            high = mid-1;
        }
    }
}

int getLast(vector<int> nums,int target){
    int low = 0;
    int high = nums.size()-1;
    int ans = -1;
    while(low <= high){
        int mid = (low+high)/2;
        if(nums[mid] == target){
            ans = mid;
            low = mid+1;
        }
        if(nums[mid] < target){
            low = mid+1;
        }else{
            high = mid-1;
        }
    }
}

vector<int> searchRange(vector<int> &nums,int target){
    int first = getFirst(nums,target);
    int last = getLast(nums,last);

    vector<int> ans;
    ans.push_back(first);
    ans.push_back(last);
    return ans;
}


int searchInRotatedSortedArray(vector<int> &nums,int target){

    int low = 0;
    int high = nums.size()-1;

    while(low <= high){
        int mid = (low+high)/2;
        if(nums[mid] == target){
            return mid;
        }
        if(nums[low] <= nums[mid] ){
            if(target >= nums[low] && target <= nums[mid]){
                high = mid-1;
            }else{
                low = mid+1;
            }
        }else{
            if(target >= nums[mid] && target <= nums[high]){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
    }

    return -1;
}


vector<vector<int>> threeSum(vector<int> &nums){
    int n = nums.size();

    for(int i = 0;i < n;i++){
        int front = i+1;
        int back = n-1;

        int target = -nums[i];
        while(front < back){
            int sum = nums[front] + nums[back];

            if(target == sum){
                vector<int> triplet = {nums[i],nums[front],nums[back]};
                ans.push_back(triplet);

                while(front < back && nums[front] == triplet[1]) front++;

                while(front < back && nums[back] == triplet[2]) back--;
            }
            if(sum < target){
                front++;
            }else{
                back--;
            }
        }

        while(i+1 < n && nums[i] == nums[i+1]) i++;
    }
}



vector<vector<int>> threeSum(vector<int> nums){
    int n = nums.size();
    vector<vector<int>> ans;
    sort(nums.begin(),nums.end());
    for(int i = 0;i < n;i++){
        int front = i+1;
        int back = n-1;

        int target = -nums[i];

        while(front < back){

            int sum = nums[front] + nums[back];

            if(target == sum){
                vector<int> triplet = {nums[i],nums[front],nums[back]};

                ans.push_back(triplet);

                while(front < back && nums[front] == triplet[1]) front++;

                while(front < back && nums[back] == triplet[2]) back--;

            }else if(sum < target){
                front++;
            }else{
                back--;
            }
        }

        while(i+1 < n && nums[i] == nums[i+1]) i++;
    }
    return ans;
}


int maxArea(vector<int> heights){

    int left = 0;
    int right = heights.size()-1;
    int ans = -1;
    while(left <= right){
        ans = max(min(heights[left],heights[right])*(right-left),ans);

        if(heights[left] < heights[right]){
            left++;
        }else{
            right--;
        }
    }

    return ans;
}


int maxArea(vector<int> heights){
    int s = 0;
    int e = heights.size()-1;
    int ans = -1;

    while(s <= e){
        ans = max(min(heights[s],heights[e])*(e-s),ans);

        if(heights[s] < heights[e]){
            s++;
        }else{
            e--;
        }
    }
    return ans;
}





int maxArea(vector<int> heights){
    int left = 0;
    int right = heights.size()-1;
    int ans = -1;

    while(left <= right){
        ans = max(min(heights[left],heights[right])*(right-left),ans);

        if(heights[left] < heights[right]){
            left++;
        }else{
            right--;
        }
    }
    return ans;
}



int containerWithMaxWater(vector<int> &matrix){
    int n = matrix.size();

    int low = 0;int high = n-1;
    int ans = -1;
    while(low <= high){
        ans = max(min(matrix[low],matrix[high])*(high-low),ans);
        if(matrix[low] < matrix[high]){
            low++;
        }else{
            high--;
        }
    }

    return ans;
}


vector<vector<int>> threeSum(vector<int> &nums){
    int n = nums.size();

    for(int i = 0;i < n;i++){

        int front = i+1;
        int back = n-1;
        int target = -nums[i];
        while(front <= back){
            int sum = nums[front]+nums[back];

            if(sum == target){
                vector<int> triplet = {nums[i],nums[front],nums[back]};
                ans.push_back(triplet);

                while(i < n && nums[front] == triplet[1]) front++;

                while(i < n && nums[back] == triplet[2]) back--;

            }else if(sum < target){
                front++;
            }else{
                back--;
            }
        }
        while(i+1 < n && nums[i+1] == nums[i]) i++;
    }

    return ans;
}

int searchInRotatedSortedArray(vector<int> &nums,int target){
    int n = nums.size();

    int s = 0;
    int e = n-1;
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;

        if(nums[mid] == target){
            ans = mid;
            break;
        }

        if(nums[mid] >= nums[s]){
            if(target >= nums[s] && target <= nums[mid]){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(target >= nums[mid] && target <= nums[e]){
                s= mid+1;
            }else{
                e = mid-1;
            }
        }
    }
    return ans;
}

int getFirst(vector<int> nums,int target){
    int s = 0;
    int e = nums.size();
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }
        if(nums[mid] >= target){
            e = mid-1;
        }else{
            s = mid+1;
        }
    }
}


int getLast(vector<int> nums,int target){
    int s = 0;
    int e = nums.size();
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            s = mid+1;
        }
        if(nums[mid] >= target){
            e = mid-1;
        }else{
            s = mid+1;
        }
    }
}

vector<int> searchRange(vector<int> &nums,int target){
    int n = nums.size();

    int first = getFirst(nums,target);
    int last = getLast(nums,target);

    vector<int> ans;
    ans.push_back(first);
    ans.push_back(last);
}


bool validSudoku(vector<vector<char>> &board){
    unordered_map<string,bool> mp;
    for(int i = 0;i < board.size();i++){
        for(int j = 0;j < board[i].size();j++){
            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];

                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = true;
                }
                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
            }
        }
    }
    return true;
}

void helper(int i,vector<vector<int>> &ans,vector<int> &nums){
    if(i == nums.size()){
        ans.push_back(nums);
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[i],nums[j]);
        helper(i+1,ans,nums);
        swap(nums[i],nums[j]);
    }
}

vector<vector<int>> permutations(vector<int> &nums){
    vector<vector<int>> ans;
    helper(0,ans,nums);
    return ans;
}


void rotateImage(vector<vector<int>> &matrix){

    reverse(matrix.begin(),matrix.end());

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
}


vector<vector<string>> groupAnagrams(vector<string> &strs){
    vector<vector<int>> ans;
    unordered_map<string,vector<string>> mp;
    for(string sr : strs){
        string sorted = sr;
        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(sr);
    }

    for(auto el : mp){
        ans.push_back(el.second);
    }

    return ans;
}


int maxSubArraySum(vector<int> &nums){
    int current_max = nums[0];
    int global_max = nums[0];

    for(int i = 1;i < nums.size();i++){
        current_max = max(current_max+nums[i],nums[i]);
        if(current_max > global_max){
            global_max = current_max;
        }
    }
    return global_max;
}


bool canJump(vector<int> &nums){

    if(nums[0] == 0){
        return false;
    }

    if(nums.size() == 1){
        return true;
    }
    int steps = nums[0];
    int maxReach = nums[0];
    int jumps = 1;
    int n = nums.size();
    for(int i = 1;i < n;i++){
        if(i == n-1){
            return true;
        }
        steps--;
        maxReach = max(maxReach,nums[i]+i);
        if(steps == 0){
            jumps++;
            if(i >= maxReach){
                return false;
            }
            steps = maxReach - i;
        }
    }
    return false;
}


vector<vector<int>> merge(vector<vector<int>> &intervals){
    vector<vector<int>> ans;
    ans.push_back(intervals[0]);
    for(int i = 1;i < intervals.size();i++){
        if(ans.back()[1] >= intervals[i][0]){
            ans.back()[1] = max(ans.back()[1],intervals[i][1]);
        }else{
            ans.push_back(intervals[i]);
        }
    }

    return ans;
}


void setMatrixZero(vector<vector<int>> &matrix){
    bool r = false;
    bool c = false;
    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < matrix[i].size();j++){
            if(matrix[i][j] == 0){
                if(i == 0) r = true;
                if(j == 0) c = true;

                matrix[0][j] = matrix[i][0] = 0;
            }
        }
    }

    for(int i = 1;i < matrix.size();i++){
        for(int j = 1;j < matrix[i].size();j++){
            if(matrix[0][j] == 0  || matrix[i][0] == 0){
                matrix[i][j] = 0;
            }
        }
    }

    if(r){
        for(int i = 0;i < matrix[0].size();i++){
            matrix[0][i] = 0;
        }
    }

    if(c){
        for(int i = 0;i < matrix.size();i++){
            matrix[i][0] = 0;
        }
    }
}


void setColors(vector<int> &nums){
    int n = nums.size();
    int mid = 0;
    int low = 0;
    int high = n-1;
    while(mid <= high){
        if(nums[mid] == 0){
            swap(nums[low++],nums[mid++]);
        }else if(nums[mid] == 2){
            swap(nums[mid],nums[high--]);
        }else{
            mid++;
        }
    }
}

void helper(int i;vector<int> &nums,vector<int> &sub,vector<vector<int>> &ans){
    ans.push_back(sub);
    for(int j = i;j < nums.size();j++){
        sub.push_back(nums[j]);
        helper(j+1,nums,sub,ans);
        sub.pop_back();
    }
}

vector<vector<int>> subsets(vector<int> &nums){
    vector<vector<int>> ans;
    vector<int> sub;
    helper(0,nums,sub,ans);
}

TreeNode* helper(vector<int> preorder,vector<int> inorder,int preS,int preE,int inS,int inE){
    if(inS > inE){
        return NULL;
    }

    int rootData = preorder[preS];
    int rootIndex = -1;
    for(int i = 0;i < inorder.size();i++){
        if(rootData == inorder[i]){
            rootIndex = i;
            break;
        }
    }


    int leftInS = inS;
    int leftInE = rootIndex-1;
    int rightInS = rootIndex+1;
    int rightInE = inE;

    int leftPreS = preS+1;
    int leftPreE = leftPreS + leftInE - leftInS;
    int rightPreS = leftPreE+1;
    inr rightPreE = preE;

    TreeNode* root = new TreeNode(rootData);
    root->left = helper(preorder,inorder,leftPreS,leftPreE,leftInS,leftInE);
    root->right = helper(preorder,inorder,rightPreS,rightPreE,rightInS,rightInE);

    return root;

}

TreeNode* builder(vector<int> &preorder,vector<int> &inorder){
    int n = inorder.size();
    TreeNode *root = helper(preorder,inorder,0,n-1,0,n-1);
    return root;
}


int maxProfit(vector<int> &prices){
    int buy = 0;
    int sell = 0;
    int n = prices.size();
    int ans = -1;
    for(int i = 0;i < n;i++){
        while(i < n && prices[i+1] <= prices[i]) i++;
        buy = i;

        while(i < n && prices[i+1] >= prices[i]) i++
        sell = i;

        ans += prices[sell] - prices[buy];
    }

    return ans;
}

int longestConsecutive(vector<int> &nums){

    set<int> s;
    int n = nums.size();
    int ans = 0;
    for(int i = 0;i < n;i++){
        s.insert(nums[i]);
    }

    for(int i = 0;i != s.end();i++){
        if(s.find(nums[i]-1) != s.end()){
            continue;
        }else{
            int current = nums[i];
            int count = 0;
            while(s.find(current) != s.end()){
                count++;
                current++;
            }   
            ans = max(ans,count);
        }
    }
    return ans;
}


int canCompleteCircuit(vector<int> &gas,vector<int> &cost){
    int total_fuel = 0;int total_cost = 0;

    for(int i = 0;i < gas.size();i++){
        total_fuel += gas[i];
        total_cost += cost[i];
    }

    if(total_cost > total_fuel){
        return -1;
    }

    int curr_fuel = 0;
    int start = -1;
    for(int i = 0;i < gas.size();i++){

        if(curr_fuel < 0){
            curr_fuel = 0;
            start = i;
        }

        curr_fuel += (gas[i]-cost[i]);
    }

    return start;
}

//string to int conversion

atoi(arr[i].c_str())


int maxProduct(vector<int> nums){

    int r = 0,l = 0;
    int ans = -1;
    int n = nums.size();
    for(int i = 0;i < nums.size();i++){

        l = (l ? l : 1)*nums[i];
        r = (r ? r : 1)*nums[n-1-i];

        ans = max(max(l,r),ans);
    }
    return ans;
}



int maxProduct(vector<int> &nums){

    int n = nums.size();
    int l =r = 0;
    int ans = 0;
    for(int i = 0;i < n;i++){
        r = (r ? r : 1)*nums[n-1-i];
        l = (l ? l : 1)*nums[i];

        ans = max(max(l,r),ans);
    }
    return ans;
}


int helper(vector<int>,int s ,int e){

    while(s < e){
        int mid1 = (s+e)/2;
        int mid2 = mid1+1;

        if(nums[mid1] > nums[mid2]){
            e = mid1;
        }else{
            s = mid2;
        }
    }
    return s;
}

int findPeakElement(vector<int> &nums){
    int n = nums.size();

    return helper(nums,0,n-1);
}


int helper(vector<int> nums,int s ,int e){
    while(s < e){
        int mid1 = (s+e)/2;
        int mid2 = mid1+1;

        if(nums[mid1] > nums[mid2]){
            e = mid1;
        }else{
            s = mid2;
        }
    }
}

int findPeakElement(vector<int> &nums){
    int n = nums.size();
    return helper(nums,0,n-1);
}


void rotateArray(vector<int> nums,int k){
    k %= nums.size();

    reverse(nums.begin(),nums.end());
    reverse(nums.begin(),nums.begin()+k);
    reverse(nums.begin()+k,nums.end());
}

int rob(vector<int> &nums){
    int n = nums.size();
    int amount1=amount2 =0;

    for(int i = 0;i < n;i++){
        if(i%2 == 0){
            amount1 = max(amount2,amount1+nums[i]);
        }else{
            amount2 = max(amount1,amount2+nums[i]);
        }
    }

    return max(amount1,amount2);
}


int countPrimes(int n){
    vector<int> passed(n,false);
    int count = 0;
    for(int i = 2;i < n;i++){
        if(passed[i]){
            continue;
        }else{
            count++;
            for(long long multi = (long)i*i;multi < n;multi += i){
                passed[multi] = true;
            }
        }
    }
    return count;
}


int kThLargestElement(vector<int> nums,int k){


    int i = 0;
    sort(nums.begin(),nums.end());
    while(k--){
        i++;
    }
    return nums[i];
}


vector<int> productExceptSelf(vector<int> &nums){

    int n = nums.size();
    vector<int> ans(n,1);
    int product = 1;
    for(int i = 0;i < n;i++){
        product *= nums[i];
        ans[i] = product;
    }

    product = 1;
    for(int i = n-1;i > 0;i--){
        ans[i] = product*ans[i-1];
        product *= nums[i];
    }

    ans[0] = product;

    return ans;
}


vector<int> productExceptSelf(vector<int> &nums){
    int n = nums.size();

    int product = 1;
    vector<int> op(n,1);
    for(int i = 0;i < n;i++){
        proudct *= nums[i];
        op[i] = product;
    }

    product = 1;
    for(int i = n-1;i > 0;i++){
        op[i] = product*op[i-1];
        product *= nums[i];
    }

    op[0] = product;
    return op;
}


int findTheDuplicateNumber(vector<int> &nums){
    sort(nums.begin(),nums.end());
    int n = nums.size();

    for(int i = 1;i < n;i++){
        if(nums[i] == nums[i-1]){
            return nums[i];
            break;
        }
    }
}

int removeDuplicates(vector<int> &nums){
    int pos = 0;
    int n = nums.size();
    for(int i = 0;i < n-1;i++){
        if(nums[i] != nums[i+1]){
            nums[++pos] = nums[i+1];
        }
    }
    return pos+1;
}


vector<int> twoSum(vector<int> &nums,int target){
    int n = nums.size();
    unordered_map<int,int> mp;
    vector<int> result;
    for(int i = 0;i < n;i++){
        int requiredIndex = target-nums[i];
        if(mp.count(requiredIndex)){
            result.push_back(mp[requiredIndex]);
            result.push_back(i);
            return result;
        }
        mp[nums[i]] = i;
        
    }
    return result;
}

vector<int> twoSum(vector<int> &nums,int target){
    int n = nums.size();
    unordered_map<int,int> mp;
    vector<int> ans;
    for(int i = 0;i < n;i++){
        int requiredVal = target - nums[i];
        if(mp.count(requiredVal)){
            ans.push_back(mp[requiredVal]);
            ans.push_back(i);
            return ans;
        }
        mp[nums[i]] = i;
    }

    return ans;
}


vector<int> plusOne(vector<int> &nums){
    int n = nums.size()
    for(int i = n-1;i >= 0;i--){

        if(nums[i]+1 > 9){
            nums[i] = nums[i]+1 - 10;
            if(i == 0) nums.insert(nums.begin(),1);
        }else{
            nums[i] = nums[i] +1;
            break;
        }
    }
    return nums;
}


void merge(vector<int> nums1,int m,vector<int> nums2,int n){
    int i = m-1;
    int j = n-1;
    int k = m+n-1;

    while(i >= 0 && j >= 0){
        if(nums1[i] > nums2[j]){
            nums1[k--] = nums2[j--];
        }else{
            nums1[k--] = nums1[i--];
        }
    }

    if(i > 0){
        while(i >= 0){
            nums1[k--] = nums1[i--];
        }
    }

    if(j > 0){
        while(j >= 0){
            nums1[k--] = nums2[j--];
        }
    }
}

TreeNode* helper(vector<int> nums,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    int rootData = nums[mid];

    TreeNode* root = new TreeNode(rootData);
    root->left = helper(nums,s,m-1);
    root->right = helper(nums,m+1,e);

    return root;
}


TreeNode* convertSortedArrayToBST(vector<int> nums,int s,int e){
    return helper(nums,s,e);
}


vector<vector<int>> generate(int numRows){
    vector<vector<int>> ans;
    
    for(int i = 0;i < numRows;i++){
        vector<int> sub(i+1,1);
        for(int j = 1;j < i;j++){
            sub[j] = ans[i-1][j] + ans[i-1][j-1];
        }
        ans.push_back(sub);
    }
    return ans;

}

int maxProfit(vector<int> prices){
    int n = prices.size();
    int lsf = INT_MAX;
    int op = 0;
    for(int i = 0;i <n;i++){
        if(prices[i] < lsf){
            lsf = prices[i];
        }

        int pist = prices[i] -lsf;

        if(pist > op){
            op = pist;
        }
    }
    return op;
}


int singleNumber(vector<int> &nums){
    sort(nums.begin(),nums.end());

    for(int i = 1;i < nums.size();i += 2){
        if(nums[i] != nums[i-1]){
            return nums[i-1];
        }
    }
    return nums[nums.size()-1];
}


int singleNumber(vector<int> &nums){
    sort(nums.begin(),nums.end());

    for(int i = 1;i < nums.size();i += 2){
        if(nums[i] != nums[i-1]){
            return nums[i-1];
        }
    }
    return nums[nums.begin() -1];
}


int majorityElement(vector<int> &nums){
    int n = nums.size();
    int cand = nums[0];
    int count = 1;
    for(int i = 1;i < n;i++){
        if(nums[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                cand = nums[i];
                count = 1;
            }
        }
    }

    int count2 = 0;
    for(int i = 0;i < n;i++){
        if(nums[i] == cand){
            count2++;
        }
    }

    if(n/2 >= count2){
        return cand;
    }else{
        return -1;
    }
}


int majorityElement(vector<int> &nums){
    int n = nums.size();
    int count = 0;
    int cand = nums[0];
    for(int i = 1;i < nums.size();i++){
        if(nums[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                count = 1;
                cand = nums[i];
            }
        }
    }

    int count2 = 0;
    for(int i = 0;i < n;i++){
        if(nums[i] == cand){
            count2++;
        }
    }
    if(n/2 <= count2){
        return cand;
    }else{
        return -1;
    }
}

bool containsDuplicate(vector<int> nums){
    int n = nums.size();
    sort(nums.begin(),nums.end());
    for(int i = 1;i < n;i++){
        if(nums[i] == nums[i-1]){
            return true;
        }
    }
    return false;
}



int missingNumber(vector<int> nums){
    sort(nums.begin(),nums.end());
    int n = nums.size();
    for(int i = 0;i < n;i++){
        if(i != nums[i]){
            return i;
        }
    }
    return nums.size();
}

void moveZeroes(vector<int> nums){
    int n = nums.size();
    int pos = 0;
    for(int i = 0;i < n;i++){
        if(nums[i] != 0){
            nums[pos++] = nums[i];
        }
    }

    for(;pos < nums.size();pos++){
        nums[pos] = 0;
    }
}


vector<int> intersect(vector<int> nums1,vector<int> nums2){
    int n1 = nums1.size();
    int n2 = nums2.size();
    sort(nums1.begin(),nums1.end());
    sort(nums2.begin(),nums2.end());
    int i = j = 0;
    vector<int> ans;
    while(i < n1 && j < n2){
        if(nums1[i] == nums2[j]){
            ans.push_back(nums2[i]);
        }else if(nums1[i] > nums2[j]){
            j++;
        }else{
            i++;
        }
    }
    return ans; 
}

int missingNumber(vector<int> &nums){
    int n = nums.size();

    for(int i = 0;i < n ;i++){
        if(nums[i] != i){
            return i;
        }
    }
    return nums.size();
}


int romanToInt(string s){
    unordered_map<char,int> sc = {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
    int result = 0;
    for(int i = s.size() -1;i >= 0;i--){
        if(result == 0 || sc[s[i]] < result){
            if(sc[s[i]]*4 <= result){
                result -= sc[s[i]];
            }else{
                result += sc[s[i]];
            }
        }else{
            result += sc[s[i]];
        }
    }
    return result;
}

string longestCommonPrefix(vector<string> &strs){
    int n = strs.size();
    int minLength = INT_MAX;
    int len = 0;
    string ans = "";
    for(int i = 0;i < n;i++){
        len = strs[i].size();
        minLength = min(minLength,min);
    }

    for(int i = 0;i < minLength;i++){
        char current_char = strs[0][i];
        for(int j = 0;j < strs.size();j++){
            if(strs[j][i] != current_char){
                return ans;
            }else{
                continue;
            }
        }
        ans.push_back(currentChar);
    }
    return ans;
}


int maxArea(vector<int> &heights){
    int left = 0;
    int right = heights.size()-1;
    int ans = 0;
    while(left <= right){
        ans = max(min(heights[left],heights[right])*(right-left),ans);
        if(heights[left]<heights[right]){
            left++;
        }else{
            right--;
        }
    }
    return ans;
}


vector<vector<int>> threeSome(vector<int> &nums){
    vector<vector<int>> ans;
    int n = nums.size();
    sort(nums.begin(),nums.end());

    for(int i =0;i < n-1;i++){

        int front = i+1;
        int back = n-1;
        int target = -nums[i];

        while(front < back){
            int sum = nums[front] + nums[back];

            if(sum < target){
                front++;
            }else if(sum > target){
                back--
            }else{
                vector<int> triplet = {nums[i],nums[front],nums[back]};
                ans.push_back(triplet);

                while(front < back && nums[front] == triplet[1]) front++;

                while(front < back && nums[back] == triplet[2]) back--;
            }
        }

        while(i+1 < n && nums[i+1] == nums[i]) i++;

    }
    return ans;
}

int search(vector<int> &nums,int target){
    int s = 0;
    int e = nums.size()-1;

    while(s <= e){
        int mid = (s+e)/2;

        if(nums[mid] == target){
            return mid;
        }

        if(nums[s] <= nums[mid]){
            if(target >= nums[s] && target <= nums[mid]){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(target >= nums[mid] && target <= nums[e]){
                s = mid+1;
            }else{
                e = mid-1;
            }
        }
    }

    return -1;
}


int getFirst(vector<int> &nums,int target){
    int s = 0;
    int e = nums.size();
    int ans = 0;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }
        if(nums[mid] > target){
            e = mid-1;
        }else{
            s = mid+1;
        }
    }
    return ans;
}
int getLast(vector<int> &nums,int target){
    int s = 0;
    int e = nums.size();
    int ans = 0;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            s = mid+1;
        }
        if(nums[mid] > target){
            e = mid-1;
        }else{
            s = mid+1;
        }
    }
    return ans;
}



vector<int> searchRange(vector<int> &nums,int target){

    sort(nums.begin(),nums.end());
    int first = getFirst(nums,target);
    int last = getLast(nums,target);

    vector<int> ans;
    ans.push_back(first);
    ans.push_back(last);
}   

bool isValidSudoku(vector<vector<char>> &board){
    
    unordered_map<string,bool> mp;

    for(int i = 0;i < board.size();i++){
        for(int j = 0;j < board[i].size();j++){
            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];


                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = true;
                }

                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
            }
        }
    }
    return true;
}

void helper(vector<int> &nums,int i,vector<vector<int>> &ans){
    if(i == nums.size()){
        ans.push_back(nums);
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[i],nums[j]);
        helper(nums,i+1,ans);
        swap(nums[i],nums[j]);
    }
}

vector<vector<int>> permute(vector<int> &nums){
    vector<vector<int>> ans;
    helper(nums,0,ans);
    return ans;
}



void rotate(vector<vector<int>> &matrix){


    reverse(matrix.begin(),matrix.end());

    for(int i = 0;i < matrix.size();i++){
        for(int j= 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
}


vector<vector<string>> groupAnagrams(vector<string> &strs){
    unordered_map<string,vector<string>> mp;

    for(string sr : strs){
        string sorted = sr;
        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(sr);
    }

    vector<vector<string>> ans;
    for(auto el : mp){
        ans.push_back(el.second);
    }
    return ans;
}

int maxSubarraySum(vector<int> &nums){
    int max_current = nums[0];
    int max_global = nums[0];

    for(int i = 1;i <nums.size();i++){
        max_current = max(nums[i],max_current+nums[i]);
        if(max_current > max_global){
            max_global = max_current;
        }
    }
    return max_global;
}

vector<int> spiralOrder(vector<vector<int>> &matrix){
    int k = 0,l = 0,last_row = matrix.size()-1;last_col = matrix[0].size()-1;
    vector<int> ans;
    while(i <= last_row && j <= last_col){

        for(int i = l;i <= last_col;i++){
            ans.push_back(matrix[k][i]);
        }
        k++;

        for(int i = k;i <= last_row;i++){
            ans.push_back(matrix[i][last_col]);
        }
        last_col--;

        if(k <= last_row){
            for(int i = last_col;i >= l;i--){
                ans.push_back(nums[last_row][i]);
            }
            last_row--;
        }

        if(l <= last_col){
            for(int i = last_row;i >= k;i--){
                ans.push_back(matrix[i][l]);
            }
            l++;
        }
    }
    return ans;
}

bool canJump(vector<int> &nums){

    if(nums[0] == 0){
        return false;
    }

    if(nums.size() == 1){
        return true;
    }

    int jumps = 1;
    int steps = nums[0];
    int maxReach = nums[0];
    for(int i = 1;i < nums.size();i++){

        if(i == nums.size()-1){
            return true;
        }

        maxReach = max(maxReach,nums[i]+i);
        steps--;
        if(steps == 0){
            jumps++;
            if(i >= maxReach){
                return false;
            }
            steps = maxReach-i;
        }
    }
    return true;
}



vector<vector<int>> merge(vector<vector<int>> &intervals){
    vector<vector<int>> ans;

    sort(intervals.begin(),intervals.end());

    ans.push_back(intervals[0]);
    for(int i = 1;i < intervals.size();i++){
        if(ans.back()[1] >= intervals[i][0]){
            ans.back()[1] = max(ans.back()[1],intervals[i][1]);
        }else{
            ans.push_back(intervals[i]);
        }
    }
    return ans;
}



void setZero(vector<vector<int>> &matrix){
    bool r=c=false;

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < matrix[i].size();j++){
            if(matrix[i][j] == 0){
                if(i == 0) r = true;
                if(j == 0) c = true;

                matrix[0][j] = matrix[i][0] = 0;
            }
        }
    }

    for(int i = 1;i < matrix.size();i++){
        for(int j = 1;j < matrix[i].size();j++){
            if(matrix[0][j] == 0 || matrix[i][0] == 0){
                matrix[i][j] = 0;
            }
        }
    }

    if(c){
        for(int i = 0;i < matrix.size();i++){
            matrix[i][0] = 0;
        }
    }

    if(r){
        for(int i = 0;i < matrix[0].size();i++){
            matrix[0][i] = 0;
        }
    }
}


void sortColors(vector<int> &nums){
    int mid = 0,low = 0,high = nums.size()-1;

    while(mid <= high){
        if(nums[mid] == 0){
            swap(nums[low++],nums[mid++]);
        }else if(nums[mid] == 2){
            swap(nums[mid],num[high--]);
        }else{
            mid++;
        }
    }
}



void helper(vector<int> &nums,int i ,vector<int> &temp,vector<vector<int>> ans){

    ans.push_back(temp);

    for(int j = i;j < nums.size();j++){
        temp.push_back(nums[j]);
        helper(nums,j+1,temp,ans);
        temp.pop_back();
    }
}

vector<vector<int>> subsets(vector<int> &nums){
    vector<vector<int>> ans;
    vector<int> temp;
    helper(nums,0,temp,ans);

    return ans;
}

TreeNode* helper(vector<int> inorder,vector<int> preorder,int inS,int inE,int preS,int preE){

    if(inS > inE){
        return NULL;
    }

    int rootIndex = -1;

    for(int i = inS;i < inorder.size();i++){
        if(inorder[i] == preorder[preS]){
            rootIndex = i;
            break;
        }
    }

    int leftInS = inS;
    int leftInE = rootIndex-1;
    int leftPreS = preS+1;
    int leftPreE = leftPreS + leftInE-leftIns;

    int rightInS = rootIndex+1;
    int rightInE = inE;
    int rightPreS = leftPreE +1;
    int rightPreE = preE;

    TreeNode* root = new TreeNode(inorder[rootIndex]);  
    root->left = helper(inorder,preorder,leftInS,leftInE,leftPreS,leftPreE);
    root->right = helper(inorder,preorder,rightInS,rightInE,rightPreS,rightPreE);

    return root;
}

TreeNode* buildTree(vector<int> preorder,vector<int> inorder){
    int n = preorder.size();
    TreeNode* root = helper(inorder,preorder,0,n-1,0,n-1);

    return root;
}

int maxProfit(vector<int> &prices){
    int buy = sell = 0;int n = prices.size();
    int profit = 0;

    for(int i = 0;i < n ;i++){
        while(i < n && price[i+1] <= prices[i]) i++;
        buy = prices[i];

        while(i < n && prices[i+1] >= prices[i]) i++;
        sell = prices[i];

        profit += sell - buy;
    }

    return profit;
}


int longestConsecutive(vector<int> &arr){

    int n = arr.size();
    int ans = 0;
    if(n == 0){
        return 0;
    }

    set<int> s;
    for(int i = 0;i < n;i++){
        s.insert(arr[i]);
    }

    for(int i = 0;i < n;i++){
        if(s.find(arr[i]-1) != s.end()){
            continue;
        }else{
            int current = arr[i];
            int count = 0;
            while(s.find(current) != s.end()){
                count++;
                current++;
            }
            ans = max(ans,count);
        }
    }
    return ans;


}

int canCompleteCircuit(vector<int> &gas,vector<int> &cost){


    int total_gas = total_cost = 0;
    int n = gas.size();
    for(int i = 0;i < n;i++){
        total_gas += gas[i];
        total_cost += cost[i];
    }

    if(total_cost > total_gas){
        return -1;
    }

    int curr_fuel = 0;
    int start = 0;
    for(int i = 0;i < n;i++){
        if(curr_fuel < 0){
            start = i;
            curr_fuel = 0;
        }

        curr_fuel += (gas[i]-cost[i]);
    }
    return start;
}

int canCompleteCircuit(vector<int> &gas,vector<int> &cost){
    int total_gas = 0;
    int total_cost = 0;
    int n = gas.size();
    for(int i = 0;i < n;i++){
        total_gas += gas[i];
        total_cost += cost[i];
    }

    if(total_cost > total_gas){
        return -1;
    }

    int start = 0;
    int curr_fuel = 0;
    for(int i = 0;i < n;i++){

        if(curr_fuel < 0){
            start = i;
            curr_fuel = 0;
        }

        curr_fuel += (gas[i]-cost[i]);
    }
    return start;
}


int evalRPN(vector<string> &tokens){

    stack<int> sc;

    for(int i = 0;i < tokens.size();i++){
        if(tokens[i] != "+" && tokens[i] != "-" && tokens[i] != "*" && tokens[i] != "/" ){
            sc.push_back(atoi(tokens[i].c_str()));
        }else{
            int v1 = sc.top();
            sc.pop();
            int v2 = sc.top();
            sc.pop();
            if(tokens[i] == '+'){
                sc.push(v2+v1);
            }else if(tokens[i] == '-'){
                sc.push(v2-v1);
            }else if(tokens[i] == '*'){
                sc.push(v2*v1);
            }else{
                sc.push(v2/v1);
            }
        }
    }
    return sc.top();
}

int maxProduct(vector<int> &nums){
    int l = r = ans = 0;
    int n = nums.size();
    for(int i = 0;i < nums.size();i++){
        l = (l ? l : 1)*nums[i];
        r = (r ? r : 1)*nums[n-1-i];

        ans = max(ans,max(l,r));
    }
    return ans;
}



int helper(vector<int> &nums,int low,int high){
    

    while(low <= high){
        int mid1 = (low+high)/2;
        int mid2 = mid1+1;

        if(nums[mid1] > nums[mid2]){
            high = mid1;
        }else{
            low = mid2;
        }
    }
    return low;
}
int findPeakElement(vector<int> &nums){
    int low = 0;
    int high = nums.size()-1;
    int ans = helper(nums,low,high);
    return ans;
}

void rotate(vector<int> &nums,int k){
    k %= nums.size();

    reverse(nums.begin(),nums.end());
    reverse(nums.begin(),nums.begin()+k);
    reverse(nums.begin()+k,nums.end());


}

int rob(vector<int> &nums){
    int amount1 = 0,amount2 = 0;
    int n = nums.size();
    for(int i = 0;i < n;i++){
        if(i%2 == 0){
            amount1 = max(amount2,amount1+nums[i]);
        }else{
            amount2 = max(amount1,amount2+nums[i]);
        }
    }
    return max(amount1,amount2);
}


int countPrimes(int n){
    vector<int> passed(n,false);
    int count= 0
    for(int i = 2;i < n;i++){
        if(passed[i]){
            continue;
        }else{
            count++;
            for(long multi = (long)i*i;multi < n;multi += i){
                passed[multi] = true;
            }
        }
    }
    return count;
}


int findKthLargestElement(vector<int> &nums,int k){
    sort(nums.begin(),nums.end());
    int i = nums.size()-1;

    while(k--){
        i--;
    }
    return nums[i];
}




vector<int> productExceptSelf(vector<int> &nums){
    int n = nums.size();
    vector<int> op(n,1);
    int product = 1;
    for(int i = 0;i < n;i++){
        product *= nums[i];
        op[i] = product;
    }

    product = 1;
    for(int i = n-1;i > 0;i--){
        op[i] = op[i-1]*product;
        product *= nums[i];
    }

    op[0] = product;
    return op;
}


vector<int> productExceptSelf(vector<int> &nums){
    int n = nums.size();
    int product = 1;
    vector<int> op(n,1);
    for(int i = 0;i < n;i++){
        product *= nums[i];
        op[i] = product;
    }

    product = 1;
    for(int i = n-1;i > 0;i--){
        op[i] = op[i-1]*product;
        product *= nums[i];
    }

    op[0] = product;
    return op;
}


vector<int> shuffle(){
    vector<int> result(nums);

    for(int i = 0;i < result.size();i++){
        int pos = rand()%(result.size() - i);
        swap(result[pos+i],result[i]);
    }
    return result;
}



vector<int> shuffle(){
    vector<int> result(nums);

    for(int i = 0;i <result.size();i++){
        int pos = rand()%(result.size() - i);
        swap(result[pos+i],result[i]);
    }
    return result;
}


vector<int> twoSum(vector<int> &nums,int target){
    unordered_map<int,int> mp;
    vector<int> ans;
    for(int i =0;i < nums.size();i++){
        int requiredIndex = target - nums[i];

        if(mp.count(requiredIndex)){
            ans.push_back(mp[requiredIndex]);
            ans.push_back(i);

            return ans;
        }
        mp[nums[i]] = i;
    }

    return ans;
}


int removeDuplicates(vector<int> &nums){
    int pos = 0;
    for(int i = 0;i < nums.size()-1;i++){
        if(nums[i] != nums[i+1]){
            nums[++pos] = nums[i+1];
        }
    }
    return pos+1;
}



int removeDuplicates(vector<int> &nums){
    int pos = 0;
    for(int i = 0;i < nums.size()-1;i++){
        if(nums[i] != nums[i+1]){
            nums[++pos] = nums[i+1];
        }
    }
    return pos+1;
}


vector<int> plusOne(vector<int> &digits){

    for(int i = digits.size()-1;i >= 0;i--){
        if(digits[i]+1 > 9){
            digits[i] = digits[i]+1 - 10;
            if(i == 0){
                digits.insert(digits.begin(),1);
            }
        }else{
            digits[i] = digits[i] +1;
            break;
        }
    }
    return digits;
    
}


void merge(vector<int> &nums1,int m,vector<int> &nums2,int n){

    int j = m-1;
    int k = n-1;
    int l = m+n-1;

    while(j >= 0 && k >= 0){
        if(nums1[j] > nums1[k]){
            nums1[l--] = nums1[j--];
        }else{
            nums1[l--] = nums2[k--];
        }
    }

    while(j >= 0){
        nums1[l--] = nums1[j--];
    }

    while(k >= 0){
        nums1[l--] = nums2[k--];
    }
    
}

TreeNode* helper(vector<int> &nums,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    TreeNode* root = new TreeNode(nums[mid]);

    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);

    return root;
}


TreeNode* sortedArrayToBST(vector<int>& nums){
    int n = nums.size();
    TreeNode* root = helper(nums,0,n-1);

    return root;
}



TreeNode* helper(vector<int> &nums,int s,int e){
    if(s > e){
        return NULL;
    }

    int mid = (s+e)/2;
    TreeNode *root = new TreeNode(nums[mid]);

    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);

    return root;
}

TreeNode* sortedArray(vector<int> &nums){

    int n = nums.size();
    TreeNode *root = helper(nums,0,n-1);
    return root;
}


vector<vector<int>> generate(int numRows){

    vector<vector<int>> ans;
    for(int i = 0;i < numRows;i++){
        vector<int> lans(i+1,1);

        for(int j = 1;j < i;i++){
            lans[j] = ans[i-1][j] + ans[i-1][j-1];
        }
        ans.push_back(lans);
    }
    return ans;
}


int maxProfit(vector<int> &prices){

    int smallest = INT_MAX;
    int max_profit = 0;
    int curr_profit = 0;

    for(int i = 0;i < prices.size();i++){
        if(prices[i] < smallest){
            smallest = prices[i];
        }

        curr_profit = prices[i] - smallest;
        if(curr_profit > max_profit){
            max_profit = curr_profit;
        }
    }
    return max_profit;
}


int singleNumber(vector<int> &nums){
    int n = nums.size();
    for(int i = 1;i < n;i += 2){
        if(nums[i] != nums[i-1]){
            return nums[i-1];
        }
    }
    return nums[nums.size()-1];
}


int majorityElement(vector<int> &nums){

    int count = 1;
    int cand = nums[0];
    int n = nums.size();
    for(int i = 1;i < nums.size();i++){
        if(nums[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                cand = nums[i];
                count = 1;
            }
        }
    }

    int count2 = 0;
    for(int i = 0;i < n;i++){
        if(nums[i] == cand){
            count2++;
        }
    }

    if(count2 >= n/2){
        return cand;
    }else{
        return -1;
    }
}


bool containsDuplicate(vector<int> &nums){

    int n = nums.size();
    sort(nums.begin(),nums.end());
    for(int i = 1;i < nums.size();i++){
        if(nums[i] == nums[i-1]){
            return true;
        }
    }
    return false;
}

int missingNumber(vector<int> &nums){
    int n = nums.size();
    sort(nums.begin(),nums.end());

    for(int i = 0;i < n;i++){
        if(nums[i] != i){
            n = i;
        }
    }
    return n;
}


void moveZeroes(vector<int> &nums){
    int n = nums.size();

    int pos = 0;
    for(int i = 0;i <n;i++){
        if(nums[i] != 0){
            nums[pos++] = nums[i];
        }
        
    }

    for(;pos < n;pos++){
        nums[pos] = 0;
    }

}


vector<int> intersect(vector<int> nums1,vector<int> nums2){

    unordered_map<int,int> mp;
    for(int a : nums1){
        mp[a]++;
    }

    vector<int> out;

    for(int b : nums2){
        if(mp[b]-- > 0){
            out.push_back(b);
        }
    }
    return out;
}

int helper(vector<int> nums,int s,int e){

    whie(s < e){
        int mid1 = (s+e)/2;
        int mid2 = mid1+1;

        if(nums[mid1] > nums[mid2]){
            e = mid1;
        }else{
            s = mid2;
        }
    }
    return s;
}

int findPeakElement(vector<int> nums){
    int n = nums.size();
    int op = helper(nums,0,n-1);

    return op;
}

int rob(vector<int> nums){
    int amount1 = amount2 = 0;

    for(int i = 0;i < nums.size();i++){
        if(i%2 == 0){
            amount1 = max(amount2,amount1+nums[i]);
        }else{
            amount2 = max(amount1,amount2+nums[i]);
        }
    }
    return max(amount1,amount2);
}


int findDuplicate(vector<int> nums){
    int op = 0;
    for(int i = 1;i < nums.size();i++){
        if(nums[i] == nums[i-1]){
            op = nums[i];
            break;
        }
    }
    return op;
}

vector<int> plusOne(vector<int> digits){

    int n = digits.size();
    for(int i = n-1;i >= 0;i-- ){
        if(digits[i]+1 > 9){
            digits[i] = digits[i]+1 - 10;
            if(i == 0) digits.insert(digits.begin(),1);
        }else{
            digits[i] = digits[i] +1;
            break;
        }
    }
    return digits;
}


vector<int> intersection(vector<int> nums1,vector<int> nums2){


    unordered_map<int,int> mp;
    for(int a : nums1){
        mp[a]++;
    }

    vector<int> output;
    for(int b : nums2){
        if(mp[b]-- > 0){
            output.push_back(b);
        }
    }
    return output;
}

int maxProfit(vector<int> prices){
    int n = prices.size();
    int curr_min = INT_MAX;
    int curr_profit = 0;
    int max_profit = 0;
    for(int i =0;i <n;i++){

        if(prices[i] < curr_min){
            curr_min = prices[i];
        }

        curr_profit = prices[i] - curr_min;

        if(curr_profit > max_profit){
            max_profit = curr_profit;
        }

    }
    return max_profit;
}



TreeNode* helper(vector<int> nums,int s,int e){

    if(s > e){
        return NULL;
    }

    int mid = (s+e)/2;
    TreeNode *root = new TreeNode(nums[mid]);

    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);

    return root; 
}

TreeNode* sortedArrayBST(vector<int> nums){
    int n = nums.size();

    TreeNode* root = helper(nums,0,n-1);
    return root;
}

vector<in> twoSum(vector<int> nums,int target){
    int n = nums.size();

    unordered_map<int,int> mp;
    vector<int> output;
    for(int i = 0;i <n;i++){
        int requiredIndex = target - nums[i];

        if(mp.count(requiredIndex)){
            output.push_back(i);
            output.push_back(mp[requiredIndex]);
            break;
        }
        mp[nums[i]] = i;
        
    }

    return output;
}



bool canJump(vector<int> nums){
    
    if(nums.size() == 1){
        return true;
    }


    if(nums[0] == 0){
        return false;
    }

    int n = nums.size();

    int jumps = 1;
    int steps = nums[0];
    int maxReach = nums[0];

    for(int i = 1;i < n;i++){
        if(i == n-1){
            return true;
        }

        maxReach = max(maxReach,nums[i]);
        steps--;

        if(steps == 0){
            jumps++;
            if(i >= maxReach){
                return false;
            }
            steps = maxReach -i;
        }
    }
    return true;
}

void helper(vector<int> &nums,int i,vector<int> &sub,vector<vector<int>> &ans){


    ans.push_back(sub);

    for(int j = i;j < nums.size();j++){
        sub.push_back(nums[i]);
        helper(nums,j+1,sub,ans);
        sub.pop_back();
    }
}

vector<vector<int>> subsets(vector<int> nums){
    vector<vector<int>> ans;
    vector<int> sub;

    helper(nums,0,sub,ans);

    return ans;
}


void helper(vector<int> &nums,int i ,vector<vector<int>> &ans){
    if(i == nums.size()){
        ans.push_back(nums);
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[i],nums[j]);
        helpe(nums,i+1,ans);
        swap(nums[i],nums[j]);
    }
}

vector<vector<int>> permute(vector<int> nums){
    vector<vector<int>> ans;
    helper(nums,0,ans);

    return ans;
}


int maxProfit(vector<int> &prices){

    int n = prices.size();
    int i = 0;int buy = 0;int sell = 0;
    while(i < n){
        while(i < n && prices[i+1] <= prices[i]) i++;
        buy = nums[i];

        while(i < n && nums[i+1] > nums[i]) i++;
        sell = nums[i];

        profit += sell - buy;
    }

    return profit;
}

int largestConsecutiveSeq(vector<int> nums){

    set<int> st;
    int n = nums.size();
    int ans = 0;
    for(int i = 0;i < n;i++){
        st.insert(nums[i]);
    }

    for(int i = 0;i < n;i++){
        if(s.find(nums[i]-1) != s.end()){
            continue;
        }else{
            int current = nums[i];
            int count = 0;

            while(s.find(current) != s.end()){
                count++;
                current++;
            }
            ans = max(ans,count);
        }
    }
    return ans;
}


vector<int> productExceptSelf(vector<int> &nums){

    int n = nums.size();
    vector<int> ans(n);
    int product = 1;

    for(int i = 0;i < n;i++){
        product *= nums[i];
        ans[i] = product;
    }

    product = 1;


    for(int i = n-1;i > 0;i--){
        ans[i] = product*ans[i-1];
        product *= nums[i];
    }

    nums[0] = product;
    return nums;
}

void sortColors(vector<int> &nums){
    int low = 0,mid = 0,high = nums.size()-1;


    for(int i = 0;i < n;i++){
        if(nums[mid] == 0){
            swap(nums[low++],nums[mid++]);
        }else if(nums[mid] == 2){
            swap(nums[mid],nums[high--]);
        }else{
            mid++;
        }
    }
}


vector<int> subArraySum(int arr[],int n,long long s){
    int l = 0,r = 0,sum = 0;
    sort(arr,arr+n);
    vector<int> ans;
    while(r < n){
        if(sum < s){
            sum += arr[r++];
        }else if(sum == s){
            ans.push_back(l);
            ans.push_back(r);
            break;
        }else{
            sum -= arr[l++];
        }
    }
}



vector<int> shuffle(vector<int> nums){
    vector<int> output(nums);
    for(int i = 0;i < nums.size();i++){
        int pos = rand()%(nums.size() - i);
        swap(output[i+pos],output[i]);
    }
    return output;
}


bool isValidSudoku(vector<vector<char>> &boards){

    unordered_map<string,bool> mp;
    for(int i = 0;i < boards.size();i++){
        for(int j = 0;j < boards[i].size();j++){
            if(boards[i][j] != '.'){
                string row = "row"+to_string(i)+boards[i][j];
                string col = "col"+to_string(j)+boards[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+boards[i][j];


                if(mp.count(row)){
                    return false;
                }else{
                    mp[row] = true;
                }

                if(mp.count(col)){
                    return false;
                }else{
                    mp[col] = true;
                }

                if(mp.count(box)){
                    return false;
                }else{
                    mp[box] = true;
                }
            }
        }
    }
    return true;
}



void rotate(vector<int> &matrix){


    reverse(matrix.begin(),matrix.end());
    
    for(int i = 0;i < n;i++){
        for(int j  = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }    
}


vector<vector<int>> threeSum(vector<int> &nums){
    
    
    int n = nums.size();
    vector<vector<int>> ans;

    for(int i = 0;i < n;i++){
        int target = -nums[i];

        int low = i+1;
        int high = n-1;
        
        while(low < high){

            int sum = nums[low]+nums[high];
            if(sum < target){
                low++;
            }else if(sum > high){
                high--;
            }else{
                vector<int> triplet = {nums[i],nums[low],nums[high]};
                ans.push_back(triplet);
                while(low < high && nums[low] == triplet[1]) low++;

                while(low < high && nums[high] == triplet[2]) high++;

            }
        }

        while(i+1 < n && nums[i] ==  nums[i+1]) i++;
    }
    return ans;
}



vector<vector<int>> threeSum(vector<int> &nums){
    int n = nums.size();

    vector<vector<int>> ans;

    for(int i = 0;i < n;i++){
        int target = -nums[i];

        int low = i+1;
        int high = n-1;

        while(low < high){


            int nums = nums[low] + nums[high];
            if(nums < target){
                low++;
            }else if(nums > target){
                high--;
            }else{
                vector<int> triplet = {nums[i],nums[low],nums[high]};

                ans.push_back(triplet);

                while(low < back && nums[low] == triplet[1]) low++;

                while(low < back && nums[high] == triplet[2]) back--;

            }
        }

        while(i+1 < n && nums[i] == nums[i+1]) i++;
    }

    return ans;
}


int maxProduct(vector<int> &nums){
    int n = nums.size();

    int l = 0,r = 0;
    int ans = 0;
    for(int i = 0;i < n;i++){
        l = (l ? l : 1)*nums[i];
        r = (r ? r : 1)*nums[n-1-i];

        ans = max(ans,max(l,r));

    }

    return ans;
}


int helper(vector<int> &nums,int s,int e){

    while(s < e){
        int mid1 = (s+e)/2;
        int mid2 = mid1+1;

        if(nums[mid1] > nums[mid2]){
            e = mid1;
        }else{
            s = mid2;
        }
    }

    return s;
}


int findPeakElement(vector<int> &nums){
    int n = nums.size();
    int ans = helper(nums,0,n-1);

    return ans;
}


vector<int> productExceptSelf(vector<int> &nums){

    int n = nums.size();
    vector<int> output;

    int product = 1;

    for(int i = 0;i < n;i++){

        producut *= nums[i];

        output[i] = product;

    }

    product = 1;

    for(int i = n-1;i > 0;i--){
        output[i] = output[i-1]*product;
        product *= nums[i];
    }

    output[0] = product;
    return output;
}


int maxSubArray(vector<int> &nums){
    int current_sum = 0;
    int total_sum = 0;

    for(int i = 0;i < nums.size();i++){
        
        current_sum = max(nums[i],current_sum+nums[i]);
        if(current_sum > total_sum){
            total_sum = current_sum;
        }
    }

    return total_sum;
}



vector<int> duplicates(vector<int> nums,int n){
    unordered_map<int,int> mp;
    vector<int> ans;
    sort(nums.begin(),nums.end());
    for(int i = 0;i <n ;i++){
        if(nums[i] == nums[i+1]){
            if(mp.find(nums[i]) == mp.end()){
                mp[nums[i]]++;
                ans.push_back(nums[i]);           
            }
        }
    }

    return ans;
}



int partition(int a[],int s,int e){
    int i = s;
    int pivot = a[e];

    for(int j = s;j <e;j++){
        if(a[j] < pivot){
            swap(a[i],a[j]);
            i++;
        }
    }

    swap(a[e],a[i]);
    return i;
}

void quickSort(int a[],int s,int e){
    if(s >= e){
        return ;
    }

    int p = partition(a,s,e);
    quickSort(a,s,p-1);
    quickSort(a,p+1,e);
}


vector<int> commonElements(int a[],int b[],int c[],int n1,int n2,int n3){

    set<int> s;
    vector<int> ans;

    int x_loc = 0;
    int y_loc = 0;
    int z_loc = 0;

    while(x_loc != n1 && y_loc != n2 && z_loc != n3){
        if(a[x_loc] == b[y_loc] && b[y_loc] == c[z_loc]){
            ans.push_back(a[x_loc]);
            x_loc++;
            y_loc++;
            z_loc++;
        }else if(a[x_loc] < b[y_loc] && a[x_loc] < c[z_loc]){
            x_loc++;
        }else if(b[y_loc] < a[x_loc] && b[y_loc] < c[z_loc]){
            y_loc++;
        }else{
            z_loc++;
        }
    }

    return ans;
}


long long int countSubArray(int a[],int n){
    int sum = 0,ans = 0;
    unordered_map<int,int> mp;
    mp[0] = 1;
    for(int i = 0;i < n;i++){
        if(a[i] == 0){
            sum -= 1;
        }else{
            sum += 1;
        }

        if(mp.count(sum)){
            ans += mp[sum];
            mp[sum]++;
        }else{
            mp[sum]++;
        }
    }

    return ans;
}

int romanToInt(string s){

    unordered_map<char,int> mp = {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
    int ans = 0;
    for(int i = 0;i < s.size();i++){
        if(mp[s[i]] < ans){
            if(mp[s[i]]*4 < ans){
                ans -= mp[s[i]];
            }else{
                ans += mp[s[i]];
            }
        }else{
            ans += mp[s[i]];
        }
    }
    return ans;
}


string longestCommonPrefix(vector<int> &strs){

    int min_length = INT_MAX;
    int n = strs.length();
    string ans = "";
    for(int i = 0;i < n;i++){
        if(strs[i].length() < min_length){
            min_length = strs[i].length();
        }
    }

    for(int i = 0;i < min_length;i++){
        int currentChar = strs[0][i];
        for(int j = 0;j < n;j++){
            if(currentChar != strs[j][i]){
                return ans;
            }
        }
        ans += currentChar;
    }

     return ans;
}
string longestCommonPrefix(vector<int> &strs){
    int min_length = INT_MAX;
    int n = strs.size();
    for(int i = 0;i <n;i++){
        if(min_length > strs[i].length()){
            min_length = strs[i].length();
        }
    }

    for(int i = 0;i < min_length;i++){
        char currentChar = strs[0][i];

        for(int j = 0;j < strs.size() ;i++){
            if(currentChar != strs[j][i]){
                return false;
            }
        }
        ans.push_back(currentChar);
    }
    return ans;
}



bool isValid(string s){
    stack<int> st;
    for(int i = 0;i < s.length();i++){
        if(s[i] == "{" || s[i] == "[" || s[i] == "("){
            st.push(s[i]);
        }else{
            if(st.empty()){
                return false;
            }else if(s[i] == ")"){
                if(st.top() == "("){
                    st.pop();
                }else{
                    return false;
                }
            }else if(s[i] == "}"){
                if(st.top() == "{"){
                    st.pop();
                }else{
                    return false;
                }
            }else if(s[i] == "]"){
                if(st.top() == "["){
                    st.pop();
                }else{
                    return false;
                }
            }
        }
    }
    return a.empty();
}


bool isPalindrome(string s){
    int n = s.length();
    
    for(int i = 0,j = s.size()-1;i < j;i++,j--){
        while(i < j && !isalnum(s[i])) i++;
        while(i < j && !isalnum(s[j])) j--;

        if(to_upper(s[i]) != to_upper(s[j])) return false;
    }
    return true;
}


bool isPalindrome(string s){

    for(int i = 0,j = s.size()-1;i < j;i++,j--){
        while(i < j && !isalnum(s[i])) i++;
        while(i < j && !isalnum(s[j])) j--;

        if(to_upper(s[i]) != to_upper(s[j])) return false;
    }
    return true;
}

int titleToNumber(string columnTitle){
    int result = 0;

    for(char s : columnTitle){
        int d = s - 'A' + 1;
        result = result*26 + d;
    }

    return result;
}


bool isAnagram(string s,string t){
    sort(s.begin(),s.end());
    sort(t.begin(),t.end());

    if(s.lengt() != t.length) return false;
    bool ans = true;
    for(int i = 0;i < s.length();i++){
        if(s[i] != t[i]) ans = false;
    }
    return ans;
}


void reverseStrng(vector<char> &st){

    int s = 0;
    int e = s.size()-1;

    while(s < e){
        swap(st[s++],st[e--]);
    }
}



int lengthOfLongest(string s){
    int max = 0;
    int start = 0;
    int end = 0;
    set<char> st;

    while(start < s.size()){
        if(st.find(s[start]) == st.end()){
            st.insert(s[start]);
            if(start-end+1 > max){
                max = start-end+1;
            }
            start++;
        }else{
            st.erase(s[end]);
            end++;
        }
    }
    return max;
}


int longestSub(string s){
    set<char> st;
    int start = 0;
    int end = 0;
    int max = 0;

    while(start < s.size()){
        if(st.find(s[start]) == st.end()){
            st.insert(s[start]);
            if(start-end+1 > max){
                max = start-end+1;
            }
            start++;
        }else{
            st.erase(s[end]);
            end++;
        }
    }

    return max;
}


int maxArea(vector<int> &heights){
    int n = heights.size();


    
    int left = 0;
    int right = n-1;
    int ans = 0;
    while(left <= right){

        ans = max(min(heights[left],heights[right])*(right-left),ans);

        if(heights[left]<heights[right]){
            left++;
        }else{
            right--;
        }
    }

    return ans;
}


vector<vector<int>> threeSum(vector<int> &nums){
    int n = nums.size();
    vector<vector<int>> ans;
    
    sort(nums.begin(),nums.end());
    for(int i = 0;i < n;i++){


        int target = -nums[i];
        int left = i+1;
        int right = n-1;

        while(left <= right){
            int sum = nums[left]+nums[right];

            if(sum < target){
                left++;
            }else if(sum > target){
                right--;
            }else{
                vector<int> triplet = {nums[i],nums[left],nums[right]};

                ans.push_back(triplet);

                while(left < right && nums[left] == triplet[1]) left++;

                while(left < right && nums[right] == triplet[2]) right--;
            }
        }

        while(i+1 < n && nums[i+1] == nums[i]) i++;
    
    }
    return ans;
}



int search(vector<int> nums,int target){

    int n = nums.size();

    int left = 0;
    int right = n-1;
    int ans = -1;
    while(left < right){
        int mid = (left+right)/2;

        if(nums[mid] == target){
            ans = mid;
        }
        if(nums[left] < nums[mid]){
            if(target > nums[left] && target < nums[mid]){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(target > nums[mid] && target < nums[mid]){
                s = mid+1;
            }else{
                e = mid-1;
            }
        }
    }
    return ans;
}




int getFirst(vector<int> nums,int target){
    int s = 0;
    int e = nums.size()-1;
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }
        if(nums[mid] < target){
            s = mid+1;
        }else{
            e = mid-1;
        }
    }
}

int getLast(vector<int> nums,int target){
    int n = nums.size();

    int s = 0;
    int e = n-1;
    int ans = -1;
    while(s <= e){
        int mid = (s+e)/2;

        if(nums[mid] == target){
            ans = mid;
            s = mid+1;
        }
        if(nums[mid] < target){
            s = mid+1;
        }else{
            e = mid-1;
        }
    }

    return ans;
}

vector<int> searchRange(vector<int> nums,int target){
    

    int first = getFirst(nums,target);
    int last = getLast(nums,target);

    vector<int> ans;
    ans.push_back(first);
    ans.push_back(last);

    return ans;
}


bool validSudoku(vector<vector<char>> &board){


    unordered_map<string,bool> mp;
    for(int i = 0;i < board.size();i++){
        for(int j = 0;j < board[i].size();j++){
            if(board[i][j] != '.'){
                string row = "row"+to_string(i)+board[i][j];
                string col = "col"+to_string(j)+board[i][j];
                string box = "box"+to_string((i/3)*3+(j/3))+board[i][j];

        
                if(!mp.count(row)){
                    mp[row] = true;
                }else{
                    return false;
                }

                if(!mp.count(col)){
                    mp[col] = true;
                }else{
                    return false;
                }

                if(!mp.count(box)){
                    mp[box] = true;
                }else{
                    return false;
                }
            }
        }
    }
    return true;
}


void helper(vector<int> nums,int i,vector<vector<int>> &ans){
    if(i == nums.size()){
        ans.push_back(nums);
        return ;
    }

    for(int j = i;j < nums.size();j++){
        swap(nums[i],nums[j]);
        helper(nums,i+1,ans);
        swap(nums[i],nums[j]);
    }
}

vector<vector<int>> permute(vector<int>& nums){

    vector<vector<int>> ans;
    helper(nums,i,ans);

    return ans;
}

void rotate(vector<vector<int>> &matrix){

    reverse(matrix.begin(),matrix.end());

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < i;j++){
            swap(matrix[i][j],matrix[j][i]);
        }
    }
}


vector<vector<string>> groupAnagrams(vector<string> &strs){

    unordered_map<string,vector<string>> mp;

    for(auto str : strs){
        string sorted = str;
        sort(sorted.begin(),sorted.end());
        mp[sorted].push_back(str);
    }

    vector<string> ans;

    for(auto el : mp){
        ans.push_back(el.second);
    }

    return ans;
}

int maxSubArray(vector<int> &nums){

    int n = nums.size();
    int global_sum = 0;
    int current_sum = 0;
    for(int i = 0;i < n;i++){

        int current_sum = max(nums[i],current_sum+nums[i]);
        if(current_sum > global_sum){
            global_sum = current_sum;
        }
    }
    return global_sum;
}


vector<int> spiralOrder(vector<vector<int>> &matrix){

    int k =0,l=0,last_row=matrix.size()-1,last_col=matrix[0].size()-1;

    vector<int> ans;

    while(k <= last_row && l <= last_col){

        for(int i = l;i <= last_col;i++){
            ans.push_back(matrix[k][i]);
        }
        k++;

        for(int i = k;i < last_row;i++){
            ans.push_back(matrix[i][last_col]);
        }
        last_col--;

        if(k <= last_row){
            for(int i = last_col;i >= l;i--){
                ans.push_back(matrix[last_row][i]);
            }
            last_row--;
        }

        if(l <= last_col){
            for(int i = last_row;i >= k;i--){
                ans.push_back(matrix[i][l]);
            }
            l++;
        }

    }
    return ans;
}


bool canJump(vector<int> &nums){

    if(nums.size() == 1){
        return true;
    }
    if(nums[0] == 0){
        return false;
    }
    int n = nums.size();
    int steps = nums[0];
    int maxReach = nums[0];
    int jumps = 1;
    for(int i = 1;i < n;i++){

        if(i == n-1){
            return true;
        }

        maxReach = max(maxReach,nums[i]);
        steps--;

        if(steps == 0){
            jumps++;
            if(i >= maxReach){
                return false;
            }
            steps = maxReach - i;
        }

    }
    return true;
}


vector<vector<int>> mergeIntervals(vector<vector<int>> intervals){

    vector<vector<int>> ans;
    sort(intervals.begin(),intervals.end());
    ans.push_back(intervals[0]);

    for(int i = 1;i < intervals.size();i++){
        if(ans.back()[1] > intervals[i][0]){
            ans.back()[1] = max(ans.back()[1],intervals[i][1]);
        }else{
            ans.push_back(intervals[i]);
        }
    }

    return ans;
}

void setZeroes(vector<vector<int>> &matrix){

    bool r = flase,c = false;

    for(int i = 0;i < matrix.size();i++){
        for(int j = 0;j < matrix[0].size();j++){
            if(matrix[i][j] == 0){
                if(i == 0) r = true;
                if(j == 0) c = true;


                matrix[0][j] = matrix[i][0] = 0;
            }
        }
    }

    for(int i = 1;i < matrix.size();i++){
        for(int j = 1;j < matrix[0].size();j++){
            if(matrix[0][j] == 0 || matrix[i][0] == 0){
                matrix[i][j] = 0;
            }
        }
    }

    if(r){
        for(int i = 0;i < matrix[0].size();i++){
            matrix[0][i] = 0;
        }
    }

    if(c){
        for(int i = 0;i < matrix.size();i++){
            matrix[i][0] = 0;
        }
    }
}


void sortColors(vector<int> &nums){
    int low = 0,mid = 0,high = nums.size()-1;

    while(mid <= high){
        if(nums[mid] == 0){
            swap(nums[low++],nums[mid++]);
        }else if(nums[mid] == 2){
            swap(nums[mid],nums[high--]);
        }else{
            mid++;
        }
    }
}


void helper(vector<int> &nums,vector<int> &temp;int i,vector<vector<int>> &ans){

    ans.push_back(temp);

    for(int j = i;j < nums.size();j++){
        temp.push_back(nums[j]);
        helper(nums,temp,j+1,ans);
        temp.pop_back();
    }
}

vector<vector<int>> subsets(vector<int> nums){

    vector<vector<int>> ans;

    helper(nums,temp,i,ans);
}


TreeNode* helper(vector<int> preorder,vector<int> inorder,int preS,int preE,int inS,int inE){


    if(inS > inE){
        return NULL;
    }

    int rootData = preorder[preS];
    int rootIndex = -1;
    for(int i = 0;i < inorder.size();i++){
        if(rootData == inorder[i]){
            rootIndex = i;
            break;
        }
    }    

    int leftIns = inS;
    int leftInE = rootIndex-1;
    int leftPreS = preS+1;
    int leftPreE = leftPres + leftInE - leftInS;

    int rightInS = rootIndex+1;
    int rightInE = inE;
    int rightPreS = leftPreE+1;
    int rightPreE = preE;

    TreeNode* root = new TreeNode(rootData);
    root->left = helper(preorder,inorder,leftPreS,leftPreE,leftInS,leftInE);
    root->right = helper(preorder,inorder,rightPreS,rightPreE,rightInS,rightInE);

    return root;
}

TreeNode* buildTree(vector<int> preorder,vector<int> inorder){

    preS = 0;
    preE = preorder.size()-1;
    inS = 0;
    inE = inorder.size()-1;

    TreeNode* root = helper(preorder,inorder,preS,preE,inS,inE);
    return root;
}

int maxProfit(vector<int> prices){
    int n = prices.size();
    int i = 0;
    int buy = 0;
    int sell = 0;
    int profit = 0;
    while(i < n){
        while(i < n && prices[i+1] < prices[i]) i++;
        buy = i;

        while(i < n && prices[i+1] > prices[i]) i++;
        sell = i;

        profit += (sell-buy);
    }
    return profit;
}

int longestConsecutiveSequence(vector<int> &arr){
    set<int> st;
    int n = arr.size();
    for(int i = 0;i < n;i++){
        st.insert(arr[i]);
    }

    int ans = 0;
    for(int i = 0;i < n;i++){
        if(st.find(arr[i]-1) != st.end()){
            continue;
        }else{
            int count = 0;
            int current = arr[i];

            while(st.find(current) != st.end()){
                count++;
                current++;
            }
            ans = max(ans,count);
        }
    }
    return ans;
}

int canCompleteCircuit(vector<int> gas,vector<int> cost){

    int total_gas = 0;
    int total_cost = 0;

    for(int i = 0;i < gas.size();i++){
        total_gas += gas[i];
        total_cost += cost[i];
    }

    if(total_cost > total_gas){
        return -1;
    }
    int start = 0;
    int ans = 0;
    for(int i = 0;i < gas.size();i++){

        if(ans < 0){
            ans = 0;
            start = i;
        }

        ans += gas[i] - cost[i];
    }

    return start;
}


int evalRPN(vector<string> &tokens){
    
    stack<int> st;
    for(int i = 0;i < tokens.size();i++){
        if(tokens[i] != '+' && tokens[i] != '-' && && tokens[i] != '*' && tokens[i] != '/'){
            st.push(atoi(tokens[i].c_str()));
        }else{
            int v1 = st.top();
            st.pop();
            int v2 = st.top();
            st.pop();
            if(tokens[i] == '+'){
                st.push(v2+v1);
            }else if(tokens[i] == '-'){
                st.push(v2-v1);
            }else if(tokens[i] == '*'){
                st.push(v2*v1);
            }else{
                st.push(v2/v1);
            }
        }
    }
    return st.top();
}

int maxProductSubArray(vector<int> nums){

    int l = 0;
    int r = 0;
    int n = nums.size();
    int ans = 0;
    for(int i = 0;i < nums.size();i++){
        l = (l ? l : 1)*nums[i];
        r = (r ? r : 1)*nums[n-1-i];

        ans = max(ans,max(l,r));
    }
    return ans;
}


void helper(vector<int> nums,int s,int e){


    while(s <= e){
        int mid1 = (s+e)/2;
        int mid2 = mid1+1;

        if(nums[mid1] < nums[mid2]){
            s = mid2;
        }else{
            e = mid1;
        }
    }
    return s;
}

int findPeakElement(vector<int> nums){

    int e = nums.size()-1;
    int ans = helper(nums,0,e);

    return ans;
}

void rotate(vector<int> nums,int k){
    k %= nums.size();

    reverse(nums.begin(),nums.end());
    reverse(nums.begin(),nums.begin()+k);
    reverse(nums.begin()+k,nums.end());

}


int rob(vector<int> nums){
    int amount1 = 0;
    int amount2 = 0;
    int n = nums.size();
    for(int i = 0;i < n;i++){
        if(i%2 == 0){
            amount1 = max(amount2,amount1+nums[i]);
        }else{
            amount2 = max(amount1,amount2+nums[i]);
        }
        
    }
    return max(amount1,amount2);

}

int countPrimes(int n){

    vector<bool> passed(n);
    int count = 0;
    for(int i = 2;i < n;i++){

        if(passed[i]){
            continue;
        }else{
            count++;
            for(long long int multi = (long)i*i;multi < n;multi += i){
                passed[multi] = true;
            }
        }
    }
    return count;
}

int findKthLargestElement(vector<int> nums,int k){

    int i = nums.size()-1;
    sort(nums.begin(),nums.end());
    while(k--){
        i--;

    }
    return nums[i];
}

vector<int> productExceptSelf(vector<int> nums){


    int n = nums.size();
    vector<int> op(n,1);
    int product = 1;
    for(int i = 0;i < n;i++){
        product *= nums[i];
        op[i] = product;
    }

    product = 1;
    for(int i = n-1;i > 0;i--){
        op[i] = product*op[i-1];
        product *= nums[i];
    }

    op[0] = product;
    return op;
}

vector<int> shuffle(vector<int> nums){

    int n = nums.size();
    vector<int> result(nums);
    for(int i = 0;i < n;i++){
        int pos = rand()%(result.size()-i);

        swap(result[pos+i],result[i]);
    }

    return result;
}



vector<int> twoSum(vector<int> nums,int target){


    int n = nums.size();
    unordered_map<int,int> mp;
    vector<int> result;
    for(int i = 0;i < n;i++){
        int requiredIndex = target-nums[i];
        if(mp.count(requiredIndex)){
            result.push_back(requiredIndex);
            result.push_back(mp[nums[i]]);
            return result;
            break;
        }
        mp[nums[i]] = i;
    }
    return {-1};
}


int removeDuplicates(vector<int> nums){
    int pos = 0;
    sort(nums.begin(),nums.end());
    for(int i = 0;i < nums.size();i++){
        if(nums[i] != nums[i+1]){
            nums[++pos] = nums[i+1];
        }
    }
    return pos+1;
}

vector<int> plusOne(vector<int> &digits){

    int n = digits.size();
    for(int i = n-1;i >= 0;i--){
        if(digits[i]+1 > 9){
            digits[i] = digits[i]+1 - 10;
            if(i == 0) digits.insert(digits.begin(),1);
        }else{
            digits[i] = digits[i]+1;
        }
    }
    return digits;
}

void merge(vector<int> nums1,int m,int nums2,int n){
    int k = m-1;
    int l = n-1;
    int o = m+n-1;

    while(k >= 0 && l >= 0){
        if(nums1[k] > nums2[l]){
            nums1[o--] = nums1[k--];
        }else{
            nums1[o--] = nums2[l--];
        }
    }

    while(k >= 0){
        nums1[o--] = nums1[k--];
    }

    while(l >= 0){
        nums1[o--] = nums2[l--];
    }
}

TreeNode*  helper(vector<int> nums,int s,int e){

    int mid = (s+e)/2;
    int rootData = nums[mid];
    TreeNode* root = new TreeNode(rootData);
    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);
    return root;
}


TreeNode* sortedArrayToBST(vector<int> nums){
    
    int n = nums.size();
    TreeNode* root = helper(nums,0,n-1);
    return root;
}


vector<vector<int>> generate(int numRows){
    vector<vector<int>> ans;

    for(int i = 0;i < numRows;i++){
        vector<int> temp(i+1,1);
        for(int j = 1;j < i;j++){
            temp[j] = ans[i-1][j]+ans[i-1][j-1];
        }
        ans.push_back(temp);
    }
    return ans;
}

int maxProfit(vector<int> &prices){


    int ans = 0;
    int minTillNow = INT_MAX;
    int currentProfit = 0;
    int n = prices.size();

    for(int  i = 0;i < n;i++){
        if(minTillNow > prices[i]){
            minTillNow = prices[i];
        }

        currentProfit = prices[i]-minTillNow;

        if(currentProfit > ans){
            ans  = currentProfit;
        }
    }

    return ans;
    

}


int singleNumber(vector<int> nums){

    int n = nums.size();
    for(int i = 1;i < n;i += 2){
        if(nums[i] != nums[i-1]){
            return nums[i];
        }
    }
    return nums[nums.size()-1];
}



int majorityElement(vector<int>  nums){

    int cand = nums[0];
    int count =1 ;
    int n = nums.size();
    for(int i = 1;i < n;i++){
        if(nums[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                cand = nums[i];
                count = 1;
            }
        }
    }

    int count2 = 0;

    for(int i = 0;i < n;i++){
        if(nums[i] == cand){
            count2++;
        }
    }

    if(count2 >= n/2){
        return cand;
    }else{
        return -1;
    }
}


void moveZeroes(vector<int>& nums){

    int n = nums.size();
    int pos = 0;
    for(int i = 0;i < n;i++){
        if(nums[i] != 0){
            nums[pos++] = nums[i];
        }
    }
    for(int i = pos;i < n;i++){
        nums[i] = 0;
    }
}

vector<int> intersect(vector<int> nums1,vector<int> nums2){

    int j = 0;
    int k = 0;

    vector<int> ans;

    while(j < nums1.size() && k < nums2.size()){

        if(nums1[j] == nums2[k]){
            ans.push_back(nums1[j]);
            j++;
            k++;
        }else if(nums1[j] < nums2[k]){
            j++;
        }else{
            k++;
        }
    }

    return ans;
}


vector<int> intersect(vector<int> nums1,vector<int> nums2){

    unordered_map<int,int> mp;

    for(auto a : nums1){
        mp[a]++;
    }

    vector<int> ans;
    for(auto b : nums2){
        if(mp[b]-- > 0){
            ans.push_back(b);
        }
    }
    return ans;
}

class Node{
    public : 
        int data;
        Node* next;

        Node(int data){
            this->data = data;
            this->next = NULL;
        }
}


Node *takeInput(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* currNode = NULL;
    while(data != -1){
        Node *n = new Node(data);
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            currNode->next = n;
            currNode = n;
        }
        cin>>data;
    }
    return head;
}

Node* takeInput2(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* currNode = NULL;
    while(data != -1){
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            n->next = head;
            head = n;
        }
        cin>>data;
    }
    return head;
}

int length(Node *head){
    int count = 0;
    Node *temp = head;

    while(temp){
        count++;
        temp = temp->next ;
    }
    return count;
}

void printIthNode(Node *head,int i){

    if(i < 0 || i > length(head)-1){
        cout<<"-1"<<endl;
    }
    Node *temp = head;
    while(i--){
        temp = temp->next;
    }
    cout<<temp->data;
    return ;
}

class Node{
    public :
        int data;
        Node *next;

        Node(int data){
            this->data = data;
            next = NULL;
        }
}

Node* takeInput(){
    int data;
    cin>>data;
    Node *head = NULL;
    Node *currNode = NULL;

    while(data != -1){
        Node *n = new Node(data);
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            currNode->next = n;
            currNode = n;
        }

        cin>>data;
    }
    return head;
};

int length(Node *head){

    Node *temp = head;
    int count = 0;
    while(temp){
        count++;
        temp = temp->next;
    }

    return count;
}


void print(Node *head){
    Node *temp = head;

    while(temp){
        cout<<temp->data<<" ";

        temp = temp->next;
    }
}

void printIthNode(Node *head,int i){
    if(i == 0){
        cout<<head->data;
        return ;
    }

    if(i < 0 || i > length(head) -1){
        return ;
    }

    Node *temp = head;

    int count = 1;
    while(count <= i){
        temp = temp->next;
        count++;
    }

    if(temp){
        cout<<temp->data<<endl;
    }else{
        return ;
    }
}

Node* insertAtIthNode(Node *head,int i,int data){
    if(i == 0){
        Node *n = new Node(data);
        n->next = head;
        head = n;
        return head;
    }

    if(i < 0 || i > length(head)-1){
        return head;
    }
    Node *temp = head;
    int count = 1;
    while(count < i || temp != NULL){
        temp = temp->next;
        count++;
    }

    if(temp){
        Node *n = new Node(data);
        n->next = temp->next;
        temp->next = n;
    }

    return temp;
}

Node* deleteIthNode(Node *head,int i){

    if(i == 0){
        Node *temp = head->next;
        head->next = NULL;
        delete head;
        return temp;
    }

    if(i < 0 || i > length(head)-1){
        return head;
    }

    Node *temp =  head;

    int count = 1;
    while(count < i && temp != NULL){
        temp = temp->next;
        count++;
    }

    if(temp){
        Node *curr = temp->next;
        temp->next = temp->next->next;
        curr->next = NULL;
        delete curr;
    }
    return temp;
}


int lengthRecursively(Node *head){

    if(head == NULL){
        return 0;
    }
    int smallans = lengthRecursively(head->next);
    return 1+smallAns;
}

bool isPresent(Node *head,int data){
    if(head == NULL){
        return false;
    }

    Node *temp = head;

    while(temp != NULL){
        if(temp->data == data){
            return true;
        }
    }
    return false;
}


bool isPresent2(Node* head,int data){
    if(head == NULL){
        return false;
    }
    if(head->data == data){
        return true;
    }
    return isPresent2(head->next,data);
}

int middleLL(Node *head){
    if(head == NULL){
        return 0;
    }

    Node *slow = head->next;
    Node *fast = head->next->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    if(fast != NULL){
        return slow->next->data;
    }

    return slow->data;
}

Node* removeKthNode(Node *head,int k){
    if(head == NULL){
        return NULL;
    }

    Node *first = head->next;
    Node *second = head->next;

    while(k--){
        second = second->next;
    }

    if(second == NULL){
        return first->next;
    }

    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }

    first->next = first->next->next;
    return head;
}

Node* reverseLL(Node *head){

    Node *curr = head;
    Node *prev = NULL;

    while(curr != NULL){
        Node *n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }

    return prev;
}



Node* sortList(Node* head){

    if(head == NULL || head->next == NULL){
        return NULL;
    }

    Node *slow = head->next;
    Node *fast = head->next->next;

    while(fast && fast->next){

        slow = slow->next;
        fast = fast->next->next;
    }

    Node *n = slow->next;
    slow->next = NULL;

    Node *a = sortList(head);
    Node *b = sortList(n);

    head = mergeTwoList(a,b);

    return head;
}


Node* mergeTwoList(Node *a,Node *b){

    if(a == NULL) return b;
    if(b == NULL) return a;

    Node *currNode = NULL;
    if(a->val < b->val){
        currNode = a;
        currNode->next = mergeTwoList(a->next,b);
    }else{
        currNode = b;
        currNode->next = mergeTwoList(a,b->next);
    }

    return currNode;
}

bool hasCycle(Node *head){

    Node *slow = head,*fast = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast) return true;
    }
    return false;
    
}




Node* connect(Node *root){

    if(!root) return NULL;

    queue<Node*> q;
    q.push(root);
    while(!q.empty()){
        int l = q.size() ,l1 = l;
        for(int i = 0;i < l;i++){
            Node *f = q.front();
            q.pop();
            if(i == l1-1) f->next = NULL;
            else{ f->next = q.front()};

            if(f->left) q.push(f->left);
            if(f->right) q.push(f->right);
        }
    }

    return root;
}



Node* copyRandomList(Node* head){

    if(!head) return NULL;

    Node* temp = head;
    unordered_map<Node*,Node*> mp;
    while(temp){
        Node *n = new Node(temp->val);
        mp[temp] = n;
        temp = temp->next;
    }

    temp = head;
    while(temp){
        mp[temp]->next = mp[temp->next];
        mp[temp]->random = mp[temp->random];
        temp = temp->next;
    }

    return mp[head];
}


ListNode* mergeKList(vector<ListNode*> &lists){
    int size = lists.size();


    vector<pair<int,ListNode*>> arr;

    for(int i = 0;i < size;i++){

        ListNode* curr_list = lists[i];
        while(curr_list){
            arr.push_back({curr_list->val,curr_list});
        }
    }

    sort(arr.begin(),arr.end());

    for(int i = 0;i < arr.size()-1;i++){
        arr[i].second->next = arr[i+1].second;
    }

    arr[arr.size()-1].second->next = NULL;


    return arr[0].second;


}



class Stack{

    private : 
        int capacity;
        int *arr;
        int nextIndex;

    public :

        Stack(){
            capacity = 4;
            arr = new int[capacity];
            nextIndex = 0;
        }

        int size(){
            return nextIndex;
        }

        bool isEmpty(){
            return nextIndex == 0;
        }

        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }
            nextIndex--;
        }

        void push(int element){
            
            if(nextIndex == capacity){
                int *newArr = new int[2*capacity];
                for(int i = 0;i < capacity;i++){
                    newArr[i] = arr[i];
                }

                delete []arr;
                arr = newArr;
                capacity = 2*capacity;
            }

            arr[nextIndex] = element;
            nextIndex++;
        }

        int top(){

            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return -1;
            }

            return arr[nextIndex-1];
        }
}


template<typename T>
class Stack{

    private : 
        T *arr;
        int capacity;
        int nextIndex;
    public :
        Stack(){
            capacity = 4;
            arr = new T[capacity];
            nextIndex = 0;
        }

        int size(){
            return nextIndex;
        }

        bool isEmpty(){
            return nextIndex == 0;
        }

        void push(T element){
            
            if(nextIndex == capacity){
                T *newArr = new T[2*capacity];
                for(int i = 0;i < capacity;i++){
                    newArr[i] = arr[i];
                }

                delete []arr;
                arr = newArr;
                capacity = 2*capacity;
            }

            arr[nextIndex] = element;
            nextIndex++;
        }

        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }

            nextIndex--;
        }

        T top(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return NULL;
            }

            return arr[nextIndex-1];
        }

}


template<typename T>
class Node{

    public :
        T data;
        Node<T> *next;

        Node(T data){
            this->data = data;
            next = NULL;
        }
}

template<typename T>
class Stack{
    private :
        Node<T> head;
        int size;

    Public :
        Stack(){
            head = NULL;
            size = 0;
        }

        bool isEmpty(){
            return size == 0;
        }

        int size(){
            return size;
        }

        void push(T element){
            Node<T> *n = new Node<T>(element);
            n->next = head;
            head = n;
            size++;
        }

        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }

            Node<T> *temp = head->next;
            head = head->next;
            temp->next = NULL;
            delete temp;
            size--;
        }

        T top(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return NULL;
            }

            return head->data;
        }
}


// remove Adjacent Duplicates

string removeDuplicates(string A){


    int stptr = -1;

    for(int i = 0;i < A.size();i++){
        if(stptr == -1 || A[i] != A[stptr]){
            stptr++;
            A[stptr] = A[i];
        }else{
            stptr--;
        }
    }

    string ans = "";
    for(int i = 0;i <= stptr;i++){
        ans.push_back(A[i]);
    }

    return ans;
}



string removeDuplicates(string A){

    stack<char> s;

    for(int i = 0;i < A.size();i++){
        if(s.empty() || s.top() != A[i]){
            s.push(A[i]);
        }else{
            s.pop();
        }
    }

    string ans = "";
    while(!s.empty()){
        ans.push_back(s.top());
        s.pop();
    }

    reverse(ans.begin(),ans.end());
    return ans;
}

void removeDuplicates(char input[]){


    if(input[0] == '\0'){
        return ;
    }
    if(input[0] == input[1]){
        for(int i = 0;input[i] != '\0';i++){
            input[i] = input[i+1];
        }
        removeDuplicates(input);
    }else{
        removeDuplicates(input+1);
    }
}



bool isValid(string a){

    stack<char> s;
    for(int i = 0;i < a.length();i++){
        if(a[i] == '(' || a[i] == '{' || a[i] == '['){
            s.push(a[i]);
        }else{
            if(s.empty()){
                return false;
            }else if(a[i] == ')'){
                if(s.top() == '('){
                    s.pop();
                }else{
                    return false;
                }
            }else if(a[i] == '}'){
                if(s.top() == '{'){
                    s.pop();
                }else{
                    return false;
                }
            }else if(a[i] == ']'){
                if(s.top() == '['){
                    s.pop();
                }else{
                    return false;
                }
            }
        }
    }
}


int evalRPN(vector<string> &tokens){

    stack<int> st;

    for(int i = 0;i < tokens.size();i++){
        if(tokens[i] == '+' || tokens[i] == '-' ||tokens[i] == '*' ||tokens[i] == '/'){
            int v1 = st.top();
            st.pop();
            int v2 = st.top();
            st.pop();

            if(tokens[i] == '+'){
                st.push(v2+v1);
            }else if(tokens[i] == '-'){
                st.push(v2-v1);
            }else if(tokens[i] == '*'){
                st.push(v2*v1);
            }else{
                st.push(v2/v1);
            }
        }else{
            st.push(atoi(tokens[i].c_str()));
        }
    }
    return st.top();
}


ListNode* mergeList(ListNode* a,ListNode* b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    ListNode* newHead = NULL;
    if(a->val < b->val){
        newHead = a;
        newHead->next = mergeList(a->next,b);
    }else{
        newHead = b;
        newHead->next = mergeList(a,b->next);
    }

    return newHead;
}

ListNode* sortList(ListNode* head){
    if(head == NULL) return NULL;

    ListNode* slow = head;
    ListNode* fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    ListNode* n = slow->next;
    slow->next = NULL;
    ListNode* a = sortList(head);
    ListNode* b = sortList(n);

    return mergeList(a,b);
}


bool ifThereisCycle(ListNode* head){
    if(head == NULL) return false;

    ListNode* slow = head, fast = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;

        if(slow == fast) return true;
    }
    return false;
}



ListNode* getIntersectionPoint(ListNode* headA,ListNode* headB){

    unordered_map<ListNode*,int> mp;

    while(headA){
        mp[headA]++;
        headA = headA->next;
    }

    while(headB){
        if(mp[headB] > 0){
            return headB;
        }
        headB = headB->next;
    }
    return NULL;
}


ListNode* getIntersectionPoint(ListNode* headA,ListNode* headB){

    ListNode* ptr1 = headA;
    ListNode* ptr2 = headB;

    while(ptr1 != ptr2){
        if(ptr1 == NULL){
            ptr1 = headB;
        }else{
            ptr1 = ptr1->next;
        }
        if(ptr2 == NULL){
            ptr2 = headA;
        }else{
            ptr2 = ptr2->next;
        }
    }
    return ptr1;
}



ListNode* reverseList(ListNode* head){

    ListNode* curr = head;
    ListNode* prev = NULL;

    while(curr != NULL){
        ListNode* n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }
    return prev;
}



bool isPalindrome(ListNode* head){
    if(head == NULL) return true;

    ListNode* slow = head;
    ListNode* fast = head;


    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    ListNode* reversed = NULL;

    while(slow != NULL){
        ListNode* next = slow->next;
        slow->next = reversed;
        reversed = slow;
        slow = next;
    }

    while(reversed != NULL){
        if(reversed->data != head->data) return false;

        reversed = reversed->next;
        head = head->next;
    }
    return true;
}


ListNode* oddEvenList(ListNode* head){

    ListNode* even =  head->next;
    ListNode* odd = head;
    ListNode* even_start = head->next;

    while(odd->next && even->next){
        odd->next = even->next;
        even->next = odd->next->next;

        odd = odd->next;
        even = even->next;
    }

    odd->next = even_start;
    return head;
}


void deleteNode(ListNode* node){

    node->val = node->next->val;
    ListNode* n = node->next;
    node->next = node->next->next;
    n->next = NULL;
    delete n;
}

ListNode* mergeTwoList(ListNode* a, ListNode* b){

    if(a == NULL) return b;
    if(b == NULL) return a;

    ListNode* newHead = NULL;

    if(a->val < b->val){
        newHead = a;
        newHead->next = mergeTwoList(a->next,b);
    }else{
        newHead = b;
        newHead->next = mergeTwoList(a,b->next);
    }

    return newHead;
}


ListNode* sortList(ListNode* head){

    if(head == NULL ) return head;

    ListNode* slow = head;
    ListNode* fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    ListNode* n = slow->next;
    slow->next = NULL;

    ListNode* a = sortList(head);
    ListNode* b = sortList(n);

    head = mergeTwoList(a,b);
    return head;
}


Class LRUCache{

    private : 
        int capacity;
        map<int,int> mp;
        list<int> ls;

        LRUCache(int capacity){
            this->capacity = capacity;
            mp.clear();
            ls.clear();
        }

        int get(int key){

            if(mp.find(key) == mp.end()) return -1;

            ls.remove(key);
            ls.push_front(key);
            return mp[key];
        }

        void put(int key, int value){

            if(mp.find(key) == mp.end()){
                if(ls.size() == capacity){
                    
                    int key = ls.back();
                    ls.pop_back();
                    mp.erase(key);
                }

                ls.push_front(key);
                mp[key] = value;
            }else{

                ls.remove(key);
                ls.push_front(key);
                mp[key] = value;
            }
        }
}


ListNode* removeKthNode(ListNode* head,int k){

    ListNode* first = head;
    ListNode* second = head;


    while(k--){
        second = second->next;
    }

    if(second == NULL){
        return head->next;
    }

    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }

    first->next = first->next->next;
    return head;

}


class LRUCache{

    private : 
        int capacity;
        map<int,int> mp;
        list<int> ls;

    public :
        LRUCache(int capacity){
            this->capacity = capacity;
            mp.clear();
            ls.clear();
        }


        int get(int key){

            if(mp.find(key) == mp.end()) return -1;

            ls.remove(key);
            ls.push_front(key);
            return mp[key];
        }


        void put(int key,int value){

            if(mp.find(key) == mp.end()){

                if(ls.size() == capacity){
                    int key = ls.back();
                    ls.pop_back();
                    mp.erase(key);
                }

                ls.push_front(key);
                mp[key] = value;
            }else{
                
                ls.remove(key);
                ls.push_front(key);
                mp[key] = value;
            }
        }
}


ListNode* addTwoNumbers(ListNode* l1,ListNode* l2){

    ListNode* dummy = new ListNode();
    ListNode* temp = dummy;

    int carry = 0;

    while(l1 || l2 || carry){

        int sum = 0;

        if(l1){
            sum += l1->val;
            l1 = l1->next;
        }

        if(l2){
            sum += l2->val;
            l2 = l2->next;
        }

        sum += carry;
        carry = sum/10;
        ListNode* newNode = new ListNode(sum%10);

        temp->next = newNode;
        temp = temp->next;
    }

    return dummy->next;
}



#include<bits/stdc++.h>
using namespace std;

template<typename T>
class Queue{

    private :
        T *arr;
        int capacity;
        int nextIndex;
        int size;
        int firstIndex;

    public :

        Queue(){
            arr = new T[5];
            this->capacity = capacity;
            size = 0;
            nextIndex = 0;
            firstInde = -1;
        }

        int getSize(){
            return size;
        }


        bool isEmpty(){
            return size == 0;
        }

        void push(T element){
            
            if(size == capacity){

                T *newArr = new T[2*capacity];
                int j = 0;
                for(int i = firstIndex ;i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }

                for(int i = 0;i < firstIndex; i++){
                    newArr[j] = arr[i];
                    j++;
                }

                nextIndex = capacity;
                firstIndex = 0;
                capacity = 2*capacity;

                delete []arr;
                arr = newArr;
            }

            arr[nextIndex] = element;
            nextIndex = (nextIndex+1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
        }

        void pop(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return ;
            }
            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }

        }

        T front(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return 0;
            }

            return arr[firstIndex];
        }


}



#include<bits/stdc++.h>
using namespace std;

template<typename T>
class Queue{
    private :
        T *arr ;
        int size;
        int capacity;
        int firstIndex;
        int nextIndex;

    public :
        Queue(){
            arr = new T[5];
            size = 0;
            firstIndex = -1;
            nextIndex = 0;
            capacity = 5;
        }

        int getSize(){
            return size;
        }

        bool isEmpty(){
            return size == 0;
        }

        void push(T element){

            if(size == capacity){
                T *newArr = new T[2*capacity];
                int j = 0;
                for(int i = firstIndex;i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }

                for(int i = 0;i < firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }

                firstIndex = 0;
                nextIndex = capacity;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }

            arr[nextIndex] = element;
            nextIndex = (nextIndex+1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
            return ;
        }

        void pop(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return ; 
            }

            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }

        T front(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return 0; 
            }

            return arr[firstIndex];
        }
}

template<typename T>
class Node{
    public :
        Node* next;
        T data;

        Node(T data){
            this->data = data;
            next = NULL;
        }
}

template<typename T>
class Queue{
    private :
        Node<T>* tail;
        Node<T>* head;
        int size = 0;

    public :
        Queue(){
            head = NULL;
            tail = NULL;
            size = 0;
        }


        int getSize(){
            return size;
        }

        bool isEmpty(){
            return size == 0;
        }
        
        void push(T element){
            Node* n = new Node(element);

            if(head == NULL){
                head = n;
                tail = n;
            }else{
                tail->next = n;
                tail = n;
            }
            size++;
        }

        void pop(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return ;
            }

            Node* temp = head;
            head = head->next;
            temp->next = NULL;
            delete temp;
            size--;
        }

        T front(){
            if(isEmpty()){
                cout<<"Queue is empty";
                return 0;
            }

            return head->data;
        }
}

void reverse(queue<int> qt){

    stack<int> st;

    while(!qt.empty()){
        st.push(qt.front());
        qt.pop();
    }

    while(!st.empty()){
        cout<<st.top()<<" ";
        st.pop();
    }
}



class Node{
    public :
        int data;
        Node* next;

        Node(int data){
            this->data = data;
            next = NULL;
        }

}


void print(Node* head){

    Node* temp = head;
    while(temp){
        cout<<temp->data<<" ";
        temp = temp->next;
    }
}


Node* takeInput(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* curr = NULL;
    while(data != -1){
        Node* n = new Node(data);
        if(head == NULL){
            head = n;
            curr = n;
        }else{
            curr->next = n;
            curr = n;
        }
        cin>>data;
    }

    return head;
}


Node* reverseLL(Node* head){

    if(head == NULL){
        return NULL;
    }

    Node* curr = head;
    Node* prev = NULL;

    while(curr != NULL){
        Node* n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }

    return prev;
}


Node* middleLL(Node *head){

    if(head == NULL){
        return NULL;
    }

    Node* slow = head;
    Node* fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    if(fast == NULL){
        return slow->data;
    }
    return slow->next->data;
}


Node* removeKthNode(Node* head,int k){

    if(head == NULL){
        return NULL;
    }

    Node* first = head;
    Node* second = head;

    while(k--){
        second = second->next;
    }

    if(second == NULL){
        return first->next;
    }

    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }

    first->next = first->next->next;
    return head;
}



Node* mergeTwoList(Node* a, Node* b){

    if(a == NULL) return b;
    if(b == NULL) return a;


    Node* finalHead = NULL;
    if(a->val < b->val){
        finalHead = a;
        finalHead->next = mergeTwoList(a->next,b);
    }else{
        finalHead = b;
        finalHead->next = mergeTwoList(a,b->next);
    }

    return finalHead;
}

Node* sortList(Node* head){

    if(head == NULL || head->next == NULL) return head;

    Node* slow = head;
    Node* fast = head->nex;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next;
    }

    Node* n = slow->next // assuming that nodes are even
    slow->next = NULL;

    Node* a = sortList(head);
    Node* b = sortList(n);

    Node* finalHead = mergeTwoList(a,b);
    return finalHead;
}


bool hasCycle(Node* head){

    Node* slow = head;
    Node* fast = head->next;

    bool flag = false;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast) flag = true;
    }
    return flag;

}

Node* getIntersectionPoint(Node* headA,Node* headB){

    Node* a = headA;
    Node* b = headB;
    while(a != b){
        if(a == NULL){
            a = headB;
        }else{
            a = a->next;
        }

        if(b == NULL){
            b = headA;
        }else{
            b = b->next;
        }
    }

    return b;
}

bool isPalindrome(Node* head){

    if(head == NULL || head->next == NULL) return true;

    Node* slow = head->next;
    Node* fast = head->next->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    Node* prev = NULL;
    while(slow != NULL){
        Node* n = slow->next;
        slow->next = prev;
        prev = slow;
        slow = n;
    }

    while(prev != NULL){
        if(prev->data != head->data) return false;

        prev = prev->next;
        head = head->next;
    }

    return true;
}




vector<long long> printFirstNegativeInteger(vector<long long int> A,long long int K){

    int N = A.length();
    vector<long long> ans;
    queue<long long> q;

    for(int i = 0;i < K-1;i++){
       if(A[i] < 0) q.push(A[i]);
    }

    for(int i = K-1; i < N;i++){
        if(A[i] < 0) q.push(A[i]);
        if(!q.empty()){
            ans.push_back(q.front());
            if(q.front() == A[i-k+1]){
                q.pop();
            }
        }else{
            ans.push_back(0);
        }
    }
    return ans;    
}


vector<vector<int>> nearest(vector<vector<int>> grid){

    int n = grid.size();
    int m = grid[0].size();

    vector<vector<int>> ans(n,vector<int>(m,INT_MAX));
    queue<pair<int,int>> q;

    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(grid[i][j] == 1){
                ans[i][j] = 0;
                q.push({i,j});
            }
        }
    }

    while(!q.empty()){

        int i = q.front().first;
        int j = q.front().second;

        if((i+1) < n and ans[i][j]+1 < ans[i+1][j]){
            ans[i+1][j] = ans[i][j]+1;
            q.push({i+1,j});
        }

        if((j+1) < m and ans[i][j]+1 < ans[i][j+1]){
            ans[i][j+1] = ans[i][j]+1;
            q.push({i,j+1});
        }

        if((i-1) >= 0 and ans[i][j]+1 < ans[i-1][j]){
            ans[i-1][j] = ans[i][j]+1;
            q.push({i-1,j});
        }

        if((j-1) >= 0 and ans[i][j]+1 < ans[i][j-1]){
            ans[i][j-1] = ans[i][j]+1;
            q.push({i,j-1});
        }

        q.pop();
    }
    return ans;
}


int rottenOranges(vector<vector<int>> grid){


    int n = grid.size();
    int m = grid[0].size();

    queue<pair<int,int>> q;
    int count = 0;

    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(grid[i][j] == 2){
                q.push({i,j});
            }
        }
    }
    q.push({-1,-1});

    while(!q.empty()){
        int i = q.front().first;
        int j = q.front().second;

        if(i == -1 and j == -1 and q.size() == 1){
            q.pop();
            break;
        }else if(i == -1 and j == -1 and q.size() > 1){
            q.pop();
            count++;
            q.push({-1,-1});
        }else{
            if( (i+1) < n and grid[i+1][j] == 1){
                grid[i+1][j] = 2;
                q.push({i+1,j});
            }
            if((j+1) < m and grid[i][j+1] == 1){
                grid[i][j+1] = 2;
                q.push({i,j+1});
            }
            if((i-1) >= 0 and grid[i-1][j] == 1){
                grid[i-1][j] = 2;
                q.push({i-1,j});
            }
            if((j-1) >= 0 and grid[i][j-1] == 1){
                grid[i][j-1] = 2;
                q.push({i,j-1});
            }
            q.pop();
        }
    }

    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(grid[i][j] == 1){
                return -1;
            }
        }
    }
    return count;

}


ListNode* oddEvenList(ListNode* head){

    if(!head || !head->next || !head->next->next) return head;


    ListNode* odd = head;
    ListNode* even = head->next;
    ListNode* even_start = head->next;

    while(odd->next && even->next){

        odd->next = even->next;
        even->next = odd->next->next;

        odd = odd->next;
        even = even->next;
    }

    odd->next = even_start;
    return head;
}


class LRUCache{

    public :
        int capacity;
        map<int,int> mp;
        list<int> ls;

        LRUCache(int cp){
            capacity = cp
            ls.clear();
            mp.clear();
        }

        int get(int key){

            if(mp.find(key) == mp.end()) return -1;
            ls.remove(key);
            ls.push_front(key);
            return mp[key];
        }

        int put(int key,int value){

            if(mp.find(key) == mp.end()){
                if(ls.size() == capacity){

                    int last = ls.back();
                    ls.remove(last);
                    mp.erase(last);
                }
                ls.push_front(key);
                mp[key] = value;
            }else{
                ls.remove(key);
                ls.push_front(key);
                mp[key] = value;
            }
        }
}

ListNode* addTwoNumber(ListNode* l1,ListNode* l2){

    ListNode* dummy = new ListNode();
    ListNode* temp = dummy;

    int carry = 0;
    while(l1 || l2 || carry){

        int sum = 0;
        if(l1){
            sum += l1->val;
            l1 = l1->next;
        }

        if(l2){
            sum += l2->val;
            l2 = l2->next;
        }

        sum += carry;
        carry = sum/10;
        ListNode* newNode = new ListNode(sum%10);
        temp->next = newNode;
        temp = temp->next;
    }

    return dummy->next;
}

Node* connect(Node* root){

    if(!root) return NULL;
    queue<Node*> q;

    q.push(root);
    while(!q.empty()){

        int l = q.size();
        for(int i = 0 ;i < l;i++){

            Node* f = q.front();
            q.pop();
            if(i == l-1){
                f->next = NULL;
            }else{
                f->next = q.front();
            }
            if(f->left) q.push(f->left);
            if(f->right) q.push(f->right);
        }
    }
    return root;
}


Node* copyRandomList(Node* head){

    if(!head) return NULL;

    map<Node*,Node*> mp;

    Node* original = head;

    while(original){
        ListNode* newNode = new ListNode(original->val);
        mp[original] = newNode;
        original = original->next;
    }

    original = head;
    while(original){
        mp[original]->next = mp[original->next];
        mp[original]->random = mp[original->random];
        original = original->next;
    }

    return mp[head];
}


int rottenOranges(vector<vector<int>> grid){

    int n = grid.size();
    int m = grid[0].size();

    queue<pair<int,int>> q;

    for(int i = 0i < n;i++){
        for(int j = 0;j < m;j++){
            if(grid[i][j] == 2){
                q.push({i,j});
            }
        }
    }

    q.push({-1,-1});
    int count = 0;

    while(!q.empty()){
        int i = q.front().first;
        int j = q.front().second;

        if(i == -1 and j == -1 and q.size() == 1){
            q.pop();
            break;
        }else if(i == -1 and j == -1 and q.size() > 1){
            q.pop();
            count++;
            q.push({-1,-1});
        }else{
            if((i-1) >= 0 and grid[i-1][j] == 1){
                grid[i-1][j] = 2;
                q.push({i-1,j});
            }

            if((i+1) < n and grid[i+1][j] == 1){
                grid[i+1][j] = 2;
                q.push({i-1,j});
            }

            if((j-1) and grid[i][j-1] == 1){
                grid[i][j-1] = 2;
                q.push({i,j-1});
            }

            if((j+1) and grid[i][j+1] == 1){
                grid[i][j+1] = 2;
                q.push({i,j+1});
            }
            q.pop();
        }
    }

    for(int i = 0;i < n;i++){
        for(int j = 0;j < m;j++){
            if(grid[i][j] == 1){
                return -1;
            }
        }
    }
    return count;
}


vector<vector<int>> nearest(vector<vector<int>> grid){


    int n = grid.size();
    int m = grid[0].size();

    vector<vector<int>> ans(n,vector<int>(m,INT_MAX));
    queue<pair<int,int>> q;

    for(int i = 0;i <n;i++){
        for(int j = 0;j < m;j++){
            if(grid[i][j] == 1){
                grid[i][j] = 0;
                q.push({i,j});
            }
        }
    }

    while(!q.empty()){
        int i = q.front().first;
        int j = q.front().second;

        if((i+1) < n and ans[i][j]+1 < ans[i+1][j]){
            ans[i+1][j] = ans[i][j]+1;
            q.push({i+1,j});
        }       
        if((j+1) < m and ans[i][j]+1 < ans[i][j+1]){
            ans[i][j+1] = ans[i][j]+1;
            q.push({i,j+1});
        }       
        if((i-1) >= 0 and ans[i][j]+1 < ans[i-1][j]){
            ans[i-1][j] = ans[i][j]+1;
            q.push({i-1,j});
        }       
        if((j-1) >= 0 and ans[i][j]+1 < ans[i][j-1]){
            ans[i][j-1] = ans[i][j]+1;
            q.push({i,j-1});
        }
        q.pop();
    }


    return ans;
}


vector<long long> firstNegative(long long int A[],int N,int K){

    vector<long long> ans;

    queue<long long> q;
    for(int i = 0;i < k-1;i++){
        if(A[i] < 0){
            q.push(A[i]);
        }
    }

    for(int i = K-1;i < N;i++){
        if(A[i] < 0) q.push(A[i]);
        if(!q.empty()){
            ans.push_back(q.front());
            if(q.front() == A[i-K+1]){
                q.pop();
            }
        }else{
            ans.push_back(0);
        }
    }
    return ans;
}


vector<long long> nearest(long long int A[],int N,int K){

    vector<long long> ans;
    queue<int> q;

    for(int i = 0;i < K-1;i++){
        if(A[i] < 0) q.push(A[i]);
    }

    for(int i = K-1;i < N;i++){
        if(A[i] < 0) q.push(A[i]);
        if(!q.empty()){
            ans.push_back(q.front());
            if(q.front() == A[i-K+1]){
                q.pop();
            }
        }else{
            q.push_back(0);
        }
    }

    return ans;
}



bool areAnagram(Node* r1,Node* r2){

    queue<Node*> q1,q2;
    map<int,int> mp;

    q1.push(r1);
    q2.push(r2);

    while(q1.size() and q2.size()){

        int s= q1.size();

        for(int i = 0;i < s;i++){
            Node* f = q.front();
            q.pop();
            mp[f->data]++;
            if(f->left) q.push(f->left);
            if(f->right) q.push(f->right);
        }

        s = q2.size();
        for(int i = 0;i < s;i++){
            Node* f = q2.front();
            q2.pop();
            mp[f->data]--;
            if(f->left) q2.push(f->left);
            if(f->right) q2.push(f->right);
        }
    }

    for(auto i : mp){
        if(i.second != 0) return 0;
    }

    return q1.size() == 0 and q2.size() == 0;
}


int minValue(string s, int k){

    map<char,int> mp;
    for(int i= 0;i < s.length();i++){
        mp[s[i]]++;
    }

    priority_queue<int> pq;
    for(auto i : mp){
        pq.push(i.second);
    }

    while(k){
        int x = pq.top();
        pq.pop();
        x--;
        pq.push(x);
        k--;
    }

    int sum = 0;
    while(!pq.empty()){
        int d = pq.top();
        pq.pop();

        sum += (d*d);
    }
    return sum;
}

string firstNonRepeating(string s){

    int flag[26] = {0};
    string ans;
    deque<char> dq;

    for(int i = 0;i < s.length();i++){
        flag[s[i]-'a']++;
        deque.push_back(s[i]);

        while(!dq.empty() and flag[dq.front()-'a'] != 1){
            dq.pop_front();
        }

        if(dq.empty()){
            ans += "#";
        }else{
            ans += dq.front();
        }
    }
    return ans;
}


class TreeNode{

    public :
        int data;
        vector<TreeNode<T>*> children;

        TreeNode(int data){
            this->data = data;
        }
         
        ~TreeNode(){
            for(int i = 0;i < children.size();i++){
                delete children[i];
            }
        }
}

void print(TreeNode* root){
    if(root == NULL){
        return ;
    }

    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<children[i]->data<<" ";
    }
    cout<<endl;
    for(int i = 0;i < children.size();i++){
        print(children[i]);
    }
}

TreeNode<T>* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    TreeNode<int>* root = new TreeNode<int>(rootData);
    cout<<"Enter no. of child : ";
    int n;
    cin>>n;
    for(int i = 0;i < n;i++){
        TreeNode<int>* child = takeInput();
        root->children.push_back(child);
    }

    return root;

}



TreeNode<int>* takeInputLevelWise(){

    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;

    TreeNode<int>* root = new TreeNode<int>(rootData);
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<"Enter no. of child of "<<f->data;
        int n;
        cin>>n;
        for(int i = 1;i <= n;i++){
            cout<<"Enter "<<i<<"th child of "<<front->data;
            int child ;
            cin>>child;
            TreeNode<int>* childP = new TreeNode<int>(child);
            front->children.push_back(childP);
            q.push(childP);
        }
    }

    return root;
}


int countNodes(TreeNode<int>* root){

    if(root == NULL){
        return -1;
    }

    int ans = 1;
    for(int i = 0;i < root->children.size();i++){
        ans += countNodes(root->children[i]);
    }
    return ans;
}


void printLevelWise(TreeNode<int>* root){
    if(root == NULL) return ;

    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < root->children.size();i++){
            cout<<front->children[i]->data<<" ";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

class TreeNode{

    public :
        int data;
        vector<TreeNode*> children;

        TreeNode(int data){
            this->data = data;
        }

        ~TreeNode(){
            for(int i = 0;i < children.size();i++){
                delete children[i];
            }
        }
}


void printRecursive(TreeNode* root){


    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<" ";
    }
    cout<<endl;
    for(int i = 0;i < root->children.size();i++){
        printRecursive(root->children[i]);
    }
}


TreeNode* takeInput(){
    int rootData;
    cout<<"Enter data : ";
    cin>>rootData;

    TreeNode* root = new TreeNode(rootData);
    cout<<"Enter children size : ";
    int n;
    cin>>n;
    for(int i = 0;i < n;i++){
        TreeNode* child = takeInput();
        root->children.push_back(child);
    }

    return root;
}

TreeNode* takeInput(){
    int rootData;
    cout<<rootData;

    TreeNode* root = new TreeNode(rootData);
    queue<TreeNode*> q;

    q.push(root);

    while(!q.empty()){
        TreeNode* f = q.front();
        q.pop();
        cout<<"Enter no. of children of "<<f->data;
        int n;
        cin>>n;
        int childData;
        for(int i = 0;i < n;i++){
            cout<<"Enter "<<i<<"th child : ";
            cin>>childData;
            TreeNode* child = new TreeNode(childData);
            root->children.push_back(child);
            q.push(child);
        }
    }

    return root;
}


int countNodes(TreeNode* root){
    if(root == NULL){
        return 0;
    }

    int ans = 1;
    for(int i = 0;i < root->children.size();i++){
        ans += countNodes(root->children[i]);
    }

    return ans;
}

void printLevelWise(TreeNode* root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode* f = q.front();
        q.pop();

        cout<<f->data<<" : ";
        for(int i = 0;i < f->children.size();i++){
            cout<<f->children[i]->data<<" ";
            q.push(f->children[i]);
        }
        cout<<endl;
        
    }
    return ;
}


int height(TreeNode* root){

    if(root == NULL) return 0;

    int mx = 0;
    for(int i = 0;i < root->children.size();i++){
        mx = max(mx,height(root->children[i]));
    }
    return mx+1;
}

void printAtLevelK(TreeNode* root , int k){

    if(root == NULL) return ;

    if(k == 0){
        cout<<root->data<<" ";
        return; 
    }

    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k--);
    }
}


int countLeafNode(TreeNode* root){

    if(root == NULL){
        return -1;
    }

    if(root->children.size() == 0){
        return 1;
    }
    int ans = 0;

    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNode(root->children[i]);
    }

    return ans;

}

void preOrder(TreeNode* root){
    if(root == NULL) return ;

    cout<<root->data<<endl;
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }

}

void postOrder(TreeNode* root){
    if(root == NULL) return ;

    for(int i = 0;i < root->children.size();i++){
        postOrder(root->children[i]);
    }

    cout<<roo->data;
}

void deleteTree(TreeNode* root){
    if(root == NULL) return;

    for(int i = 0;i < root->children.size();i++){
        delete root->children[i];

    }
    delete root;
}

Node* connect(Node* root){
    if(!root) return NULL;

    queue<Node*> q;
    q.push(root);
    while(!q.empty()){
        int l = q.size();
        for(int i = 0;i < l;i++ ){
            Node* f = q.front();
            if(i == l-1) f->next = NULL
            else f->next = q.front();

            if(f->left) q.push(f->left);
            if(f->right) q.push(f->right);
        }
    }

    return root;
}


Node* copyRandomList(Node* head){

    if(head == NULL) return NULL;

    map<Node*,Node*> mp;
    Node* original = head;
    while(original != NULL){
        Node* copy = new Node(head->val);
        mp[original] = copy
        original = original->next;
    }

    original = head;

    while(original != head){
        mp[original]->next = mp[original->next];
        mp[original]->random = mp[original->random];
        original = original->next;
    }

    return mp[head];
}


ListNode* mergeKLists(vector<ListNode*> lists){

    if(lists.size() == 0){
        return NULL;
    }

    vector<pair<int,ListNode*>> arr;
    for(int i = 0;i < lists.size();i++){

        ListNode* curr_list = lists[i];

        while(curr_list){
            arr.push_back({curr_list->val,curr_list});
            curr_list = curr_list->next;
        }
    }

    for(int i = 0;i < arr.size();i++){
        arr[i].second->next = arr[i+1].second;
    }

    arr[arr.size()-1].second->next = NULL;
    return arr[0].second;
}


ListNode* swapNode(ListNode* head){

    if(head == NULL || head->next == NULL) return NULL;

    ListNode* temp = head->next;
    head->next = swapNode(head->next->next);

    temp->next = head;
    return temp;
}


ListNode* findRightMost(ListNode* root){
    if(root->right == NULL) return root;
    return findRightMost(root->right);
}

ListNode* treeToLL(ListNode* root){
    if(root == NULL ) return NULL;

    ListNode* nextRight;
    ListNode* rightMost;

    while(root){
        if(root->left){

            rightMost = findRightMost(root->left);
            nextRight = root->right;
            root->right = root->left;
            rightMost->right = nextRight;
        }

        root = root->right;
    }

    return root;
}

ListNode* returnCycleNode(ListNode* head){

    if(head == NULL) return NULL;

    ListNode* fast = head->next;
    ListNode* slow = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next;
    }

    if(!fast && !fast->next) return NULL;

    while(head != slow){
        head = head->next;
        slow = slow->next;
    }

    return head;
}



void reverseList(ListNode* s,ListNode* e){


    ListNode* p = NULL, *c = s;
    while(p != e){
        ListNode* n = c->next;
        c->next = p;
        p = c;
        c = n;
    }
}


ListNode* reverseKGroup(ListNode* head, int k){

    if(head == NULL || head->next == NULL) return NULL;

    ListNode* s = head, *e = head;
    int inc = k-1;
    while(inc--){
        e = e->next;
        if(e == NULL) return head;
    }

    ListNode* nextNode = reverseKGroup(e->next,k);
    reverseList(s,e);
    s->next = nextNode;
    return e;
    
}



#include<bits/stdc++.h>
using namespace std;

class BTNode{

    public :
        int data;
        BTNode<T>* left;
        BTNode<T>* right;

        BTNode(int data){
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
}


void printTreeRecursive(BTNode<int>* root){

    if(root == NULL){
        return ;
    }

    cout<<root->data<<" : ";
    if(root->left){
        cout<<root->left->data<<", ";
    }
    if(root->right){
        cout<<root->right->data<<" ";
    }

    cout<<endl;
    printTreeRecursive(root->left);
    printTreeRecursive(root->right);
}


void printTreeLevelWise(BTNode<int>* root){

    if(root == NULL) return ;

    queue<BTNode<int>*> q;
    q.push(root);

    while(!q.empty()){

        BTNode<int> *f = q.front();
        q.pop();

        cout<<f->data<<" : ";
        if(f->left){
            cout<<f->left->data<<" ,";
            q.push(f->left);
        }
        if(f->right){
            cout<<f->right->data<<" ";
            q.push(f->right);
        }

    }
}


BTNode<int>* takeInputRecursive(){

    int data;
    cout<<"Enter data : ";
    cin>>data;
    if(data != -1){
        BTNode<int> *root = new BTNode<int>(data);
    }else{
        return NULL;
    }

    root->left = takeInputRecursive();
    root->right = takeInputRecursive();

    return root;
}

BTNode<int>* takeInputLevelWise(){

    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }

    BTNode<int>* root = new BTNode<int>(rootData);
    queue<BTNode<int>*> q;
    q.push(root);

    while(!q.empty()){

        BTNode<int> *f = q.front();
        q.pop();

        int leftData;
        cout<<"Enter left data : ";
        cin>>leftData;

        if(leftData != -1){
            BTNode<int>* left = new BTNode<int>(leftData);
            f->left = left;
            q.push(left);
        }

        int rightData;
        cout<<"Enter right data : ";
        cin>>rightData;

        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            f->right = right;
            q.push(right);
        }
    }
    cout<<endl;
    return root;
}


bool searchNode(BTNode<int>* root,int key){
    if(root == NULL){
        return false;
    }

    if(root->data == key){
        return true;
    }

    return searchNode(root->left,key) || searchNode(root->right,key);
}


int minValue(BTNode<int>* root){

    if(root == NULL){
        return INT_MAX;
    }

    return min(root->data,min(minValue(root->left),minValue(root->right));
}


int countLeafNode(BTNode<int>* root){

    if(root == NULL){
        return -1;
    }

    if(root->left == NULL and root->right == NULL){
        return 1;
    }

    return countLeafNode(root->left) + countLeafNode(root->right);
}


ListNode* swapPairs(ListNode* head){
    if(head == NULL || head->next == NULL) return head;


    ListNode* temp;
    temp = head->next;
    head->next = swapPairs(head->next->next);
    temp->next = head;
    
    return temp;
}


TreeNode* getMostRight(TreeNode* root){

    if(root->right == NULL) return root;
    getMostRight(root->right);
}

void flatten(TreeNode* root){

    if(root == NULL) return root;

    TreeNode* rightMost;
    TreeNode* nextRight;
    

    while(root){
        if(root->left){
            rightMost = getMostRight(root->left);

            ListNode* nextRight = root->right;
            root->right = root->left;
            root->left = NULL;
            rightMost->right = nextRight;        
        }

        root = root->right;
    }
    
}


TreeNode* getMostRight(TreeNode* root){
    if(root->right == NULL) return root;
    getMostRight(root->right);
}

void flatten(TreeNode* root){

    if(root == NULL ) return ;

    TreeNode* rightMost ;
    TreeNode* nextRight;

    while(root){

        if(root->right){
            rightMost = getRightMost(root->left);
            nextRight = root->right;

            root->right = root->left;
            root->left = NULL;
            rightMost->right = nextRight;
        }

        root = root->right;
    }


}


ListNode* swapPairs(ListNode* head){

    if(head == NULL || head->next == NULL) return head;

    ListNode* temp = root->next;
    root->next = swapPairs(root->next->next);
    temp->next = head;
    

    return temp;
}


TreeNode* buildTreeHelper(vector<TreeNode*> inorder,vector<TreeNode*> postorder,int inS,int inE,int postS,int postE){

    if(root == NULL){
        return NULL;
    }

    int rootData = postorder[postS];
    int rootIndex = -1;
    for(int i = 0;i < inorder.size();i++){
        if(rootData == inorder[i]){
            rootIndex = i;
        }
    }

    int leftInS = inS;
    int leftInE = rootIndex -1;
    int rightInS = rootIndex+1;
    int rightInE = inE;

    int leftPostS = postS;
    int leftPostE = leftPostS + leftInE - leftInS;
    int rightPostS = leftPostE+1;
    int rightPostE = postE-1;

    TreeNode* root = new TreeNode(rootData);
    root->left = buildTreeHelper(inorder,postorder,leftInS,leftInE,leftPostS,leftPostE);
    root->right = buildTreeHelper(inorder,postorder,rightInS,rightInE,rightPosS,rightPostE);

    return root;
}

TreeNode* buildTree(vector<TreeNode*> inorder, vector<TreeNode*> postorder){

    int n = inorder.size();
    TreeNode* root = buildTreeHelper(inorder,postorder,0,n-1,0,n-1);

    return root;
}

bool helper(TreeNode* left,TreeNode* right){

    if(left == NULL && right != NULL) return false;
    if(left != NULL && right == NULL) return false;
    if(left == NULL && right == NULL) return true;

    if(left->val != right->val) return false;

    return helper(left->left,right->right) && helper(left->right,right->left);
}

bool isSymmetric(TreeNode* root){
    if(root == NULL) return true;

    return helper(root->left,root->right);
}


bool getPath(TreeNode* root,int val,vector<int> &ans){

    if(root == NULL) return false;

    ans.push_back(root->val);
    if(root->val == val){
        return true;
    }

    bool left = getPath(root->left,val,ans);
    bool right = getPath(root->right,val,ans);

    if(left || right){
        return true;
    }

    ans.pop_back();
    return false;
}

int height(TreeNode* root){
    if(root == NULL) return 0;

    return max(height(root->left),height(root->right)) + 1;
}

int diameterOfBT(TreeNode* root){
    if(root == NULL) return 0;

    int option1 = height(root->left) + height(root->right);
    int option2 = diameterOfBT(root->left);
    int option3 = diameterOfBT(root->right);

    return max(option1,max(option2,option3));
}

#include<bits/stdc++.h>
using namespace std;



template<typename T>
class BSTnode{

    public :
        BSTnode<T>* left;
        BSTnode<T>* right;

        int data ;

        BSTnode(int data){
            this->data = data;
            left = NULL;
            right = NULL;
        }

        ~BSTnode(){
            delete left;
            delete right;
        }
}

void printTree(BSTnode<int>* root){
    if(root == NULL) return ;

    cout<<root->data<<" : ";

    if(root->left){
        cout<<root->left->data<<",";
    }
    if(root->right){
        cout<<root->right->data<<" ";
    }

    cout<<endl;
    print(root->left);
    print(root->right);
}

bool hasData(BSTnode<int>* root , int data){
    if(root == NULL) return false;

    if(root->data == data) return true;

    if(root->data > data){
        return hasData(root->left,data);
    }
    if(root->data < data){
        return hasData(root->right,data);
    }
}

BSTnode<int>* insert(BSTnode<int>* root,int data){

    if(root == NULL){
        BSTnode<int>* root = new BSTnode<int>(data);
        return root;
    }

    if(root->data < data){
        root->right = insert(root->right,data);
    }else{
        root->left = insert(root->left,data);
    }

    return root;
}


BSTnode<int>* deleteData(BSTnode<int>* root,int data){
    if(root == NULL){
        return NULL;
    }else if(root->data < data){
        root->right = deleteData(root->right,data);
    }else if(root->data > data){
        root->left = deleteData(root->left,data);
    }else{
        if(root->left == NULL and root->right == NULL){
            delete root;
            return NULL;
        }else if(root->right == NULL){
            BSTnode<int>* temp = root->left;
            root->left = NULL;
            delete root;
            return temp;
        }else if(root->left == NULL){
            BSTnode<int>* temp = root->right;
            root->right = NULL;
            delete root;
            return temp;
        }else{
            BSTnode<int> *minNode = root->right;
            while(minNode->left != NULL){
                minNode = minNode->left;
            }
            int rightMin = minNode->data;
            root->data = rightMin;
            root->right = delete(root->right,rightMin);
        }
    }

    return root;
}



#include<bits/stdc++.h>
using namespace std;


int main(){
    cout<<"hello world";
    return 0;
}


void reverseArray(int a[],int n){

    for(int i = n-1;i >= 0;i--){
        cout<<a[i]<<" ";
    }
}

reverseArray(a,6);


pair<long long,long long> maxAndminFind(long long a[],int n){

    int max = INT_MIN;
    int min = INT_MAX;

    for(int i = 0; i < n;i++){

        if(a[i] < min){
            min = a[i];
        }
        if(a[i] > max){
            max = a[i];
        }
    }

    pair<long long , long long> p;
    p.first = min;
    p.second = max;

    return p;
}


pair<long long ,long long> findKthMinAndMax(int a[],int l,int r,int k){

    sort(a,a+r+1);
    return a[k-1];
}


void sortColors(int a[],int n){

    int low = 0,mid = 0, high = n-1;

    while(mid <= high){

        if(a[mid] == 0){
            swap(a[low++],a[mid++]);
        }else if(a[mid] == 2){
            swap(a[mid],a[high--]);
        }else{
            mid++;
        }
    }
}

void segregateElement(int nums[],int n){


    vector<int> hel;

    for(int i = 0;i < n;i++){
        if(nums[i] > 0){
            hel.push_back(nums[i]);
        }
    }
    for(int i = 0;i < n;i++){
        if(nums[i] < 0){
            hel.push_back(nums[i]);
        }
    }

    for(int i = 0;i < hel.size();i++){
        nums[i] = hel[i];
    }

}

int doUnion(int a[],int n , int b[],int m){

    set<int> st;
    int count = 0;

    for(int i = 0;i < n;i++){
        if(st.find(a[i]) == st.end()){
            count++;
            st.insert(a[i]);
        }
    }

    for(int i = 0;i < m;i++){
        if(st.find(b[i]) == st.end()){
            count++;
            st.insert(b[i]);
        }
    }

    return count;
}

void rotateByOne(int a[],int n){

    int last = a[n-1];

    for(int i = n-1;i >= 0;i--){

        if(i != 0){
            a[i] = a[i-1];
        }else{
            a[i] = last;
        }
    }
}

long maxSubArraySum(int a[],int n){

    int max_current = a[0];
    int max_global = a[0];

    for(int i = 1;i < n;i++){
        max_current = max(a[i],max_current+ a[i]);
        if(max_current > max_global){
            max_global = max_current ;
        }
    }

    return max_global;
}


int getMinDiff(int a[],int n,int k){

    sort(a,a+n);

    int lt = 0;
    int st = 0;

    int ans = a[n-1] - a[0];
    int large = a[n-1]-k;
    int small = a[0]+k;

    for(int i = 0;i < n-1;i++){

        lt = max(large,a[i]+k);
        st = min(small,a[i+1]-k);

        if(st < 0){
            continue;
        }

        ans = min(ans,lt-st);
    }

    return ans;
}


int minJump(int a[], int n){

    if(n == 1){
        return 0;
    }

    if(a[0] == 0){
        return -1;
    }
    
    int jumps = 1;
    int steps = a[0];
    int maxReach = a[0];

    for(int i = 1;i < n;i++){


        if(i == n-1){
            return jumps;
        }       

        maxReach = max(maxReach, arr[i] + i);
        steps--;
        if(steps == 0){
            jumps++;

            if(i >= maxReach){
                return -1;
            }
            steps = maxReach - i;
            
        }
    }

}


int minJumps(int a[],int n){

    if(n == 1){
        return 0;
    }
    if(a[0] == 0){
        return -1;
    }

    int jumps = 1;
    int steps = a[0];
    int maxReach = a[0];

    for(int i = 1;i < n;i++){

        if(i == n-1){
            return jumps;
        }

        maxReach = max(maxReach, a[i]+i);

        steps--;
        if(steps == 0){
            jumps++;

            if(i >= maxReach){
                return -1;
            }

            steps = maxReach - i;
        }
    }

    return -1;
}


int evenOdd(int n){

    if(n&1 == 1){
        cout<<"odd";
    }else{
        cout<<"even"
    }
}


int AtoB(int a, int b){

    int res = 1;

    while(a && b){
        if(a&1 == 1){
            if(b&1 == 1){
                res = res*2;
            }else{
                return 0;
            }
        }

        a = a >> 1;
        b = b >> 1;
    }

    return res;
}

int leastGreater(int n){

    cout<<(n | n+1)<<endl;
}

void checkIthBit(int n,int i){

    if(n&(1<<i-1)){
        cout<<"yes";
    }else{
        cout<<"no";
    }
}

int checkPowerOfFour(int n){

    if(n < 0){
        return false;
    }

    if(__builtin_popcount(n) == 1){
        int k = floor(log2(n)+1);
        if(k&1 == 1) return true;
    }
    return false;
}

int AtoB(int a,int b){

    int res = 0;

    while(a && b){
        if(a&1 == 1){
            if(b&1 == 1){
                res = res*2;
            }else{
                return 0;
            }
        }

        a = a >> 1;
        b = b >> 1;
    }

    return res;
}

int leastGreater(int n){

    cout<<(n | n+1)
}

bool checkIthBit(int n){

    cout<<(n&(1<<(i-1)));
}

void determinigNum(int n){

    int a[] = {1,2,3,4,5,4,3,5};

    int ans = 0;
    for(int i : a){
        ans = ans^i;
    }

    int bits = floor(log2(ans)+1);


    int y1=0,y2=0;
    for(int i : a){
        if(i&(1<<(bits-1))){
            y1 ^= i;
        }else{
            y2 ^= i;
        }
    }

    if(y1 < y2) cout<<y1<<" "<<y2;
    else cout<<y2<<" "<<y1;
}


#include<bits/stdc++.h>
using namespace std;


void payingUp(int n,int m,int a[]){

    int total = 1<<n;
    bool flag = false;

    for(int k =1 ;k < total;k++){
        long long sum = 0;
        for(int i = 0;i < n;i++){
            if(k&(1<<i)){
                sum += a[i];
            }
        }

        if(sum == m){
            flag = true;
            break;
        }
    }

    if(flag){
        cout<<"yes";
    }else{
        cout<<"no";
    }
}

void printSubsetOfK(int n,int k,int a[]){

    int total = 1<<n;

    for(int m = 1;m < total;m++){
        if(__builtin_popcount(m) == k){
            for(int i = 0;i < n;i++){
                if(m&(1<<i)){
                    cout<<a[i]<<" ";
                }
            }
            cout<<endl;
        }
    }
}


int russianPeasant(int x,int y){

    int res = 0;
    while(y > 0){

        if(y&1){
            res += x;
        }

        y = y >> 1;
        x = x << 1;
    }

    return res;
}


string addBitsString(string str1, string str2){


    int i = str1.size() -1;
    int j = str2.size() -1;
    int carry = 0;
    string ans = "";

    while(i >= 0 || j >= 0 || carry){
        carry += (i >= 0) ? (str1[i--] - '0') : 0 ;
        carry += (j >= 0) ? (str1[j--] - '0') : 0 ;
        ans = char('0' + (carry%2)) + ans;

        carry = carry/2;
    }

    return ans;
}

void binaryRepresentation(int n){

    if(n > 1){
        binaryRepresentation(n/2);
    }

    cout<<n%2;
}


void NoOdd(int a[],int n){

    int res = 0;
    for(int i = 0;i < n;i++){
        res ^= a[i];
    }

    cout<<res;
}

void fun(int n){

    cout<<(n & (n-1));
}

int myXOR(int x,int y){

    return (x|y) & (~x|~y);
}

int leftRotate(int n,int d){

    if(n < 0){
        return 0;
    }

    return (n << d) | (n >> (32 - d));
}

int rightRotate(int n,int d){
    if(n < 0){  
        return 0;
    }

    return (n >> d) | (n << (32 -d));
}

int russianPeasant(int x, int y){

    int res = 0;
    while(y > 0){

        if(y&1){
            res += x;
        }

        y = y >> 1;
        x = x << 1;
    }

    return res;
}

void swap(int &x,int &y){

    x = x^y;
    y = x^y;
    x = x^y;

    cout<<x<<" "<<y;
}


void findMajority(int a[],int n){

    int total = sizeof(int)*8;

    int number = 0;
    for(int i = 0; i < len ;i++){
        int count = 0;
        for(int j = 0;j < n;j++){
            if(a[j]&(1 << i)){
                count++;
            }
        }

        if(count > (n/2)){
            number += (1 << i);
        }
    }

    int count = 0;

    for(int i = 0;i < n;i++){
        if(a[i] == number){
            count++;
        }
    }

    if(count > (n/2)){
        cout<<"majority element : "<<number<<endl;
    }else{
        cout<<"There's no majority element";
    }


}




void findMajority(int a[],int n){

    int total = sizeof(int)*8;
    int number = 0;

    for(int i = 0;i < total;i++){
        int count = 0;

        for(int j = 0;j < n;j++){
            if(a[j]&(1 << i)){
                count++;
            }
        }

        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;

    for(int i = 0;i <n;i++){
        if(a[i] == number){
            count++;
        }
    }
    if(count > (n/2)){
        cout<<"majority element is : "<<number<<endl;
    }else{
        cout<<"there's no majority element in the array "<<endl;
    }
}

void swapEvenWithOdd(int n){

    unsigned int even_bits = n&(0xaaaaaaaa)>>1;
    unsigned int odd_bits = n&(0x55555555)<<1;

    return even_bits | odd_bits;
}

int swapBits(int n, int p1,int p2,int m){

    int hello = ((n>>p1)^(n>>p2)) & ((1U<<n)-1);

    return x^((hello<<p1) | (hello<<p2));
}



int fibonacci(int n){

    if(n == 0){
        return 0;
    }
    if(n == 1){
        return 1;
    }

    int result1 = fibonacci(n-1);
    int result2 = fibonacci(n-2);

    return result1 + result2;
}

int factorial(int n){

    if(n == 0){
        return 0;
    }

    int small = factorial(n-1);
    return small*n;
}

int power(int x,int n){

    if(n == 0){
        return 1;
    }

    if(n < 0){
        return -1;
    }

    int small = power(x,n-1);
    return small*x;
}

int print(int n){
    if(n <= 1){
        return 1;
    }

    cout<<print(n-1)<<" ";
    return n;
}

int count(int n){

    if(n/10 == 0){
        return 1;
    }

    int small = count(n/10);
    return small+1;
}

int sumOfDigits(int n){

    if(n/10 == 0){
        return 1;
    }

    int small = sumOfDigits(n/10);
    int lastDigit = n%10;
    return lastDigit + small;
}


int countZeros(int n){

    if(n == 0){
        return 0;
    }

    int small = countZeroes(n/10);
    int lastDigit = n%10;
    if(lastDigit == 0){
        return small + 1;
    }else{
        return small;
    }
}


if(a&1 == 1){
    cout<<"odd";
}else{
    cout<<"even"
}

int AtoBConv(int a,int b){

    int res = 1;
    while(a && b){
        if(a&1 == 1){
            if(b&1 == 1){
                res = res*2;
            }else{
                return 0;
            }
        }

        a = a >> 1;
        b = b >> 1;
    }
}

n | n+1

check(int n,int i){
    int n = 1<<i-1;
    if(n&1 == 1){
        cout<<"set";
    }else{
        cout<<"not set";
    }
}

int countBits(int n){

    int bits = (int)log2(n)+1;
    return bits;


}

func(int n){
    
    int count = 0;
    while(n){
        count++;
        n = n & (n-1);
    }

    return count;
}

func(int n ){
    if(n < 0){
        return false;
    }
    int count = 0;
    while(n){
        count++;
        n = n&(n-1);
    }
    return count == 1;
}

func(int n){

    if(__builtin_popcount(n) == 1){
        int bits = floor(log2(n)+1);
        if(bits&1 == 1){
            return true;
        }else{
            return false;
        }
    }
}

unique(int a[],int n){
    int res = 0;
    for(int i = 0;i < n;i++){
        res = res^a[i];
    }
    return res;
}

missing(int a[],int n){

    // n = 5;
    // size = 4;
    int res = 0;
    for(int i = 1;i <= n;i++){
        res = res^i;
    }

    for(int e : a){
        res = res^e;
    }

    return res;
}

determiningNum(int a[],int n){

    int res = 0;
    for(int e : a){
        res = res^e;
    }

    int bits = floor(log2(n)+1);


    int y1 =0,y2 = 0;
    for(int e : a){
        if(e&(1<<(bits-1))){
            y1 = y1^e;
        }else{
            y2 = y2^e;
        }
    }

    y1 < y2 ? cout<<y1<<" "<<y2 : cout<<y2<<" "<<y1;
}


//10 => 1010;
//5  => 0101;
flipBits(int n){

    int bits = floor(log2(n)+1); //4
    int x = 1<<bits-1;
    x = x|x-1;
    return x^n;


}

printSubset(int a[],int n,int m){

    int total = 1<<n;

    for(int i = 1;i < total ;i++){
        if(__inbuilt_popcount(k) == m){
            for(int j = 0;j < n;j++){
                if(i&(1<<j)){
                    cout<<a[j]<" ";
                }
            }
            cout<<endl;
        }
        
    }
}

// 10 => 1010;
// 5  => 0101;
// 15 => 1111;

func(int n,int x){

    while(a){

        if(a&1){
            x = x|1;
        }

        a = a >> 1;
    }

    return x;
}

func(int x,int y,int l,int r){

    for(;l <= r;l++){
        int z = 1 << l;

        if(y&z){
            x = x|z;
        }
    }

    return x;
}

posOfSetBit(int n){

    if(n&(n-1) == 0) return floor(log2(n)+1);
    else return -1;
}

int russianPeasant(int x,int y){
    
    int res = 0;
    while(x > 0){
        if(x&1){
            res = res+y;
        }

        y = y << 1;
        x = x >> 1;
    }
}

int leftRotate(int n,int x){

    return (n << x) | (n >> (32-x));
}

int rightRotate(int n,int x){

    return (n >> x) | (n << 32-x) ;
}

same(int x,int y){
    if(x^y){
        cout<<"no";
    }else{
        cout<<"yes";
    }
}

XOR(int x,int y){

    return (x | y) & (~x | ~y); 
}

binaryPresent(int n){

    if(n > 1){
        binaryPresent(n/2);
    }

    cout<<n%2;
}

addingBitString(string str1,string str2){

    int carry = 0;

    int i = str1.length()-1;
    int j = str2.length()-1;
    
    string ans = "";

    while(i || j || carry){

        carry += (i >= 0) ? (str1[i--] - '0') : 0;
        carry += (j >= 0) ? (str2[j--] - '0') : 0;
        ans  = char('0' + (carry%2)) + ans;
        carry = carry/2;
    }

    return ans;
}

reverseBits(int n){


    int ans = 0;
    for(itn i = 1;i <= 32;i++){
        if(n&(1<<i)){
            ans = ans | (1<<(32-i));
        }
    }

    return ans;
}

int setKthBit(int n,int i){

    int x = 1<<(i-1);
    return n | x;
}

swapNibbles(int n){

    int right = n&(0x0f)<<4;
    int left = n&(0xf0)>>4;

    return right | left;
    
}

swapBits(int n,int p1,int p2,int k){


    int hello = (n>>p1 ^ n>>p2)&((1U<<k)-1);
    return n^((hello<<p1) | (hello<<p2));
}

swapEvenBitsWithOdd(int n){

    int set1 = (0xaaaaaaaa)&n;
    int set2 = (0x55555555)&n;

    return (set1>>1 | set2<<1);
}

//10 -> 1010;
//5  -> 0101;


majorityElement(int a[],int n){

    int number = 0;
    int total = sizeof(int)*8;

    for(int i = 0;i < total;i++){
        int count = 0;
        for(int j = 0;j < n;j++){
            if(a[j]&(1<<i)){
                count++;
            }
        }

        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;

    for(int i = 0;i < n;i++){
        if(a[i] == number){
            count++;
        }
    }
    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}


countOccurance(int a[],int n,int m){

    if(n < 0){
        return 0;
    }

    if(a[0] == m){
        return countOccurance(a+1,n-1,m) + 1;
    }else{
        return countOccurance(a+1,n-1,m);
    }
    
}


int firstIndex(int a[],int n,int m,int i){

    if(i == n){
        return -1;
    }

    if(a[i] == m){
        return i;
    }

    int small = firstIndex(a,n,m,i+1);
    return small;    
}


bool checkElement(int a[],int n,int m){

    if(n < 0){
        return false;
    }
    if(a[0] == m){
        return true;
    }
    return checkElement(a+1,n-1,m);
}

void printPos(int a[],int n,int m,int i=0){

    if(i == n){
        return ;
    }
    if(a[i] == m){
        cout<<"pos "<<i;
    }
    printPos(a,n,m,i+1);

}

int sumOfArray(int a[],int n){

    if(n < 0){
        return 0;
    }
    int small = sumOfArray(a+1,n-1);
    return small + a[0];
}


int firstIndexElement(int a[],int n,int m,int i){

    if(n == i){
        return -1;
    }

    if(a[i] == m){
        return i;
    }

    return firstIndexElement(a,n,m,i+1);
}   

int countOccurance(int a[],int n,int m){

    if(n < 0){
        return -1;
    }
    if(a[0] == m){
        return countOccurance(a+1,n-1,m) + 1;
    }else{
        return countOccurance(a+1,n-1,m) ;
    }
}


int convertStrToInt(string str,int n){

    if(n == 0){
        return 0;
    }

    int small = convertStrToInt(str,n-1);
    int lastDigit = str[n-1] - '0';
    return small*10+lastDigit;
}

int length(string str){

    if(str[0] == '\0'){
        return 0;
    }

    int small = length(str+1);
    return small + 1;
}

void printSubs(string input,string output){
    if(input.length() == 0){
        cout<<output<<endl;
        return ;
    }

    printSubs(input.substr(1),output+input[0]);
    printSubs(input.substr(1),output);
}

void printPermu(string str,int i=0){

    if(str[i] == '\0'){
        cout<<str<<endl;
        return ;
    }

    for(int j = i;str[j] != '\0' ;j++){
        swap(str[i],str[j]);
        printPermu(str,i+1);
        swap(str[i],str[j]);
    }
}

void printPermu(string str,int i = 0){

    if(str[i] == '\0'){
        cout<<str<<endl;
        return ;
    }

    for(int j = i;str[j] != '\0';j++){
        swap(str[i],str[j]);
        printPermu(str,i+1);
        swap(str[i],str[j]);
    }
}

int copySetBit(int n,int m, int l , int r){

    if(n < 0){
        return -1;
    }

    int ans = 0;

    for(;l <= r;l++){
        int k = 1<<l;
        if(n&k){
            ans = ans | k;
        }
    }
    return ans;

}

int russianPeasant(int x,int y){


    int ans = 0;
    while(y > 0){
        if(y&1){
            ans = ans+x;
        }

        y = y>>1;
        x = x<<1;
    }

    return ans;
}

int leftRotate(int n,int m){

    return n<<m | n>>(32-m);

}
int rightRotate(int n,int m){
    return n>>m | n<<(32-m);
}

bool same(int n,int m){
    if(n^m){
        cout<<"not same";
    }else{
        cout<<"same";
    }
}

int XORWithoutXOR(int n,int m){
    return (n|m) & (~n | ~m);
}

int turnOff(int n){
    return n&(n-1);
}

int numberOccuring(int a[],int n){
    int ans = 0;
    for(int i : a){
        ans = ans^i;
    }
    return ans;
}

int binaryRepresentation(int n){

    if(n > 1){
        binaryRepresentation(n/2);
    }
    cout<<n%2;
}

string addition(string str1,string str2){

    string ans = "";
    int i = str1.length()-1;
    int j = str2.length()-2;

    int carry = 0;
    while(i >= 0 || j >= 0  || carry){

        carry += i >= 0 ? str1[i--] - '0' : 0;
        carry += j >= 0 ? str1[j--] - '0' : 0;

        ans =  char('0' + carry%2) + ans;
        carry = carry/2;
    }

    return ans;
}

int reverseBits(int n){

    if(n <= 0){
        return 0;
    }


    for(int i = 1;i <= 32; i++){
        if(n&(1<<i)){
            ans = ans | (1<<32-i);
        }
    }
    return ans;
}

int swapNibles(int n){

    int set1 = n&0x0f<<4;
    int set2 = n&0xf0>>4;
    return set1|set2;
}

int swapBits(int n,int p1,int p2,int m){

    int hello = (n>>p1 ^ n>>p2)&(1U<<m)-1;
    return n^hello<<p1|hello<<p2; 
}

int swapEvenWithOdd(int n){
    int set1 = 0xaaaaaaaa&n>>1;
    int set2 = 0x55555555&n<<1;
    return set1 | set2;
}

void majorityElement(int a[],int n){

    int total = sizeof(int)*8;

    int count = 0;
    int number = 0;
    for(int i = 0;i < total;i++){
        for(int j = 0;j < n;j++){
            if(a[j]&(1<<i)){
                count++;
            }
        }   
        
        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;
    for(int i = 0;i < n;i++){
        if(a[j] == number){
            count++;
        }
    }

    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}

int changeEvenBits(int n){

    return n&0xaaaaaaaa;
}


void print(int n){

    if(n <= 1){
        return 1;
    }

    cout<<print(n-1)<<" ";
    return n;
}

void removeConsecutive(string str){

    if(str[0] == '\0'){
        return ;
    }

    if(str[0] != str[1]){
        removeConsecutive(str+1);
    }else{
        for(int i = 0;str[i] != '\0';i++){
            str[i] = str[i+1];
        }
        removeConsecutive(str);
    }
    
}

int toh(int n){
    if(n == 0){
        return 0;
    }

    return toh(n-1) + 1 + toh(n-1);
}

int stairCase(int n){
    if(n == 0 || n == 1){
        return 1;
    }
    if(n < 0){
        return 0;
    }

    return stairCase(n-1) + stairCase(n-2) + stairCase(n-3);
}

void printPermu(char str[],int i=0){
    if(str[i] == '\0'){
        return ;
    }

    for(int j = i;str[j] != '\0';j++){
        swap(str[j],str[i]);
        printPermu(str,i+1);
        swap(str[j],str[i]);
    }
}

void printSubs(string input,string output){

    if(input.length() == 0){
        cout<<output<<endl;
        return ;
    }

    printSubs(input.substr(1),ouput+input[0]);
    printSubs(input.substr(1),ouput);
}

int convertStrToInt(char str[],int n){

    if(n == 0){
        return 0;
    }

    int small = convertStrToInt(str+1,n-1);
    int smallDigit = str[n-1] - '0';
    return small*10+lastDigit;
}

int russianPeasant(int x ,int y){

    int res = 0;
    while(x > 0){
        if(x&1){
            res = res+y;
        }

        x = x >> 1;
        y = y << 1;
    }

    return res;
}

int leftRotate(int x,int d){

    return x<<d | x>>(32-d)
    
}

int findMajority(int a[],int n){

    int len = sizeof(int)*8;
    int number = 0;
    for(int i = 0;i < len;i++){

        int count = 0;
        for(int j = 0;j < n;j++){

            if(a[j]&(1<<i)){
                count++;
                
            }
        }

        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;
    for(int i = 0;i < n;i++){
        if(a[j] == number){
            count++;
        }
    }

    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}

int swapBits(int x,int p1,int p2,int d){

    int hello = ((x>>p1) ^ (x>>p2))&((1<<n)-1);
    return x^(hello<<p1 | hello<<p2);
}


int fibonacci(int n){
    if(n == 0){
        return 0;
    }
    if(n == 1){
        return 1;
    }

    int small1 = fibonacci(n-1);
    int small2 = fibonacci(n-2);

    return small1 + small2;
}

int findGCD(int x,int y){

    if(y == 0){
        return 0;
    }

    return findGCD(y,x%y);
}

int factorial(int n){

    if(n == 0){
        return 1;
    }

    int small = factorial(n-1);
    return small*n;
}

int power(int x,int y){

    if(y == 0){
        return 1;
    }

    int small = power(x,y-1);
    return small*x;
}

int print(int n){

    if(n == 0){
        return 0;
    }
    cout<<print(n-1)<<" ";
    return n;
}

int count(int n){

    if(n == 0){
        return 1;
    }

    int small = count(n/10);
    return small+1;
}

int sumOfDigits(int n){
    if(n == 0){
        return 0;
    }

    int small = sumOfDigits(n/10);
    int lastDigit = n%10;
    return lastDigit+small;
}

int multiply(int n,int m){

    if(m == 0){
        return 0;
    }

    int small = multiply(n,m-1);
    return small +n;
}

int countZero(int n){

    if(n == 0){
        return 0;
    }

    int small = countZero(n/10);
    int lastDigit = n%10;
    if(lastDigit == 0){
        return small+1;
    }else{
        return small;
    }
}

double gSum(int n){
    if(n == 0){
        return 0;
    }

    int small = gSum(n-1);
    return small+ 1.0/pow(2,n);
}

bool checkPal(char str[],int s,int e){
    if(s > e){
        return true;
    }

    if(str[s] == str[e]){
        return checkPal(str,s+1,e-1);
    }else{
        return false;
    }
}

bool checkElement(int a[],int n){
    if(n == 0){
        return false;
    }

    if(a[0] == n){
        return true;
    }

    return checkElement(a+1,n-1);
}

bool checkPal(int a[],int s,int e){

    if(s > e){
        return true;
    }
    if(a[s] == a[e]){
        return checkPal(a,s+1,e-1);
    }else{
        return false;
    }

}

bool checkSorted(int a[],int n){

    if(n == 0){
        return true;
    }
    if(a[0] == a[1]){
        return checkSorted(a+1,n-1);
    }else{
        return false;
    }
}

int countOccurance(int a[],int n,int m){

    if(n == 0){
        return 0;
    }
    if(a[0] == m){
        return countOccurance(a+1,n-1,m) +1;
    }else{
        return countOccurance(a+1,n-1,m);
    }
}

int firstIndex(int a[],int n,int m,int i){

    if(n == i){
        return -1;
    }
    if(a[0] == m){
        return i;
    }
    return firstIndex(a,n,m,i+1);
}

int lastIndex(int a[],int n,int m){
    if(n == 0){
        return -1;
    }
    if(a[n-1] == m){
        return n-1;
    }
    return lastIndex(a,n-1,m);
}

void printPos(int a[],int n,int m,int i){

    if(n == i){
        return ;
    }

    if(a[i] == m){
        cout<<i<<" ";
    }

    printPos(a,n,m,i+1);
}

int reverseNumber(int n){

    int reverse = 0;
    int remainder = 0;

    do{
        remainder = n%10;
        reverse = reverse*10+remainder;
        n = n/10;
    }while(n > 0)

    return reverse;
}

int sumOfArray(int a[],int n){
    if(n == 0){
        return 0;
    }
    int small = sumOfArray(a+1,n-1);
    return small+a[0];
}

int toh(int n){

    if(n == 0){
        return 0;
    }

    return toh(n-1) + 1 + toh(n-1);
}

void printSteps(int n,char s, char h , char d){

    if(n == 0){
        return ;
    }

    printSteps(n-1,s,d,h);
    cout<<"moving disk "<<n<<" from "<<s<<" to "<<d<<endl;
    printSteps(n-1,h,s,d);
}

int staircase(int n){
    if(n == 0 || n == 1){
        return 1;
    }
    if(n < 0){
        return -1;
    }

    return staircase(n-1) + staircase(n-2) + staircase(n-3);
}

void replaceChar(char a[]){

    if(a[0] == '\0'){
        return ;
    }

    if(a[0] == 'a'){
        a[0] == 'm';
    }
    replaceChar(a+1);
}

void removeConsecutiveDuplicates(char a[]){

    if(a[0] == '\0'){
        return ;
    }

    if(a[0] != a[1]){
        removeConsecutiveDuplicates(a+1);
    }else{
        for(int i = 0;a[i] != '\0';i++){
            a[i] = a[i+1];
        }
        removeConsecutiveDuplicates(a);
    }
}


void reversePrint(char input[]){
    if(input[0] == '\0'){
        return ;
    }
    reversePrint(input+1);
    cout<<input[0]<<" ";
}

void printPermu(char input[],int i){

    if(input[i] == '\0'){
        cout<<input<<endl;
        return ;
    }

    for(int j = i;input[j] != '\0';j++){
        swap(input[i],input[j]);
        printPermu(input,i+1);
        swap(input[i],input[j]);
    }
}

print subs(string input,string output){

    if(input.length() == 0){
        cout<<output<<endl;
        return ;
    }

    subs(input.substr(1),output+input[0]);
    subs(input.substr(1),output);
}

int lengthRecursive(char input[]){
    if(input[0] == '\0'){
        return 0;
    }

    int small = lengthRecursive(input+1);
    return small+1;
}

vector<pair<int,string>> v = {{1000000000,"billion"},{1000000,"million"},{1000,"thousand"},{100,"hundred}};

string intToWords(int num){

    if(num == 0){
        return "zero";
    }

    for(auto it : v){
        if(num >= it.first){
            return (num >= 100 ? intToWords(num/it.first) + " " : "" + it.second + (num%it.first == 0 ? "" : " " + intToWords(num%it.first)));
        }
    }

    return "";
}

int convertStrToInt(char input[],int n){

    if(n == 0){
        return 0;
    }
    int small = convertSTrToInt(input,n-1);
    int lastDigit = input[n-1] - '0';
    return small*10 + lastDigit;
}

int basicCalculator(string input,int ind){

    int res = 0;
    int sign = 1;
    int number = 0;

    for(;ind < input.length();ind++){

        char x = input[ind];

        if(x == ' '){
            continue;
        }else if(x == '+' || x == '-'){
            res += sign*(number);
            number = 0;
            sign = x == '+' ? 1 : -1;
        }else if(x == '('){
            res += sign*basicCalculator(input,++ind);
        }else if(x == ')'){
            break;
        }else{
            number *= 10+(x-'0');
        }

    }

    return res;
}



void determiningNum(int a[],int n){

    int ans = 0;
    for(int i : a){
        ans = ans^i;
    }

    int pos = floor(log2(ans)+1);

    int y1 = 0,y2 = 0;
    for(int i : a){
        if(i&(1<<(pos-1))){
            y1 = y1^i;
        }else{
            y2 = y2^i;
        }
    }

    y1 < y2 ? cout<<y1<<" "<<y2<<endl;
    y2 < y1 ? cout<<y2<<" "<<y1<<endl;
}

void printSubs(int a[],int n){

    int total = 1<<n;

    for(int i = 1;i < total;i++){
        if(__builtin_popcount(k) == m){
            for(int i = 0;i < n;i++){
                if(k&(1<<i)){
                    cout<<a[i]<<" ";
                }
            }

            cout<<endl;
        }
        
        
    }
}

void copySetBit(int &x,int y,int l,int r){

    for(;l <= r;l++){

        int k = 1<<l;

        if(y&k){
            x = x | k;
        }
    }
}

int russianPeasant(int x,int y){

    int res = 0;
    while(y > 0){
        if(y&1){
            res += x;
        }


        y = y >> 1;
        x = x << 1;   
    }

    return res;
}


int leftRotate(int x , int d){

    return ((x << m) | (x >> 32-d) )
}

int XORWithoutXOR(int x,int y){

    return (x | y) & (~x | ~y);
}

void binaryR(int n){
    if(n > 1){
        binaryR(n/2);
    }

    cout<<n%2;
}

string addition(string str1,string str2){


    int carry = 0;
    int i = str1.length()-1;
    int j = str2.length()-1;
    string ans = "";

    while(i >= 0 || j >= 0 || carry){
        carry += (j >= 0) ? str2[j--] - '0' : 0;
        carry += (i >= 0) ? str1[i--] - '0' : 0;
        ans = char('0' + carry%2) + ans;
        carry = carry/2;
    }

    return ans;
}

int reverseBits(int x){

    int ans =  0;
    for(int i = 1;i < 32;i++){
        int k = 1<<i;
        if(x&k){
            ans = ans | 1<<(32-i);
        }
    }
    return ans;
}

int swapBits(int x,int p1,int p2,int d){

    int hello = ((x>>p1) ^ (x>>p2))&((1<<d)-1);

    return x^((hello<<p1) | (hello<<p2));
}


int majorityElement(int a[],int n){

    int len = sizeof(int)*8;
    int number = 0;

    for(int i = 0;i < len;i++){

        for(int j = 0;j < n;j++){
            if(a[j]& 1<<i){
                count++;
            }
        }

        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;
    
    for(int i = 0;i < n;i++){

        if(a[i] == number){
            count++;
        }
    }
    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}


int firstIndex(int a[],int n,int m,int i){

    if(n == i){
        return -1;
    }

    if(a[i] == m){
        return i;
    }

    return firstIndex(a,n,m,i+1);
}

int lastIndex(int a[],int n,int m){

    if(n < 0){
        return -1;
    }
    if(a[n-1] == m){
        return n-1;
    }

    return lastIndex(a,n-1,m);

}




void printSubset(int a[],int n){


    int total = 1<<n;
    for(int k = 1;k < total;k++){

        for(int i = 0;i < n;i++){

            if(k&(1<<i)){
                cout<<a[i]<<" ";
            }
        }
        cout<<endl;
    }


}


int majorityElement(int a[],int n){

    int total = sizeof(int)*8;
    int number = 0;

    for(int i = 0;i < total ;i++){
        int count = 0;
        for(int j = 0;j <  n;j++){

            if(a[j]&&(1<<i)){
                count++;
            }
        }

        if(count > (n/2)){
            number += 1<<i;
        }
    }

    int count = 0;
    for(int i = 0;i < n;i++){
        if(number == a[i]){
            count++;
        }
    }

    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}



#include<bits/stdc++.h>
using namespace std;

void printSubsets(int a[],int n){

    int total = 1<<n;
    for(int k = 1;k < total;k++){
        for(int j = 0;j < n;j++){
            if(k&(1<<j)){
                cout<<a[j]<<" ";
            }
        }
        cout<<endl;
    }
}

int main(){


}

int findMajority(int a[],int n){

    int len = sizeof(int)*8;
    int number = 0;

    for(int i = 0;i < len;i++){
        int count = 0;
        for(int j = 0;j < n;j++){
            if(a[j]&(1<<i)){
                count++;
            }
        }

        if(count > (n/2)){
            number +=(1<<i);
        }
    }


    int count = 0;

    for(int i = 0;i < n;i++){
        if(a[i] == number){
            count++;
        }
    }

    if(count == (n/2)){
        return number;
    }else{
        return -1;
    }
}


int fibonacci(int n){
    if(n == 0){
        return 0;
    }
    if(n == 1){
        return 1;
    }

    int small1 = fibonacci(n-1);
    int small2 = fibonacci(n-2);

    return small1+small2;
}

int findGCD(int num1,int num2){

    if(num2 == 0){
        return num1;
    }

    return findGCD(num2,num1%num2);
}

int findGCD(int num1,int num2){

    if(num2 == 0){
        return num1;
    }

    return findGCD(num2,num1%num2);
}

void solution(string str,string asf,int count,int pos){
    if(str.length() == pos){
        if(count == 0){
            cout<<asf<<endl;
        }else{
            cout<<(asf+char('0'+count))<<endl;
        }
        return ;
    }
    

    if(count > 0){
        Solution(str,asf+count+str[pos],0,pos+1);
    }else{
        Solution(str,asf+str[pos],0,pos+1);
    }
    Solution(str,asf,count+1,pos+1);
}


void solution(string str,string asf,int count,int pos){

    if(str.length() == pos){
        if(count == 0){
            cout<<asf<<endl;
        }else{
            cout<<asf+char('0'+count)<<endl;
        }

        return ;
    }

    if(count > 0){
        solution(str,asf+char('0'+count)+str[pos],0,pos+1);
    }else{
        solution(str,asf+str[pos],0,pos+1);
    }

    solution(str,asf,count+1,pos+1);
}


void solve(bool board[][4],int n,int row,int cols[],int ndiag[],int rdiag,string asf){


    if(row == n){
        cout<<asf+'.'<<endl;
        return;
    }

    for(int col = 0;col <n;col++){

        if(cols[col] == false && ndiag[col+row] == false && rdiag[(row-col)+n-1] == false){
            board[row][col] = true;
            cols[col] = true;
            ndiag[row+col] = true;
            rdiag[(row-col)+n-1] = true;
            solve(board,n,row+1,cols,ndiag,rdiag,asf+char('0'+row)+'-'+char('0'+col)+',')
            board[row][col] = false;
            cols[col] = false;
            ndiag[row+col] = false;
            rdiag[(row-col)+n-1] = false;
        }
    }
}

int solve(vector<string> words,vector<int> freq,vector<int> score,int ind){
    if(words.size() == ind){
        return 0;
    }

    int sno = 0+solve(words,freq,score,ind+1);

    int sword = 0;
    string word = words[ind];
    bool flag = true;

    for(int i = 0;i < word.size();i++){
        char ch = word[i];

        if(freq[ch-'a'] == 0){
            flag = false;
        }

        freq[ch-'a']--;
        sword += score[ch-'a'];
    }


    int syes = 0;
    if(flag){
        syes = sword + solve(words,freq,score,ind+1); 
    }

    for(int i = 0;i < word.size();i++){
        char ch = word[i];
        freq[ch-'a']++;
    }

    return max(sno,syes);
}


int maxScoreWords(vector<string> words,vector<char> letters,vector<int> score){

    vector<int> freq(26,0);
    for(int i = 0;i < letters.size();i++){
        freq[letters[i]-'a']++;
    }

    return solve(words,freq,score,0);
}



int solve(vector<string> words,vector<int> freq,vector<int> score,int ind){
    if(words.length() == ind){
        return 0;
    }

    int sno = 0 + solve(words,freq,score,ind+1);

    string word = words[ind];
    int sword = 0;
    bool flag = true;

    for(int i = 0;i < word.length();i++){
        char ch = word[i];

        if(freq[ch-'a'] == 0){
            flag = true;
        }

        freq[ch-'a']--;
        sword += score[ch-'a'];
    }

    int syes = 0;
    if(flag){
        syes = sword + solve(words,freq,score,ind+1);
    }

    for(int i = 0;i < word.length();i++){
        char ch = word[i];
        freq[ch-'a']++;
    }

    return max(sno,syes);
}


int maxScoreWords(vector<string> words,vector<char> letters,vector<int> score){

    vector<int> freq(26,0);
    for(int i = 0;i < letters.size();i++){
        freq[letters[i]-'a']++;
    }

    return solve(words,freq,score,0);
}


int solve(int n,int k){
    if(n == 1){
        return 0;
    }

    int small = solve(n-1,k);
    int y = (small+k)%n;
    return y;
}

int josephusProblem(int n,int k){
    int x = solve(n,k);
    retur x+1;
}

void dfs(int i,int n){
    if(i > n){
        return ;
    }
    cout<<i<<endl;
    for(int j = 0;j < 10;j++){
        dfs(10*i+j,n);
    }
}

void lexicographicalPrint(int n){
    for(int i = 1;i < 10;i++){
        dfs(i,n);
    }
}


int solve(vector<vector<int>> grid,int i,int j,int m,int n){

    if(i >= m || i < 0 || j >= n || j < 0 || grid[i][j] == 0){
        return 0;
    }

    int ans = 0,temp = 0;
    temp = grid[i][j];
    grid[i][j] = 0;

    ans += solve(grid,i+1,j,m,n);
    ans += solve(grid,i-1,j,m,n);
    ans += solve(grid,i,j+1,m,n);
    ans += solve(grid,i,j-1,m,n);

    grid[i][j] = temp;

    return ans + temp;
}


int getMaxGold(vector<vector<int>> grid){

    int m = grid.size();
    int n = grid[0].size();
    int ans = 0;
    for(int i = 0;i < m;i++){
        for(int j = 0;j < n;j++){
            if(grid[i][j] != 0){
                ans = max(ans,solve(grid,i,j,m,n));
            }
        }
    }

    return ans;
    
}

bool check(vector<vector<char>> board,int row,int col,char ch){

    for(int i = 0;i < 9;i++){
        if(board[i][col] == ch){
            return false;
        }
    }

    for(int i = 0;i < 9;i++){
        if(board[row][i] == ch){
            return false;
        }
    }

    int x0 = (row/3)*3 , y0 = (col/3)*3;

    for(int i = 0;i < 3;i++){
        for(int j = 0;j < 3;j++){
            if(board[i+x0][j+y0] == ch) return false;
        }
    }

    return true;
}

bool solve(vector<vector<char>> board,int row,int col){
    if(row == 9) return true;
    if(col == 9) return solve(board,row+1,0);
    if(board[row][col] != '.') return solve(board,row,col+1);

    for(char i = '1';i <= '9';i++){
        if(check(board,row,col,i)){
            board[row][col] = i;
            if(solve(board,row,col+1)) return true;
            board[row][col] = '.';
        }
    }

    return false;
}

void solveSudoku(vector<vector<char>> board){
    solve(board,0,0);
}



bool check(vector<vector<char>> board,int row,int col,char ch){

    for(int i = 0;i < 9;i++){
        if(board[i][col] == ch) return false;
    }

    for(int i = 0;i < 9;i++){
        if(board[row][i] == ch) return false;
    }

    int x0 = (row/3)*3 , y0 = (col/3)*3;

    for(int i = 0;i < 3;i++){
        for(int j = 0;j < 3;j++){
            if(board[x0+i][y0+j] == ch) return false;
        }
    }
    return true;
}


bool solve(vector<vector<char>> board,int row,int col){

    if(row == 9) return true;
    if(col == 9) return solve(board,row+1,0);
    if(board[row][col] != '.') solve(board,row,col+1);

    for(char i = '1';i <= '9';i++){
        if(check(board,row,col,i)){
            board[row][col] = i;
            if(solve(board,row,col+1)) return true;
            board[row][col] = '.';
        }
    }

    return false;
}

void solveSudoku(vector<vector<char>> board){

    solve(board,0,0);
}

void printSubsets(vector<int> arr){

    int n = arr.size();

    int total = 1<<n;

    for(int k = 1;k < total;k++){
        for(int i = 0;i < n;i++){
            if(k&(1<<i)){
                cout<<arr[i]<<" "
            }
        }
        cout<<endl;
    }
}



void printSubsets(vector<int> arr){

    int n = arr.size();

    int total = 1<<n;
    for(int k = 1;k < total ;k++){
        for(int i = 0;i < n;i++){
            if(k&(1<<i)){
                cout<<arr[i]<<" ";
            }
        }
        cout<<endl;
    }
}


string additionOfBitString(string str1,string str2){


    int carry = 0;
    string ans = "";
    int len1 = str1.length();
    int len2 = str2.length();

    while(len1 >= 0 || len2 >= 0 || carry >= 0){

        carry += len1 >= 0 ? str1[len1--] - '0' : 0;
        carry += len2 >= 0 ? str1[len2--] - '0' : 0;
        ans = char('0'+(carry%2)) + ans;
        carry /= 2;
    }

    return ans;
}



return ["https://www.linkedin.com/groups/10307956/","https://www.linkedin.com/groups/7018767/","https://www.linkedin.com/groups/100358/","https://www.linkedin.com/groups/3732032/","https://www.linkedin.com/groups/1875717/","https://www.linkedin.com/groups/3704356/","https://www.linkedin.com/groups/137552/","https://www.linkedin.com/groups/4496205/","https://www.linkedin.com/groups/2115120/","https://www.linkedin.com/groups/2056001/","https://www.linkedin.com/groups/10379184/","https://www.linkedin.com/groups/1074487/","https://www.linkedin.com/groups/7025688/","https://www.linkedin.com/groups/2231152/","https://www.linkedin.com/groups/6519652/","https://www.linkedin.com/groups/12307294/","https://www.linkedin.com/groups/4314060/","https://www.linkedin.com/groups/62218/","https://www.linkedin.com/groups/6940944/","https://www.linkedin.com/groups/1976445/","https://www.linkedin.com/groups/2154029/","https://www.linkedin.com/groups/2066905/","https://www.linkedin.com/groups/8571393/","https://www.linkedin.com/groups/54723/","https://www.linkedin.com/groups/63192/","https://www.linkedin.com/groups/7039829/"];


void printAbbreviation(string str,string asf,int count , int pos){

    if(pos == str.length()){
        if(count > 0){
            cout<<asf+char('0'+count)<<endl;
        }else{
            cout<<asf<<endl;
        }
        
        return ;
    }

    if(count > 0){
        printAbbreviation(str,asf+char('0'+count)+str[pos],0,pos+1);
    }else{
        printAbbreviation(str,asf+str[pos],0,pos+1);
    }

    printAbbreviation(str,asf,count+1,pos+1);
    


}


bool evenOrOdd(int n){

    if(n&1){
        return true;
    }else{
        return false;
    }
}

bool evenOrOdd(int n){

    if(n&1){
        return true;
    }else{
        return false;
    }
}


int swapBits(int x,int p1,int p2,int n){
    int hello = (x>>p1 ^ x>>p2)&((1<<n)-1);
    return x^(hello<<p1 | hello<<p2);
}


int majorityElement(int a[],int n){

    int len = sizeof(int)*8;

    int number = 0;

    for(int i = 0;i < len;i++){
        int count = 0;
        for(int j = 0;j < n;j++){
            if(a[j]&(1<<i)){
                count++;
            }
        }

        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;
    for(int i = 0;i < n;i++){
        if(number == a[i]){
            count++;
        }
    }

    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}


bool checkPal(char str[],int s,int e){
    if(s > e){
        return true;
    }

    if(str[s] == str[e]){
        return checkPal(str,s+1,e-1);
    }else{
        return false;
    }
}


int findGCD(int a,int b){

    if(b == 0){
        return a;   
    }
    return findGCD(b,a%b);

}



int findGCD(int num1,int num2){
    if(num2 == 0){
        return num1;
    }

    return findGCD(num2,num1%num2);
}

bool powerOfThree(int n){

    if(n == 1 || n == 3) return true;
    if(n == 0 || n%3 != 0) return false;

    return powerOfThree(n/3);
}

int fibonacci(int n){
    if(n == 1){
        return 1;
    }

    if(n == 0){
        return 0;
    }

    int small1 = fibonacci(n-1);
    int small2 = fibonacci(n-2);
    return small1 + small2;
}

int factorial(int n){
    if(n == 0){
        return 0;
    }

    return factorial(n-1)*n;
}

int power(int m,int n){
    if( n == 0){
        return 1;
    }

    int small = power(m,n-1);
    return small*m;
}

int print(int n){
    
    if(n == 0){
        return 0;
    }
    cout<<print(n-1)<<" ";
    return n;
}


int count(int n){
    if(n/10 == 0){
        return 1;
    }

    int small = count(n/10);
    return small+1;
}

int sumOfDigits(int n){

    if(n == 0){
        return 0;
    }
    int small = sumOfDigits(n/10);
    int lastDigit = n%10;
    return small+lastDigit;
}

int multiply(int m,int n){

    if(n == 0){
        return 0;
    }

    int small = multiply(m,n-1);
    return small+m;
}

long long countZero(int n){

    if(n == 0){
        return 0;
    }

    int small = countZero(n/10);
    int lastDigit = n%10;
    if(lastDigit == 0){
        return small+1;
    }else{
        return small;
    }
}


double gsum(int n){

    if(n == 0){
        return 1;
    }

    int small = gsum(n-1);
    return small + 1.0/pow(2,n);
}


int helper(string str,int idx == 0){

    int sign =1 ;
    int number = 0;
    int res = 0;


    for(;idx < str.length();idx++){

        char ch = str[idx];

        if(ch == ' '){
            continue;
        }else if(ch == '+' || ch == '-'){
            res += sign*(number);
            number = 0;
            sign = ch == '+' ? 1 : 0;
        }else if('('){
            res += sign*helper(str,++idx);
        }else if(')'){
            break;
        }else{
            number = number*10+(ch-'0');
        }
    }

    return res+(sign*number);
}

int basicCalculator(string str){

    int x = helper(str);
    return x;
}


int myAtoI(string str){

    if(str.length() == 0){
        return 0;
    }

    if(str.length() == 1){
        if(isdigit(str[0])){
            return str[0]-'0';
        }else{
            return 0;
        }
    }

    int i = str.find_first_not_of(' ');
    int indicator = 1;
    int result = 0;

    if(i == -1){
        return 0;
    }

    if(str[i] == '-' || str[i] == '+'){
        indicator = str[i++] == '+' ? 1 : -1;
    }

    while(isdigit(str[i])){

        result = result*10+(str[i++]-'0');

        if(result*indicator >= INT_MAX){
            return INT_MAX;
        }else if(result*indicator <= INT_MIN){
            return INT_MIN;
        }

    }
    return result*indicator;
}


string intToWords(int n){

    vector<pair<char,int>> nums = {{}};

    if(n == 0){
        return "zero";
    }

    for(auto it : nums){
        if(n >= it.first){
            return (n >= 100 ? intToWords(n/it.first) + " " : "") + it.second + (n%it.first == 0 ? "" : " " + intToWords(n%it.first));
        }
    }

    return "";
}


vodi printPermu(char str[],int i=0){

    if(str[i] == '\0'){
        cout<<str<<endl;
        return ;
    }

    for(int j = i;str[j] != '\0';j++){
        swap(str[j],str[i]);
        printPermu(str,i+1);
        swap(str[i],str[j]);
    }
}


void printAbbreviation(string str,string asf ,int count,int idx){

    if(str.length() == 0){

        if(count > 0){
            cout<<asf+char('0'+count)<<endl;
        }else{
            cout<<asf<<endl;
            
        }
    }

    if(count > 0){
        printAbbreviation(str,asf+char('0'+count)+str[idx],0,idx+1);
    }else{  
        printAbbreviation(str,asf+str[idx],0,idx+1);
    }

    printAbbreviation(str,asf,count+1,idx+1);
}



void solve(bool board[][8],int n,int row,bool cols[],bool ndiag[],bool rdiag,string asf){

    if(row == n){
        cout<<asf+'.'<<endl;
        return ;
    }

    for(int col = 0;col < n;col++){

        if(cols[col] == false && ndiag[row+col] == false && rdiag[(row-col)+(n-1)] == false){

            board[row][col] = true;
            cols[col] = true;
            ndiag[row+col] = true;
            rdiag[(row-col)+(n-1)] = true;
            solve(board,n,row+1,cols,ndiag,rdiag,asf+char('0'+row)+'-'+char('0'+col));
            board[row][col] = false;
            cols[col] = false;
            ndiag[row+col] = false;
            rdiag[(row-col)+(n-1)] = false;

        }
    }
}

int main(){

    cin>> n;

    bool board[n][n] = {false};
    bool cols[n] =  {false};
    bool ndiag[(2*n)-1] = {fasle};
    bool rdiag[(2*n)-1] = {false};

    solve(board,n,0,cols,ndiag,rdiag,"");
    
}



int solve(vector<string> words,vector<int> freq,vector<int> score,int idx){

    if(idx == words.size()){
        return 0;
    }

    int sno = 0 + solve(words,freq,score,idx+1);

    int sword = 0;
    string word = words[idx];
    bool flag = true;

    for(int i = 0;i < word.length();i++){

        char ch = word[i];

        if(freq[ch-'a'] == 0){
            flag = false;
        }

        freq[ch-'a']--;
        sword += score[ch-'a'];
    }

    int syes = 0;
    if(flag){
        syes = sword + solve(words,freq,score,idx+1);
    }

    for(int i = 0;i < word.length();i++){
        char ch = word[i];
        freq[ch-'a']++;
    }

    return max(sno,syes);
    
}

int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {

    vector<int> freq(26,0);
    for(int i = 0; i < letters.size();i++){
        freq[letters[i]-'a']++;
    }

    int result = solve(words,freq,score,0);
    return result;
}




int AtoB(int a,int b){

    int res = 1;
    while(a && b){
        if(a&1 == 1){
            if(b&1 == 1){
                res = res*2;
            }else{
                return 0;
            }
        }

        a = a >> 1;
        b = b >> 1;
    }

    return res;
}


int leastGreater(int a){
    return a | a+1;
}
n&(1<<i-1)


(int)(log2(n)+1);


int getSetBit(int n){
    int count = 0;

    while(n){
        count++;
        n = n&n-1;
    }

    return count;
}



string addBitStrings(string str1,string str2){

    string ans = "";
    int carry = 0;
    int i = str1.length()-1;
    int j = str2.length()-2;

    while(i >= 0 || j >= 0 || carry){

        carry += i >= 0 ? (str1[i--]-'0') : 0;
        carry += j >= 0 ? (str1[j--]-'0') : 0;
        ans = char('0'+carry%2) + ans;

        carry = carry/2;

    }

    return ans;
}



int majorityElement(int a[],int n ){
    int len = sizeof(int)*8;

    int number = 0;

    for(int i = 0;i < len;i++){
        int count = 0;

        for(int j = 0;j <  n;j++){
            if(a[j]&(1<<i)){
                count++;
            }

            if(count > (n/2)){
                number += (1<<i);
            }
        }
    }

    int count = 0;

    for(int i = 0;i < n;i++){
        if(a[i] == number){
            count++;
        }
    }

    if(count > (n/2)){
        return number;
    }else{
        return -1;
    }
}

string addition(string str1,string str2){

    int carry = 0;
    int i = str1.length()-1;
    int j = str2.length()-2;
    int res = 0;

    while(carry || i >= 0 || j >= 0){

        carry += i >=0 ? (str1[i--]-'0') : 0;
        carry += j >= 0 ? (str2[j--]-'0') : 0;

        ans = char('0'+carry%2)+ans;
        carry = carry/2;
    }

    return ans;
}

int russianPeasant(int a,int b){

    int res = 0;

    while(b > 0){
        if(b&1){
            res = res+a;
        }

        b = b>>1;
        a = a<<1;
    }

    return res;
}

int swapBits(int x,int p1,int p2,int d){

    int hello = ((x>>p1) ^ (x>>p2))&((1<<n)-1);
    return x^(hello<<p1 | hello<<p2);
}

int rotateBits(int x,int d){

    int y = 0;

    for(int i = 1;i <= 32;i++){
        if(x&(1<<i)){
            y = y | 1<<(32-i);
        }
    }

    return y;
}


#include<bits/stdc++.h>
using namespace std;


class MinHeap{
    private :
        int *input;
        int capacity;
        int heap_size;

    public :

        MinHeap(int cap){
            input = new int[cap];
            capacity = cap;
            heap_size = cap;
        }

        int left(i){
            return (2*i+1);
        }

        int right(i){
            return (2*i+2);
        }

        int parent(int i){
            return (i-1)/2;
        }

        int getMin(){
            return input[0];
        }

        void printArray(){
            for(int i = 0;i < cap;i++){
                cout<<input[i]<<" ";
            }
        }

        int getMin(){
            return input[0];
        }

        void getUnsortedArray(){
            cout<<"enter your elements : ";
            for(int i = 0;i < capacity;i++){
                cin>>input[i];
            }
        }

        void minHeapify(int i){

            int l = left(i);
            int r = right(i);
            int smallest = i;

            if(l < heap_size && input[l] < input[i]){
                smallest = l;
            }else if(r < heap_size && input[r] < input[i]){
                smallest = r;
            }

            if(input[i] != input[smallest]){
                swap(input[i],input[smallest]);
                minHeapify(smallest);
            }
            
        }

        int extractMin(){

            if(heap_size <= 0){
                return INT_MAX;
            }else if(heap_size == 1){
                heap_size--;
                return input[0];
            }

            int root = input[0];
            input[0] = input[heap_size-1];
            heap_size--;
            minHeapify(0);
            return root;

        }

        void heapSort(){
            int temp[capacity];
            for(int j = 0;j < capacity;j++){
                temp[j] = extractMin();
                cout<<temp[j]<<" ";
            }
        }

}

int main(){

}

#include<bits/stdc++.h>
using namespace std;


class PriorityQueue{

    vector<int> pq;

    public :
        priorityQueue{

        }

        bool isEmpty(){
            return pq.size() == 0;
        }

        int getSize(){
            return pq.size();
        }

        int getMin(){
            if(isEmpty()){
                return 0;
            }
            return pq[0];
        }

        void insert(int element){
            pq.push_back(element);
            int CI = pq[pq.size()-1];

            while(CI > 0){
                int PI = (CI-1)/2;

                if(pq[CI] < pq[PI]){
                    swap(pq[CI],pq[PI]);
                    CI = PI;
                }else{
                    break;
                }
            }
        }

        void removeMin(){

            if(isEmpty()){
                return ;
            }

            int min = pq[0];
            pq[0] = pq[pq.size()-1];
            pq.pop_back();

            int pi = 0;
            while(true){

                int l = (pi*2)+1 ;
                int r = (pi*2)+2 ;
                int smallest = i;

                if(l < pq.size() && pq[i] > pq[l]){
                    smallest = l;
                }else if(r < pq.size() && pq[i] > pq[r]){
                    smallest = r;
                }

                if(pq[smallest] == pq[i]){
                    break;
                }

                swap(pq[smallest],pq[i]);
                pi = smallest;
            }
        }

        void inplaceSort(){

            for(int i = 1;i < pq.size();i++){

                int CI = i;
                while(CI > 0){
                    int PI = (CI-1)/2;
                    if(pq[PI] > pq[CI]){
                        swap(pq[PI],pq[CI]);
                        CI = pI;
                    }else{
                        break;
                    }
                }
            }

            int size = pq.size();

            while(size >= 1){

                swap(pq[0],pq[size-1]);
                size--;

                int pi = 0;
                while(true){

                    int l = (2*pi)+1;
                    int r = (2*pi)+2;
                    int smallest = pi;

                    if(smallest < size && pq[l] < pq[pi]){
                        smallest = l;
                    }else if(smallest < size && pq[r] < pq[pi]){
                        smallest = r;
                    }

                    if(smallest = pi){
                        break;
                    }
                    swap(pq[smallest],pq[pi]);
                    pi = smallest;

                }
            }
            
        }
}


int lastStoneWeight(vector<int>&stones){

    priority_queue<int> pq;
    int n = stones.size();

    for(int i = 0;i < n;i++){
        pq.push(stones[i]);
    }

    int first,second ;

    while(n > 1){
        first = pq.top();
        pq.pop();
        second = pq.top();
        pq.pop();
        n -= 2;

        if(first-second > 0){
            pq.push(first-second);
            n += 1;
        }
    }

    return pq.top();
}

int kthlargestelement(int *input,int n,int k){

    priority_queue<int,vector<int>,greater<int>> pq(input,input+n);

    for(int i = 0;i < n;i++){
        if(pq.size() < k){
            pq.push(input[i]);
        }else{
            if(pq.top() < input[i]){
                pq.pop();
                pq.push(input[i]);
            }
        }
    }

    return pq.top();

}


class Solution{

    struct node{
        int no;
        int freq;
        Node(int a,int b){
            no = a;
            freq = b;
        }
    };

    struct compare{
        bool operator()(node const &a,node const &b){
            return a.freq < b.freq;
        }
    }

    public :

        vector<int> topKfrequency(vector<int> nums,int k){
            unordered_map<int,int> mp;

            for(int it : nums){
                mp[it]++;
            }

            priority_queue<node,vector<node>,compare> pq;

            for(auto it : mp){
                pq.push(node(it.first,it.second));
            }

            vector<int> ans;

            while(k--){
                int temp = pq.top();
                pq.pop();
                ans.push_back(temp.no);
            }

            return ans;
        }
}


class Solution{

    struct node{
        int no;
        int freq;

        node(int a,int b){
            no = a;
            freq = b;
        }
    };

    struct compare{
        bool operator()(node const &a,node const &b){
            return a.freq < b.freq;
        }
    };

    public :
        vector<int> kthfrequency(vector<int> &nums,int k){

            unordered_map<int,int> mp;

            for(int num : nums){
                mp[num]++;
            }

            priority_queue<node,vector<node>,compare> pq;

            for(auto it : mp){
                pq.push(node(it.first,it.second));
            }

            vector<int> ans;
            while(k--){
                int temp = pq.top();
                pq.pop();
                ans.push_back(temp.no);
            }

            return ans;
        }
}



void minHeapify(int i){
    int left = left(i);
    int right = right(i);
    int smallest = i;

    if(left < heap_size && harr[left] < harr[i]){
        smallest = left;
    }
    if(right < heap_size && harr[right] < harr[smallest]){
        smallest = right;
    }

    if(smallest != i){
        swap(harr[i],harr[smallest]);
        minHeapify(smallest);
    }
}

int extractMin(){

    if(heap_size <= 0){
        return INT_MAX;
    }else if(heap_size == 1){
        heap_size--;
        return harr[0];
    }

    int root = harr[0];
    harr[0] = harr[heap_size-1];
    heap_size--;
    minHeapify(0);
    return root;
}



for(int i = (s/2)-1;i >= 0;i--){
    minHeapify(i);
}


for(int i = 1;i < n;i++){

    int CI = i;
    while(CI > 0){
        int PI = (CI-1)/2;
        if(harr[CI] < harr[PI]){
            swap(harr[CI],harr[PI]);
            CI = PI;
        }else{
            break;
        }
    }
}

void minHeapify(int i){

    int left = leftIdx(i);
    int right = rightIdx(i);
    int smallest = i;

    if(left < heap_size && harr[left] < harr[i]){
        smallest = left;
    }
    if(right < heap_size && harr[right] < harr[smallest]){
        smallest = right;
    }
    if(smallest != i){
        swap(harr[i],harr[smallest]);
        minHeapify(smallest);
    }
}

for(int i = (heap_size/2)-1;i >= 0;i++){
    minHeapify(i);
}


void inplaceHeapsort(int *pq,int n){

    for(int i = 1;i < n;i++){
        int CI = i;
        while(CI > 0){
            int PI = (CI-1)/2;
            if(harr[CI] < harr[PI]){
                swap(harr[CI],harr[PI]);
                CI = PI;
            }else{
                break;
            }
        }
    }

    int size = n;
    while(size >= 1){
        swap(pq[0],pq[size-1]);
        size--;

        int pi = 0;

        while(true){
            int left = leftIdx(i);
            int right = rightIdx(i);
            int smallest = pi;
        }
    }
}



void kSortedArray(int *input,int n,int k){

    priority_queue<int,vector<int>,greater<int>> pq(input,input+k);

    int s = 0;
    for(int i = k;i < n;i++){
        input[s] = pq.top();
        pq.pop();
        s++;
        pq.push(input[i]);
    }

    while(!pq.empty()){
        input[s] = pq.top();
        pq.pop();
        s++;
    }

}

voi KSortedArray(int *input,int n,int k){

    piority_queue<int,vector<int>,greater<int>> pq(input,input+k);

    int s = 0;
    for(int i = k;i < n;i++){
        input[s++] = pq.top();
        pq.pop();
        pq.push(input[i]);
    }

    while(!pq.empty()){
        input[s++] = pq.top();
        pq.pop();
    }
}


int KthLargestElement(int *input,int n,int k){

    priority_queue<int,vector<int>,greater<int>> pq;

    for(int i = 0;i < n;i++){
        if(pq.size() < k){
            pq.push(input[i]);
        }else{
            if(input[i] > pq.top()){
                pq.pop();
                pq.push(input[i]);
            }
        }
    }

    return pq.top();
}

int KthSmallestElement(int *input,int n,int k){

    priority_queue<int> pq;
    
    for(int i = 0;i < n;i++){
        if(pq.size() < k){
            pq.push(input[i]);
        }else{
            if(input[i] < pq.top()){
                pq.pop();
                pq.push(input[i]);
            }
        }
    }

    return pq.top();


}


int lastStoneWeight(vector<int> &stones){

    int n = stones.size();
    priority_queue<int> max_heap;

    for(int i = 0;i < n;i++){
        max_heap.push(stones[i]);
    }

    int first=0,second=0;
    while(n > 1){
        first = pq.top();
        pq.pop();
        second = pq.top();
        pq.pop();
        n -= 2;

        if(first - second > 0){
            pq.push(first-second);
            n += 1;
        }
    }

    if(!pq.empty()){
        return pq.top();
    }
}

int lastStoneWeight(vector<int> &stones){

    int n = stones.size();
    priority_queue<int> pq;

    for(int i = 0;i < n;i++){
        pq.push(stones[i]);
    }

    int first,second;
    while(n > 1){
        first = pq.top();
        pq.pop();
        second = pq.top();
        pq.pop();
        n -= 2;

        if(first-second > 0){
            pq.push(first-second);
            n += 1;
        }
    }

    if(!pq.empty()){
        return pq.top();
    }
}


class Solution{

    struct Node{
        int no;
        int freq;
        Node(int a,int b){
            no = a;
            freq = b;
        }
    };

    struct compare{
        bool operator()(Node const &a,Node const &b){
            return a.freq < b.freq;
        }
    };

    public :
        vector<int> topKFrequent(vector<int> nums){
            unordered_map<int,int> mp;
            int n = nums.size();
            vector<int> ans;

            for(int i = 0;i < n;i++){
                mp[nums[i]]++;
            }

            priority_queue<Node,vector<Node>,compare> pq;

            for(auto it : mp){
                pq.push(Node(it.first,it.second));
            }

            while(k--){
                Node temp = pq.top();
                pq.pop(); 
                ans.push_back(temp.no);
            }

            return ans;
        }
}

vector<int> maxSlidingWindow(vector<int> nums,int k){
    vector<int> ans;

    priority_queue<int> pq;

    for(int i = 0;i < nums.size();i++){
        
        while(!pq.empty() and pq.top().second <= (i-k)){
            pq.pop();
        }
        pq.push(make_pair(nums[i],i));
        if(i >= (k-1)){
            ans.push_back(pq.top().first);
        }
    }

    return ans;
}

class Solution{

    struct node{
        ListNode* curr;
        int idx;
        node(ListNode* a,int b){
            curr = a;
            idx = b;
        }
    };

    struct compare{
        bool operator()(node const &a,node const &b){
            return a.curr->val > b.curr->val;
        }
    };

    public :
        ListNode* mergeKList(vector<ListNode*> lists){

            priority_queue<node,vector<node>,compare> pq;
            int k = lists.size();
            vector<ListNode*> ptr(k);
            ListNode* head=tail=NULL;

            for(int i = 0;i < k;i++){
                ptr[i] = list[i];
                if(ptr[i] != NULL){
                    pq.push(node(ptr[i],i));
                }
            }

            if(pq.empty()){
                return NULL;
            }

            head=tail=pq.top().curr;
            int idx = pq.top().idx;
            pq.pop();
            ptr[idx] = ptr[idx]->next;

            if(ptr[idx]){
                heap.push(node(ptr[idx],idx));
            }

            while(!pq.empty()){

                ListNode* temp = pq.top().curr;
                idx = pq.top().idx;

                pq.pop();
                
                tail->next = temp;
                tail = tail->next;

                ptr[idx] = ptr[idx]->next;
                if(ptr[idx]){
                    pq.push(node(ptr[idx],idx));
                }
            }

            return head;
        }
}


class Solution{

    struct node{
        ListNode* curr;
        int idx ;
        node(ListNode* a,int b){
            curr = a;
            idx = b;
        }
    };
    struct compare{
        bool operator()(node const& a,node const& b){
            return a.curr->val > b.curr->val;
        }
    };

    public :

        ListNode* mergeKList(vector<ListNode*> lists){

            int k = lists.size();
            priority_queue<node,vector<node>,compare> pq;
            vector<ListNode*> ptr(k);
            ListNode* head,tail;
            head=tail=NULL;

            for(int i = 0;i < k;i++){
                ptr[i] = lists[i];
                if(ptr[i] != NULL){
                    pq.push(node(ptr[i],i));
                }
            }

            if(pq.empty()){
                return NULL;
            }

            head=tail=pq.top().curr;
            int idx = pq.top().idx;
            pq.pop();
            ptr[idx] = ptr[idx]->next;

            if(ptr[idx]){
                pq.push(node(ptr[idx],idx));
            }

            while(!pq.empty()){

                ListNode* temp = pq.top().curr;
                idx = pq.top().idx;
                pq.pop();
                tail->next = temp;
                tail = tail->next;

                ptr[idx] = ptr[idx]->next;
                if(ptr[idx]){
                    pq.push(node(ptr[idx],idx));
                }
            }

            return head;
        }
}


int connectTwoRopes(vector<int>& ropes){

    int n = ropes.size();
    priority_queue<int,vector<int>,greater<int>> pq;


    for(int i = 0;i < n;i++){
        pq.push(ropes[i]);
    }

    int minCost =0;
    while(!pq.empty()){

        int first = pq.top();
        pq.pop();
        int second = pq.top();
        pq.pop();

        int tempCost = first+second;
        minCost = minCost + tempCost;
        pq.push(tempCost);
    }

    return minCost;
}

vector<vector<int>> kClosest(vector<vector<int>> &points,int k){

    priority_queue<pair<int,pair<int,int>>>pq;

    for(int i = 0;i < points.size();i++){
        int dist = points[i][0]*points[i][0] + points[i][1]*points[i][1];
        if(pq.size() < k){
            pq.push({dist,{points[i][0],points[i][1]}});
        }else{
            if(dist < pq.top().first){
                pq.pop();
                pq.push({dist,{points[i][0],points[i][1]}});
            }
        }
    }

    vector<vector<int>> ans;
    while(!pq.empty()){
        ans.push_back({pq.top().second.first,pq.top().second.second});
        pq.pop();
    }   

    return ans;
}

vector<int> kLargestElement(int *input,int n,int k){

    priority_queue<int,vector<int>,greater<int>> pq;

    for(int i = 0;i < n;i++){
        if(pq.size() < k){
            pq.push(input[i]);
        }else{
            if(input[i] > pq.top()){
                pq.pop();
                pq.push(input[i]);
            }
        }
    }

    vector<int> ans;
    while(k--){
        ans.push_back(pq.top());
        pq.pop();
    }
    return ans;

}


char getMaxCountChar(vector<int> count){

    int mx_count = 0;
    char ch;
    for(int i = 0;i < 26;i++){
        if(count[i] > mx_count){
            mx_count = count[i];
            ch = 'a'+i;
        }
    }

    return ch;
}

string rearrangeString(string str){

    int n = str.size();
    if(!n) return " ";

    vector<int> count(26,0);

    for(int i = 0;i < n;i++){
        count[str[i]-'a']++;
    }

    char ch_max = getMaxCountChar(count);
    int mx_count = count[ch_max-'a'];

    string res(n," ");
    int idx = 0;
    while(mx_count){
        res[idx] = ch_max;
        idx += 2;
        mx_count--;
    }
    count[ch_max-'a'] = 0;


    for(int i = 0;i < 26;i++){
        while(count[i] > 0){
            idx = (idx >= n) ? 1 : idx;
            res[idx] = 'a'+i;
            idx += 2;
            count[i]--;
        }
    }
    return res;

}


class three{
    int val;
    int row;
    int col;
    three(int a,int b,int c){
        val = a;
        row = b;
        col = c;
    }
};

struct comp{
    bool operator()(const three &a,const three &b){
        return a.val > b.val;
    }
};

vector<int> solve(vector<vector<int>>& nums){

    int m = nums.size();
    int n = nums[0].size();

    priority_queue<three,vector<three>,comp> pq;
    for(int i = 0;i < m;i++){
        pq.push(three(nums[i][0],i,0));
    }

    vector<int> ans;

    while(!pq.empty()){
        three tp = pq.top();
        pq.pop();
        int val = tp.val;
        int row = tp.row;
        int col = tp.col;

        ans.push_back(val);
        if((col+1) < m) pq.push(three(nums[row][col+1],row,col+1));
    }

    return ans;
}

vector<int> smallestRange(vector<vector<int>> &nums){

    int k = nums.size();
    int maxi = INT_MIN;
    vector<int> res = {-100000,100000};
    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;


    for(int i = 0;i < k;i++){
        int num = nums[i][0];
        maxi = max(num,maxi);
        pq.push({val,0,i});
    }



    while(true){
        vector<int> minVal = pq.top();
        pq.pop();

        if(res[1]-res[0] > max-minVal[0]){
            res[1] = maxi;
            res[0] = minVal[0];
        }

        minVal[1]++;
        vector<int> vec2 = nums[minVal[2]];
        
        if(minVal[1] == vec2.size()){
            break;
        }else{
            minVal[0] = vec2[minVal[1]];
            maxi = max(maxi,minVal[0]);
            pq.push(minVal);
        }

    }
    return ans;
}


vector<int> solve(vector<vector<int>> &nums){

    vector<int> res{-100000,100000};
    int k = nums.size();
    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> pq;
    int maxi = INT_MIN;

    for(int i = 0;i < k;i++){
        int num = nums[i][0];
        maxi = max(maxi,num);
        pq.push({num,0,i});
    }

    while(true){

        vector<int> minVal = pq.top();
        pq.pop();

        if(res[1]-res[0] > maxi-minVal[0]){
            res[1] = maxi;
            res[0] = minVal[0];
        }

        minVal[1]++;
        vector<int> vec2 = nums[minVal[2]];

        if(minVal[1] >= vec2.size()){
            break;
        }else{
            minVal[0] = vec2[minVal[1]];
            maxi = max(maxi,minVal[0]);
            pq.push(minVal);
        }
    }

    return res;
}




class MedianFinder{
    public :
        priority_queue<int> small;
        priority_queue<int,vector<int>,greater<int>> big;

        MedianFinder(){

        }

        void addNum(int element){
            small.push(element);
            big.push(small.top());
            small.pop();

            if(big.size() > small.size()){
                small.push(big.top());
                big.pop();
            }
        }

        int findMedian(){
            if(small.size() == big.size()){
                return 0.5*(small.top() + big.top());
            }

            return small.top();
        }
}



bool isHeap(Node root){

    if(root == NULL) return false;

    queue<Node*> q;
    bool flag = false;
    q.push(root);

    while(!q.empty()){

        Node curr = q.front();
        q.pop();

        if(curr->left){
            if(flag == 1 || curr->left->data > curr->data){
                return false;
            }
            q.push(curr->left);
        }else{
            flag = 1;
        }

        if(curr->right){
            if(flag == 1 || curr->right->data > curr->data){
                return false;
            }
            q.push(curr->right);
        }else{
            flag = 1;
        }
    }

    return true;
}


int minSum(int arr[],int n){

    priority_queue<int,vector<int>,greater<int>> pq(arr,arr+n);

    int a=0,b=0;
    while(!pq.empty()){
        a *= 10;
        a += pq.top();
        pq.pop();

        if(!pq.empty()){
            b *= 10;
            b += pq.top();
            pq.pop();
        }
    }
    return a+b;

}


int left(int i){
    return (i*2)+1;
}
int right(int i){
    return (i*2)+2;
}
void heapify(vector<int> &nums,int i,int n){

    int l = left(i);
    int r = right(i);

    int largest = i;

    if(l < n && nums[l] > nums[i]){
        largest = l;
    }
    if(r < n && nums[r] > nums[largest]){
        largest = r;
    }

    if(largest != i){
        swap(nums[largest],nums[i]);
        heapify(nums,largest,n);
    }
}

vector<int> maxHeap(vector<int> nums){

    int n = nums.size();
    int i = (n/2)-1;

    while(i >= 0){
        heapify(nums,i--,n);
    }

    return nums;
}

int helper(string str,int idx){

    char ch = str[idx];

    int sign = 1;
    int number = 0;
    int res = 0;

    if(ch == ' '){
        continue;
    }else if(ch == '+' || ch == '-'){
        res += sign*number;
        number = 0;
        sign = (ch == '+') ? 1 : -1;
    }else if(ch == '('){
        res += sign*helper(str,idx++);
    }else if(ch == ')'){
        break;
    }else{
        number = number*10+(ch-'0');
    }
    return res+(sign*number);
}

int calculator(string str){

    int res = helper(str,0);
    return res;
}


char getMaxChar(vector<int> &count){

    char ch;
    int mx_count = 0;

    for(int i = 0;i < 26;i++){
        if(mx_count < count[i]){
            ch = i+'a';
            mx_count = count[i];
        }
    }
    return ch;
}

string rearrangeString(string str){

    int n = str.size();
    vector<int> count(26,0);

    for(int i = 0;i < n;i++){
        count[str[i]-'0']++;
    }

    string res(n,"");

    char ch = getMaxChar(count);
    int mx_count = count[ch-'a'];

    idx = 0;
    while(mx_count){
        res[idx] = ch;
        idx += 2;
        mx_count--;
    }

    count[ch-'a'] = 0;

    for(int i = 0;i < 26;i++){

        while(count[i] > 0){
            idx = (idx >= n) ? 1 : idx;
            res[idx] = i+'a';
            idx += 2;
            count[i]--;
        }
    }
    return res;
}


class node{
    public :
        int idx;
        ListNode* curr;
        node(ListNode* ptr,int i){
            curr = ptr;
            idx = i;
        }
}

struct comparator{
    bool compare()(node const& *a,node const& *b){
        return a.curr->val > b.curr->val;
    }
}

ListNode* mergeKList(vector<ListNode*> lists){

    int k = lists.size();
    ListNode* head, *tail;
    vector<ListNode*> ptr;
    priority_queue<node,vector<node>,comparator> pq;

    for(int i = 0;i < k;i++){
        ptr[i] = lists[i][0];
        if(ptr[i]){
            pq.push(node(ptr[i],i));
        }
    }

    if(pq.empty()){
        return NULL;
    }

    int idx = 0;
    head=tail=pq.top().curr;
    idx = pq.top().idx;
    pq.pop();
    ptr[idx] = ptr[idx]->next;
    if(ptr[idx]){
        pq.push(node(ptr[idx],idx));
    }


    while(!pq.empty()){
        ListNode* temp = pq.top().curr;
        pq.pop();

        tail->next = temp
        tail = tail->next;

        ptr[idx] = ptr[idx]->next;
        if(ptr[idx]){
            pq.push(node(ptr[idx],idx));
        }
    }
    return head;
}




vector<int> smallestRange(vector<vector<int>>& nums){

    int k = nums.size();
    vector<int> res = {-100000,100000};
    int maxi = 0;
    priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>> heap;

    for(int i = 0;i < k;i++){
        vector<int> vec = {nums[i][0],0,i};

        maxi = max(maxi,nums[i][0]);
        heap.push(vec);
    }



    while(true){
        vector<int> minval = pq.top();
        pq.pop();

        if(res[1]-res[0] > maxi-minval[0]){
            res[0] = minVal[0];
            res[1] = maxi;
        }

        minval[1]++;
        vector<int> vec2 = nums[minval[2]];
        if(minval[1] == vec2.size()){
            break;
        }else{
            minval[0] = vec2[minval[1]];
            maxi = max(maxi,vec2[minval[1]]);
            pq.push(minval);
        }
    }

    return res;
}


class Trie{
    public :
        bool isTerminal;
        int freq;
        Trie *chid[26];

        Trie(){
            isTerminal = false;
            freq = 0;
            for(int i = 0;i < 26;i++){
                child[i] = NULL;
            }
        }
};

void buildTree(string word,Trie* root){

    Trie* curr = root;
    for(int i = 0;i < word.size();i++){
        if(curr->child[word[i]-'a'] == NULL){
           curr->child[word[i]-'a']->freq++;
           curr->child[word[i]-'a'] = new Trie();
           curr = curr->child[word[i]-'a'];
        }else{
            curr->child[word[i]-'a']->freq++;
            curr = curr->child[word[i]-'a'];
        }
    }
}

string buildPrefix(string word,Trie* root){
    Trie* curr;
    string ans = "";
    for(int i =0i < word.size();i++){
        if(curr->child[word[i]-'a'] == 1){
            ans += word[i];
            break;
        }else{
            ans += word[i];
            curr = curr->child[word[i]-'a'];
        }
    }

    return ans;
}

vector<string> findPrefix(vector<string> words){
    Trie* root ;
    vector<string> ans;
    for(int i = 0;i < words.size();i++){
        buildTree(words[i],root);
    }

    for(int i = 0;i < words.size();i++){
        ans.push_back(buildPrefix(words[i],root));
    }

    return ans;

}


bool payingUp(vector<int> nums){
    int n = nums.size();

    int total = 1<<n;

    for(int k = 1;k < total;k++){
        int sum = 0;
        for(int i = 0;i < n;i++){
            if(k&(1<<i)){
                sum += nums[i];
            }
        }

        if(sum == m){
            return true;
        }else{
            return false;
        }
    }
}

string additionOfBitString(string str1, string str2){

    int i = str1.lenght()-1;
    int j = str2.lenght()-1;

    int carry = 0;
    string ans = "";
    while(i >= 0 || j >= || carry){
        carry += (i >= 0) ? str1[i--]-'0' : 0;
        carry += (j >= 0) ? str2[j--]-'0' : 0;
        ans = char('0'+carry%2)+ans;
        carry /= 2;
    }

    return ans;
}

int swapBits(int x,int p1,int p2,int n){

    int hello = ((x>>p1)^(x>>p2))&((1<<n)-1);
    return x^(hello<<p1 | hello<<p2);
}

class TrieNode{
    public :
        unordered_map<char,TrieNode*> child;
        bool isLeaf;
        unordered_set<string> words;
};

class Solution{
    public :
        void insert(TrieNode* root , string word){

            if(root == NULL){
                root = new TrieNode();
            }

            TrieNode* curr = root;
            for(char c : word){
                if(isupper(c)){
                    if(curr->child.find(c) == curr->child.end()){
                        curr->child[c] = new TrieNode();
                    }
                    curr = curr->child[c];
                }
            }

            curr->isLeaf = true;
            curr->words.insert(word);
        }

        void printAllWords(TriNode* root){

            if(root->isLeaf){
                unordered_set<string> wordset = root->words;
                for(string word : wordset){
                    cout<<word<<endl;
                }
                return ;
            }

            for(auto el : root->child){
                if(el.second){
                    printAllWords(el.second);
                }
            }
        }

        void findAllWords(vector<string> &dictionary,string pattern){

            TrieNode* root;
            for(string word : dictionary){
                insert(root,word);
            }

            TrieNode* curr = head;
            for(char c : pattern){
                curr = curr->child[c];
                if(curr == NULL){
                    return ;
                }
            }

            printAllWords(curr);
        }
}




bool checkpalindrome(string str1,int s,int e){
    if(s >= e){
        return true;
    }

    if(str1[s] == str1[e]){
        return checkpalindrome(str1,s+1,e-1);
    }else{
        return false;
    }
}

int main(){
    cout<<"hello world"<<endl;

    cout<<checkpalindrome("hello",0,4);
}

bool checkpalindrome(string str,int s,int e){
    if(s >= e){
        return true;
    }
    if(str[s] == str[e]){
        return checkpalindrome(str,0,4);
    }else{
        return false;
    }

int main(){
    cout<<checkpalindrome("anand",0,4);
}



bool checkpalindrome(string str,int s,int e){
    if(s >= e){
        return true;
    }
    if(str[s] == str[e]){
        return checkpalindrome(str,s+1,e-1);
    }else{
        return false;
    }
}

int main(){
    cout<<checkpalindrome("hello",0,4);
}


int solve(int idx,vector<int>&heights){

    if(idx == 0) return 0;
    int left = solve(idx-1,heights) + abs(heights[idx]-heights[idx-1]);
    int right = INT_MAX;
    if(idx > 1)
        right = solve(idx-2,heights) + abs(heights[idx]-heights[idx-2]);

    return min(left,right);
}

int solve2(int idx,vector<int>&heights,vector<int>&dp){
    if(idx == 0) return 0;
    if(dp[idx] != -1){
        return dp[idx];
    }
    int left = solve(idx-1,heights) + abs(heights[idx]-heights[idx-1]);
    int right = INT_MAX;
    if(idx > 1)
        right = solve(idx-2,heights) + abs(heights[idx]-heights[idx-2]);
    dp[idx] = min(left,right);
    return dp[idx];
}

int solve3(int idx,vector<int>&heights){

    int n = heights.size();
    vector<int> dp(n,-1);
    dp[0] = 0;
    for(int i = 1;i < n;i++){
        int left = dp[idx-1] + abs(heights[idx]-heights[idx-1]);
        int right = INT_MAX;
        if(idx > 1)
            right = dp[idx-2] + abs(heights[idx]-heights[idx-2]);
        
        dp[idx] = min(left,right);
    }

    return dp[n-1];
}


int solve4(int idx,vector<int>&heights){
    int n = heights.size();
    int prev1 = 0;
    int prev2 = 0;
    for(int i = 1;i < n;i++){
        int left = prev1 + abs(heights[idx]-heights[idx-1]);
        int right = INT_MAX;
        if(idx > 1)
            right = prev2 + abs(heights[idx]-heights[idx-2]);
        
        int ans = min(left,right);
        prev2 = prev1;
        prev1 = ans;
    }

    return prev1;
}

string intToWords(int num){

    vector<pair<int,string>> nums = {{1000000000,"billion"},{1000000,"million"},{1000,"thousand"},{100,"hundred"},{90,"ninety"}};

    if(num == 0){
        return "zero";
    }

    for(auto it : nums){
        if(num >= it.first){
            return ((num >= 100 ? intToWords(num/it.first) + " " : "") + it.second + (num%it.first == 0 ? "" : " " + intToWords(num%it.first)));
        }
    }
    return "";
}

bool checkSubsequenceSum(int n,vector<int> &arr,int k){
    if(k == 0){
        return true;
    }
    if(n < 0 || k < 0){
        return false;
    }

    bool include = checkSubsequenceSum(n-1,arr,k-arr[n]);
    bool exclude = checkSubsequenceSum(n-1,arr,k);

    return include || exclude;

}


void Solution(string s,string &asf,int count,int idx){
    if(idx == s.length()){
        if(count > 0){
            ans.push_back()
        }else{

        }
        return ;
    }
}

int main(){
    string s = "pep";
    vector<string> ans;
    Solution(s,ans,0,0);
}


int getValue(int a,int b){
    int res = 0;
    while(a && b){
        if(b&1){
            if(a&1){
                res = res*2;
            }else{
                return 0;
            }
        }
        b = b >> 1;
        a = a << 1;
    }
    return res;
}



int checkPal(int arr[],int s,int e){
    if(s >= e){
        return true;
    }
    if(arr[s] == arr[e]){
        return checkPal(arr,s+1,e-1);
    }else{
        return false;
    }
}


bool checkSubsequenceSum(int n,vector<in> &arr,int k){
    if(k == 0){
        return true;
    }
    if(n < 0 || k < 0){
        return false;
    }

    bool include = checkSubsequenceSum(n-1,arr,k-arr[n]);
    bool exclude = checkSubsequenceSum(n-1,arr,k);

    return include || exclude;
}

bool checkSubsequenceSum(int n,vector<int> &arr,int k,auto &lookup){
    if(k == 0){
        return true;
    }
    if(k < 0 || n < 0){
        return false;
    }

    string key = to_string(n)+'|'+to_string(k);

    if(lookup.find(key) == lookup.end()){
        bool include = checkSubsequenceSum(n-1,arr,k-arr[n],lookup);
        bool exclude = checkSubsequenceSum(n-1,arr,k,lookup);

        lookup[key] = include || exclude;
    }

    return lookup[key];
}

void print(int n){
    if(n <= 1){
        return 1;
    }
    cout<<print(n-1)<<" :
    return n;
}


bool helper(string s,string &ans,unordered_set<string> &words){

    if(s.length() == 0){
        cout<<ans;
        return ;
    }

    for(int i = 0;i < s.length();i++){
        string left = s.substr(0,i+1);
        if(words.find(left) != words.end()){
            string right = s.substr(i+1);
            helper(right,ans+left+" ",words);
        }
    }
}


bool wordBreak(string s,vector<string> &words){

    return helper(s,"",{words.begin(),words.end()});
}


int helper(string str,int idx){

    int indicator = 1;
    int result = 0;

    for(;idx < str.size();idx++){

        char c = str[idx];
        
    }
}



vector<pair<int,string>> pad = {{1000000000,"billion"},{1000000,"million"},{1000,"thousand"},{100,"hundred"},{90,"neinty"},{80,"eighty"},{70,"seventy"},{60,"sixty"},{50,"fifty"},{40,"fourty"},{30,"thirty"},{20,"twenty"},{19,"neinteen"},{18,"eighteen"},{17,"seventeen"},{16,"sixteen"},{15,"fifteeen"},{14,"fourteen"},{13,"thirteen"},{12,"twelve"},{11,"eleven"},{10,"ten"},{9,"nine"},{8,"eight"},{7,"seven"},{6,"six"},{5,"five"},{4,"four"},{3,"three"},{2,"two"},{1,"one"}};


string numToWords(int n){

    if(n == 0){
        return "zero";
    }

    for(auto it : pad){
        if(n >= it.first){
            (n >= 100 ? numToWords(n/it.first)+" " : "") + it.second + (n%it.first == 0 ? "" : " " + numToWords(n%it.first));
        }
    }

    return "";
}


int helper(string s,int idx){

    int result = 0;
    int indicator = 1;
    int number = 0;

    for(;idx < s.size();idx++){

        char c = s[idx];

        if(c == ' '){
            continue;
        }else if(c == '-' || c == '+'){
            res += sign*(number);
            number = 0;
            sign = c == '-' ? -1 : 1;
        }else if(c == '('){
            res += sign*(helper(s,++idx));
        }else if(c == ')'){
            break;
        }else{
            res += number*10+(c-'0');
        }
    }

    return res+(sign*number);
}
int basicCalc(string s){

    return helper(s,0);
}

int myAtoi(string s){

    if(s.length() == 0){
        return 0;
    }
    if(s.length() == 1){
        if(isdigit(s[0])){
            return s[0]-'0';
        }else{
            return 0;
        }
    }

    int i = s.find_first_not_of(" ");
    int indicator = 1;
    int result = 0;
    if(i == -1){
        return 0;
    }
    indicator = s[i++] == '-' ? -1 : 1;

    while(isdigit(s[i])){

        result = result*10+(s[i++]-'0');
        if(result*indicator >= INT_MAX){
            return INT_MAX;
        }else if(result*indicator <= INT_MIN){
            return INT_MIN;
        }
    }
    return result*indicator;

}


int length(char str[]){

    if(str[n-1] == '\0'){
        return 0;
    }

    return length(str+1)+1;
}


void print_subs(string input,string output){
    if(input.lenght() == 0){
        cout<<output<<" ";
    }

    print_subs(input.substr(0,1),output+input[0]);
    print_subs(input.substr(0,1),output);
}


vector<vector<string>> ans;
void print_permu(string input,ind idx,int n){

    if(idx == n){
        ans.push_back(input);
        return ;
    }

    for(int i = idx;i < input.size();i++){
        swap(input[i],input[idx]);
        print_permu(input,i+1,n);
        swap(input[i],input[idx]);
    }
}


void print_permu_2(string input,int idx,int n){

    if(idx == n){
        ans.push_back(input);
        return ;
    }
    
    set<char> s;
    for(int i = idx;i < n;i++){
        if(s.find(input[i]) == s.end()){    
            swap(input[i],input[idx]);
            print_permu_2(input,i+1,n);
            swap(input[i],input[idx]);
            s.insert(input[i]);
        }
    }

}





void reverseInsert(stack<int> &st,int key){
    if(st.empty()){
        st.push(key);
        return ;
    }

    int top = st.top();
    st.pop();

    reverseInsert(st,key);

    st.push(top);
}



void reverse(stack<int> &st){

    if(st.empty()){
        return ;
    }

    int top = st.top();
    st.pop();

    reverse(st);

    reverseInsert(st,top);
}



void insertSorted(stack<int> &st,int key){
    if(st.empty() || key >= st.top()){
        st.push(key);
        return ;
    }

    int top = st.top();
    st.pop();

    insertSorted(st,key);

    st.push(top);
}

void sortStack(stack<int> &st){
    if(st.empty()){
        return ;
    }

    int top = st.top();
    st.pop();

    sortStack(st);

    insertSorted(st,top);
}



helper(vector<int> &nums,int sum,vector<vector<int>> ans,int currIdx){

    ans.push_back(sum);
    for(int i = currIdx;i < nums.size();i++){
        ans += nums[i];
        helper(nums,sum,ans,i+1);
        ans -= nums[i];
    }
}





void subsets(vector<int> &nums){
    vector<vector<int>> ans;
    
    helper(nums,0,ans,0);
    return ans;
}


void findMajority(int arr[],int n){

    int total = sizeof(int)*8;
    int number = 0;

    for(int i = 0;i < len;i++){
        int count = 0;
        for(int j = 0;j < n;j++){

            if(arr[j]&(1<<i)){
                count++;
            }
        }

        if(count > (n/2)){
            number += (1<<i);
        }
    }

    int count = 0;

    for(int j = 0;j < n;j++){
        if(number == arr[j]){
            count++;
        }
    }

    if(count >= (n/2)){
        return number;
    }else{
        return -1;
    }
}

void solution(string str,string temp,int count,int pos){

    if(pos == str.length()){
        if(count > 0){
            cout<<asf+char('0'+count)+str[pos]
        }
    }
}

void arrange(int arr[],int n){

    int s = 0;
    int e =  n-1;

    while(s <= e){
        if(arr[s] < 0 && arr[e] < 0){
            s++;
        }
        if(arr[s] < 0 && arr[e] > 0){
            e--;
        }
        if(arr[s] > 0 && arr[e] > 0){
            s++;
            e--;
        }
        if(arr[s] > 0 && arr[e] < 0){
            swap(arr[s],arr[e]);
            e--;
            s++;
        }
    }
}



string twoSum(vector<int> &nums,int target){
    sort(nums.begin(),nums.end());

    int n = nums.size();
    int left = 0,right = 0;
    while(right < n){
        int sum = nums[left] + nums[right];
        if(sum == target){
            return "yes";
        }else if(sum > target){
            right--;
        }else{
            left++;
        }
    }
    return "No";
}

void sort012(vector<int> &nums){
    int n = nums.size();
    int low = 0,mid = 0,high = n-1;

    while(mid <= high){
        if(nums[mid] == 0){
            swap(nums[low++],nums[mid]);
        }else if(nums[mid] == 1){
            mid++;
        }else{
            swap(nums[mid],nums[high]);
        }
    }
}

int stockBuyAndSell(vector<int> &nums){

    int n = nums.size();
    int min = INT_MAX;
    int pist = 0;
    int op = 0;
    for(int i = 0;i < n;i++){
        if(nums[i] < min){
            min = nums[i];
        }

        pist = nums[i] - min;
        if(pist > op){
            op = pist;
        }
    }
    return op;
}



vector<int> nextPermutation(vector<int> &a){
    int n = a.size();
    int ind = -1;

    for(int i = n-2;i >= 0;i--){
        if(a[i] < a[i+1]){
            ind = i;
            break;
        }
    }

    if(ind == -1){
        reverse(a.begin(),a.end());
        return a;
    }

    for(int i = n-1;i > ind;i--){
        if(a[i] > a[ind]){
            swap(a[i],a[ind]);
            break;
        }
    }

    reverse(a.begin()+ind+1,a.end());
    return a;
}


string reverseString(string word){

    int cnt = 0;
    int i = 0;
    reverse(word.begin(),word.end());
    for(;i < word.length();i++){
        if(word[i] == '.'){
            reverse(word.begin()+cnt,word.begin()+i);
            cnt = i+1;
        }
    }
    reverse(word.begin()+cnt,word.begin()+i);
    return word;
}


string longestCommonPrefix(string s[],n){

    string S = "";
    int minLength = INT_MAX;

    for(int i = 0;i < n;i++){
        if(s[i].length() < minLength){
            minLength = s[i].length();
            S = s[i];
        }
    }

    int count = -1;
    bool flag = true;
    for(int i = 0;i < minLength;i++){
        for(int j = 0;j < n;j++){
            if(s[j][i] != S[i]){
                flag = false;
            }
        }
        if(flag == false){
            break;
        }
        count++;
    }
    if(count == -1){
        return "-1";
    }

    return S.substr(0,count);
}

int romanToInt(string s){
    int result = 0;
    unordered_map<char,int> mp = {{'I',1},{'V',5},{'X',10},{'L',50},{'C',100},{'D',500},{'M',1000}};
    for(int i = s.length()-1;i >=0;i--){
        if(mp[s[i]]*4 > result){
            result += mp[s[i]];
        }else{
            result -= mp[s[i]];
        }
    }
    return result;
}


string intToRoman(int num){
    string code[] = {"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
    int intCode[] = {1000,900,500,400,100,90,50,40,10,9,5,4,1};

    itn size = sizeof(code)/sizeof(code[0]);
    string result = "";
    for(int i = 0;i < size;i++){
        while(num >= intCode[i]){
            result += code[i];
            num -= intCode[i];
        }
    }
    return result;
}


int shortestDistance(string first,string sec,vector<string> s){
    int firstPlace = -1;
    int secondPlace = -1;
    int minDistance = INT_MAX;
    int n = s.size();

    for(int i = 0;i < n;i++){
        if(s[i] == first){
            firstPlace = i;
        }
        if(s[i] == sec){
            secondPlace = i;
        }

        if(firstPlace != -1 && secondPlace != -1){
            minDistance = min(minDistance,abs(firstPlace-secondPlace));
        }
    }
    return minDistance;
}


bool divisibleBy7(string s){

    int num = 0;
    for(int i = 0; i < s.length();i++){
        num = num*10 + s[i]-'0';
        num %= 7;
    }

    if(num == 0){
        return true;
    }else{
        return false;
    }
}

string encryptString(string s){
    char on = s[0];
    int count = 1;
    string ans = "";
    for(int i = 1;i < s.length();i++){
        if(s[i] == s[i-1]){
            count++;
        }else{
            ans += on;
            string hx = "";
            while(count != 0){
                int rem = count%16;
                if(rem < 10){
                    hx += ('0'+rem);
                }else{
                    hx += 'a'+(rem-10);
                }
                count /= 16;
            }

            ans += hx;
            on = s[i];
            count = 1;

        }
    }

    if(ans == ""){
        ans += on;
        string hx = "";
        while(count != 0){
            int rem = count%16;
            if(rem < 10){
                hx += ('0'+rem);
            }else{
                hx += 'a'+(rem-10);
            }
            count /= 16;
        }

        ans += hx;
    }
    return reverse(ans.begin(),ans.end());

}

bool areIsomorphic(string str1,string str2){

    unordered_map<char,char> mp1;
    unordered_map<char,bool> mp2;

    if(str1.length() != str2.length()){
        return false;
    }
    for(int i = 0;i < str1.length();i++){
        char ch1 = str1[i];
        char ch2 = str2[i];

        if(mp1.find(ch1) != mp.end()){
            if(mp1[ch1] != ch2){
                return false;
            }
        }else{
            if(mp2[ch2] == true){
                return false;
            }else{
                mp1[ch1] = ch2;
                mp2[ch2] = true;
            }
        }
    }
}


bool areKAnagram(string str1,string str2,int k){

    unordered_map<char,int> mp;
    int count = 0;

    if(str1.length() != str.length()){
        return false;
    }
    for(int i = 0;i < str1.length();i++){
        mp[str1[i]]++;
    }

    for(int i = 0;i < str2.length();i++){
        if(mp[str2[i]] == 0){
            count++;
        }else{
            mp[str2[i]]--;
        }
    }

    if(count <= k){
        return true;
    }else{
        return false;
    }
}


bool checkPanagram(string s){

    bool alList[27];

    for(int i = 0;i < s.length();i++){
        if(s[i] >= 'A' && s[i] <= 'Z'){
            int ind = s[i]-'A';
            alList[ind] = true;
        }else if(s[i] >= 'a' && s[i] <= 'z'){
            int ind = s[i]-'a';
            alList[ind] = true;
        }
    }

    bool ans = true;
    for(int i = 0;i <= 25;i++){
        if(alList[i] == false){
            ans = false;
            break;
        }
    }
    return ans;
}


int helper(string str,int s,int e){

    if(s >= e){
        return 0;
    }
    if(str[s] == str[e]){
        return helper(str,s+1,e-1);
    }

    return min(helper(str,s+1,e),helper(str,s,e-1));
}
int minDeletion(string str){
    int result = 0;
    int n = str.length();
    result = helper(str,0,n-1);
    return result;
}

bool checkRotation(string str1,string str2){

    int len1 = str1.length();
    int len2 = str2.length();

    if(len1 < 2 || len2 < 2){
        if(str1 == str2){
            return true;
        }else{
            return false;
        }
    }

    string temp1,string temp2;

    temp1.append(str1.substr(2,len1-2));
    temp1.append(str1.substr(0,2));

    temp2.append(str2.substr(len1-2,2));
    temp2.append(str2.substr(0,len1-2));

    if(temp1 == str2 || temp2 == str2){
        return true;
    }else{
        return false;
    }
}


int myatoi(string str){

    if(str.length() == 0){
        return 0;
    }

    if(str.length() == 1){
        if(isdigit[str[0]]){
            return str[0]-'0';
        }else{
            return 0;
        }
    }

    int i = str.find_first_not_of(" ");

    if(i == -1){
        return 0;
    }

    int result = 0;
    int indicator = 1;

    indicator = str[i++] == '-' ? -1 : 1;

    while(isdigit(str[i])){
        result = result*10 + str[i++]-'0';

        if(result*indicator >= INT_MAX){
            return INT_MAX;
        }else if(result*indicator <= INT_MIN){
            return INT_MIN;
        }
    }
    return result*indicator;
}



bool isValid(string str){

    int counter = 0;

    for(int i = 0;i < str.length();i++){
        if(str[i] == '.'){
            counter++;
        }
    }

    if(counter != 3){
        return false;
    }

    unordered_set<int> st;
    counter = 0;

    for(int i = 0;i < 256;i++){
        st.insert(to_string(i));
    }

    string temp = "";
    for(int i = 0;i < str.length();i++){
        if(str[i] != '.'){
            temp += str[i];
        }else{
            if(st.count(temp) != st.end()){
                counter++;
                temp = "";
            }
        }
    }

    if(st.count(temp) != st.end()) counter++;
    if(counter != 4) return false;
    else return true;
}

string keyFormatting(string s,int k){

    int counter = 0;
    string result = "";
    for(int i = s.length()-1;i >= 0;i--){
        if(s[i] != '-'){

            if(counter == k){
                result += '-';
                counter = 0;
            }

            counter++;
            if(s[i] >= 'a' && s[i] <= 'z'){
                s[i] = 'A'-'a';
            }

            result += s[i];

        }
    }

    reverse(result.begin(),result.end());
}


Node* reverseLL(Node* head){

    Node* prev = NULL;
    Node* curr = head;
    while(curr != NULL){
        Node* n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }

    return prev;
}

Node* middleLL(Node* head){
    Node* slow = head;
    Node* fast = head->next;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    if(fast != NULL){
        return slow->next->data;
    }
    return slow->data;
}


Node* removeKthNode(Node* head,int k){
    Node* first = head;
    Node* second = head;
    while(k--){
        second = second->next;
    }

    if(second == NULL){
        return first->next;
    }

    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }
    first->next = first->next->next;
    return head;
    
}

bool isPresent(Node* head,int data){
    if(head == NULL) return false;
    if(head->data == data) return true;
    return isPresent(head->next);
}


int length(Node* head){
    if(head == NULL) return 0;
    int smallAns = length(head->next);
    return smallAns+1;
}

Node* deleteIthNode(Node* head,int i){
    if(i < 0){
        return head;
    }
    if(i == 0 && head){
        return head->next;
    }

    if(i > length(head)){
        return NULL;
    }

    int count = 1;
    Node* copyHead = head;
    while(count <= i-1 && head){
        head = head->next;
        count++;
    }

    if(head && head->next){
        Node* temp = head->next;
        head->next = head->next->next;
        temp->next = NULL;
        delete temp;
    }
    return copyHead;

}

Node* insertAtIthPos(Node* head,int i,int data){
    if(i == 0){
        Node *n = new Node(data);
        n->next = head;
        head = n;
        return head;
    }

    if(i < 0){
        return head;
    }

    if(i > length(head)){
        return NULL;
    }

    int count = 1;
    Node* copyHead = head;

    while(count <= i-1 && head){
        head = head->next;
        count++;
    }

    if(head && head-next){
        Node* n = new Node(data);
        Node* temp = head->next;
        head->next = n;
        n->next = temp;
    }
    return copyHead;
}

int printIthNode(Node* head,int i){
    if(i == 0){
        return head->data;     
    }

    if(i < 0){
        return NULL;
    }
    if(i > length(head)){
        return NULL;
    }

    int count = 1;
    Node* copyHead = head;

    while(count <= i && head){
        head = head->next;
        count++;
    }

    if(head){
        return head->data;
    }
    return head->data;
}

Node* insertAtTail(Node*  head){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* currNode = NULL;
    while(data != -1){
        Node* n = new Node(data);
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            n->next = head;
            head = n;
        }
        cin>>data;
    }
    return head;

}

Node* insert(Node* head){
    int data;
    cin>>data;  
    Node* head = NULL;
    Node* currNode = NULL;
    while(data != -1){
        Node* n = new Node(data);
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            currNode->next = n;
            currNode = n;
        }
        cin>>data;
    }
    return head;
}

void print(Node* head){

    Node* curr = head;
    while(curr != NULL){
        cout<<curr->data<<" ";
        curr = curr->next;
    }
    return ;
}

[1,3,4,5,2];

class Node{

    public:
        int data;
        Node* next;


        Node(int data){
            this->data = data;
            this->next = NULL;
        }
};

bool isPalindrome(Node* head){

    Node* slow = head;
    Node* fast = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    Node* reversed = NULL;
    while(slow != NULL){
        Node* n = slow->next;
        slow->next = reversed;
        reversed = slow;
        slow = n;
    }

    while(reversed != NULL){
        if(head->val != reversed->val) return false;
        head = head->next;
        reversed = reversed->next;
    }

    return true;
}

Node* oddEvenList(Node* head){

    Node* even = head->next;
    Node* odd = head;
    Node* even_start = head-next;

    while(event->next && odd->next){
        odd->next = even->next;
        even->next = odd->next->next;

        odd = odd->next;
        even = even->next;
    }

    odd->next = even_start;
    return head;
    
}


bool checkIfThereIsCycle(Node* head){

    if(head == NULL && head->next == NULL) return false;

    Node* slow = head,*fast = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next;

        if(slow == fast) return true;
    }

    return false;
}

Node* returnCycleNode(Node* head){

    Node* slow = head;
    Node* fast = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next;

        if(slow == fast) break;
    }

    if(!(fast && fast->next)) return NULL;

    while(head != slow){
        slow = slow->next;
        head = head->next;
    }

    return head;

    
}


class LRU{
    public:
        
        map<int,int> mp;
        list<int> ls;
        int cp;
        LRU(int capacity){
            cp = capacity;
            ls.clear();
            mp.clear();
        }

        int get(int key){

            if(mp.find(key) == mp.end()){
                return -1;
            }

            ls.remove(key);
            ls.push_front(key);
            return mp[key];
        }

        void push(int key,int value){
            if(mp.find(key) == mp.end()){
                
                if(cp == ls.size()){
                    int hel = ls.back();
                    ls.pop_back();
                    mp.erase(hel);
                }

                ls.push_front(key);
                mp[key] = value;

            }else{

                ls.remove(key);
                ls.push_front(key);
                mp[key] = value;
            }
        }
}

TreeNode* rightMost(TreeNode* root){
    if(root->right == NULL) return root;
    return rightMost(root->right);
}

void flatten(TreeNode* root){

    if(root == NULL) return ;

    TreeNode* rightMost = NULL;
    TreeNode* nextRight = NULL;
    while(root){

        if(root->left){
            rightMost = rightMost(root->left);
            nextRight = root->right;
            root->right = root->left;
            root->left = NULL;
            rightMost->right = nextRight;
        }

        root = root->right;
    }
}

void sortList(Node* head){
    if(head == NULL) return ;

    int count[] = {0,0,0};
    Node* ptr = head;
    while(ptr){
        count[ptr->data]++;
        ptr = ptr->next;
    }

    int i = 0;

    ptr = head;
    while(ptr){
        if(count[i] == 0){
            ++i
        }else{
            ptr->data = i;
            --count[i];
        }
        ptr = ptr->next;
    }
}


Node* mergeTwoList(Node* a,Node* b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    Node* newHead = NULL;
    if(a->val < b->val){
        newHead = a;
        newHead->next = mergeTwoList(a->next,b);
    }else{
        newHead = b;
        newHead->next = mergeTwoList(a,b->next);
    }

    return newHead;
}

void sortList(Node* head){
    if(head == NULL || head->next == NULL) return head;

    Node* slow = head;
    Node* fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    Node* n = slow->next;
    slow->next = NULL;

    Node* a = sortList(n);
    Node* b = sortList(head);

    head = mergeTwoList(a,b);

    return head;
}

bool ifCycle(Node* head){

    if(head == NULL || head->next == NULL) return false;

    Node* slow = head;
    Node* fast = head;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;

        if(slow == fast) return true;
    }
    return false;
}


Node* intersectionPoint(Node* a,Node* b){

    Node* ptr1 = a;
    Node* ptr2 = b;

    while(ptr1 != ptr2){
        if(ptr1 == NULL){
            ptr1 = b;
        }else{
            ptr1 = ptr1->next;
        }

        if(ptr2 == NULL){
            ptr2 == a;
        }else{
            ptr2 = ptr2->next;
        }
    }
    return ptr1;
}

void reverseList(Node* head){

    Node* prev = NULL;
    Node* curr = head;

    while(curr){
        Node* n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }
    return prev;
}


bool isPalindrome(Node* head){

    if(head == NULL || head->next == NULL){
        return true;
    }

    Node* reversed = NULL;
    Node* curr = head;
    while(curr){
        Node* n = curr->next;
        curr->next = reversed;
        prev = curr;
        curr = n;
    }

    while(reversed){
        if(head->val != reversed->val) return false;
        head = head->next;
        reversed = reversed->next;

    }
    return true;
}


Node* odd_even_list(Node* head){

    if(head == NULL || head->next == NULL) return head;

    Node* odd = head;
    Node* even = head->next;
    Node* even_start = head->next;

    while(odd->next && even->next){
        odd->next = even->next;
        even->next = odd->next->next;

        odd = odd->next;
        even = even->next;
    }

    odd->next = even_start;
    return head;
}


void deleteWithoutHead(Node* node){

    node->val = node->next->val;
    Node* n = node->next;
    node->next = node->next->next;
    n->next = NULL;
    delete n;

}

class LRU{
    public :
        map<int,int> mp;
        list<int> ls;
        int cp;

        LRU(int capacity){
            ls.clear();
            mp.clear();
            cp = capacity;
        }

        int get(int key){
            if(mp.find(key) == mp.end()){
                return -1;
            }

            ls.remove(key);
            ls.push_front(key);
            return mp[key];
        }

        void put(int key,int value){
            if(mp.find(key) == mp.end()){

                if(cp == ls.size()){
                    int k = ls.back();
                    ls.pop_back();
                    mp.erase(k);
                }
                ls.push_front(key);
                mp[key] = value;
            }else{
                ls.remove(key);
                ls.push_front(key);
                mp[key] = value;
            }
        }

        void put(int key,int value){

            if(mp.find(key) == mp.end()){

                if(cp = ls.size()){
                    int last = ls.back();
                    ls.pop_back();
                    mp.erase(back);
                }
                ls.push_front(key);
                mp[key] = value;
            }else{
                ls.remove(key);
                ls.push_front(key);
                mp[key] = value;
            }
        }
}


void removeKthNode(Node* head,int k){
    Node* first = head;
    Node* second = head;

    while(k--){
        second = second->next;
    }

    if(second == NULL){
        return first->next;
    }

    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }

    first->next = first->next->next;

    return head;
}


ListNode* addTwoNumbers(Node* l1,Node* l2){


    Node* dummy = new ListNode();
    Node* temp = dummy;

    int carry = 0;
    
    while(l1 || l2 || carry){
        int sum = 0;

        if(l1){
            sum += l1->val;
            l1 = l1->next;
        }

        if(l2){
            sum += l2->val;
            l2 = l2->next;
        }

        
        sum += carry;
        carry = sum/10;
        Node* n = new Node(sum%10);

        temp->next = n;
        temp = temp->next;
    }    

    return dummy->next;
}

int partition(int arr[],int s,int e){
    int pivot = arr[e];
    int j = s;
    for(int i = s;i < e;i++){
        if(arr[i] < pivot){
            swap(arr[j],arr[i]);
            j++;
        }
    }
    swap(arr[j],arr[e]);
    return j;
}

void quickSort(int arr[],int s,int e){
    if(s >= e){
        return ;
    }

    int p = partition(arr,s,e);
    quickSort(arr,s,p-1);
    quickSort(arr,p+1,e);
}


int partition(int arr[],int s,int e){
    if(s >= e){
        return ; 
    }
    int j = s;
    int pivot = arr[e];
    for(int i = s;i < e;i++){
        if(arr[i] < pivot){
            swap(arr[i],arr[j]);
            j++;
        }
    }

    swap(arr[e],arr[j]);
    return j;
}

void quickSort(int arr[],int s,int e){
    if(s >= e){
        return ;
    }

    int p = partition(arr,s,e);
    quickSort(arr,s,p-1);
    quickSort(arr,p+1,e);
}

vector<int> subArraySum(int arr[],int n,int s){
    int l = 0,r = 0,sum = 0;
    vector<int> ans;
    while(r <= n){

        if(sum < s){
            sum += arr[r++];
        }else if(sum == s){
            ans.push_back(l+1);
            ans.push_back(r);
            return ans;
        }else{
            sum -= arr[l++];
        }
    }

    return {-1};
}


int countSubArrayWithGivenSumK(vector<int> &arr, int k){
    int preSum = 0;
    map<int,int> mp;
    mp[0] = 1;
    int cnt = 0;
    int n = arr.size();

    for(int i = 0;i < n;i++){
        preSum += arr[i];

        int remove = preSum - k;
        cnt += mp[remove];

        mp[preSum] += 1;
    }

    return cnt;
    
}

vector<int> longestSubarrayWithGivenSumK(vector<int> &arr, int k){

    int left = 0;
    int right = 0;
    int maxLength = 0;
    int n = arr.size();
    int sum = arr[0];

    while(right < n){

        if(left <= right && sum > k){
            sum -= arr[left];
            left++;
        }

        if(sum == k){
            maxLength = max(maxLength, right-left+1);        
        }

        right++;
        if(right < n) sum += arr[right];
    }

    return maxLength;
}


vector<int> printLeaders(vector<int> &arr){
    int n = arr.size();
    int max = arr[n-1];
    vector<int> ans;
    ans.push_back(arr[n-1]);

    for(int i = n-2; i >=0;i--){
        if(arr[i] > max){
            ans.push_back(arr[i]);
            max = arr[i];
        }
    }

    return ans;

}


































