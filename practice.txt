class Solution{
    public :
         ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
             if(l1 == NULL) return l2;
             if(l2 == NULL) return l1;


            ListNode* finalHead = NULL;
             if(l1-> val < l2->val){
                finalHead = l1;
                l1 = l1->next;
             }else{
                 finalHead = l2;
                 l2 = l2->next;
             }

             ListNode* p = finalHead;
             while(l1 && l2){
                 if(l1->val < l2->val){
                     p->next = l1;
                     l1 = l1->next;
                 }else{
                     p->next = l2;
                     l2 = l2->next;
                 }
                 p = p->next;
             }
            if(l1){
                p->next = l1;
            }else{
                p->next = l2;
            }
            return finalHead;
         }

         ListNode* sortList(ListNode* head) {
             if(head == NULL ) return head;
             ListNode* slow= head;
             ListNode* fast = head->next;
            while(fast && fast->next){
                slow = slow->next;
                fast = fast->next->next;
            }
             if(fast){
                ListNode* n = slow->next;
                slow->next = NULL;
             }else{
                 ListNode* n = slow;
                 slow = NULL;
             }
             ListNode* a = sortList(head);
             ListNode* b = sortList(n);
            head = mergeTwoLists(a,b);            
            return head;

         }
        ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
            if(l1 == NULL) return l2;
            if(l2 == NULL) return l1;
            ListNode* finalHead = NULL;
            if(l1->val < l2->val){
                finalHead = l1;
                finalHead->next = mergeTwoLists(l1->next,l2);
            }else{
                finalHead = l2;
                finalHead->next = mergeTwoLists(l1,l2->next);
            }
            return finalHead;
        }

}


template<typename T>
class Stack{
    T *arr;
    int nextIndex;
    int capacity;
    public :
        Stack(){
            capacity = 5;
            arr = new T[capacity];
            nextIndex = 0;
        }
        int size(){
            return nextIndex;
        }
        bool isEmpty(){
            return nextIndex == 0;
        }
        T top(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return -1;
            }
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }
            nextIndex--;
        }
        void push(T element){
            if(capacity == nextIndex){
                int *newArr = new T[capacity*2];
                for(int i = 0;i < nextIndex;i++){
                    newArr[i] = arr[i];
                }
                delete []arr;
                arr = newArr;
                capacity = 2*capacity;
            }
            arr[nextIndex] == element;
            nextIndex++;
        }
}

template<typename T>
class Node{
    public :
        T data;
        Node<T> *next;
        Node(T element){
            this->data = element;
            this->next = NULL;
        }
}

template<typename T>
class Stack{
    int size = 0;
    Node<T> *head;
    public :
        Stack(){
            head = NULL;
            size = 0;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size==0;
        }
        void push(T element){
            Node<T> *n = new Node<T>(element);
            n->next = head;
            head = n;
            size++;
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return ;
            }
            Node<T> *temp = head;
            head = head->next;
            temp->next = NULL;
            delete temp;
            size--;
        }
        T top(){
            if(isEmpty()){
                cout<<"Stack is empty"<<endl;
                return 0;
            }
            return head->data;
        }
}


bool isValid(String a){
    stack<char> c;
    for(int i = 0;i < a.size();i++){
        if(a[i] == '(' || a[i] == '{' || a[i] == '[' ){
            c.push(a[i]);
        }else{
            if(s.empty()){
                return false;
            }else if(a[i] == ')'){
                if(s.top() == a[i]){
                    s.pop();
                }else{
                    return false;
                }
            }else if(a[i] == '}'){
                if(s.top() == a[i]){
                    s.pop();
                }else{
                    return false;
                }
            }else if(a[i] == ']'){
                if(s.top() == a[i]){
                    s.pop();
                }else{
                    return false;
                }
            }
        }
    }
}

int evalRPN(vector<string> &tokens){
    stack<int> st;
    for(int i = 0;i < tokens.size();i++){
        if(tokens[i] == "+" ||tokens[i] == "-" ||tokens[i] == "*" ||tokens[i] == "/"){
            int v1 = st.top();
            st.pop();
            int v2 = st.top();
            st.pop();
            if(tokens[i] == "+"){
                st.push(v2+v1);
            }else if(tokens[i] == "-"){
                st.push(v2-v1);
            }else if(tokens[i] == "*"){
                st.push(v2*v1);
            }else if(tokens[i] == "/"){
                st.push(v2/v1);
            }
        }else{
            st.push(atoi(tokens[i].c_str()));
        }
    }
    return st.top();
}


string removeAdj(string A){
    stack<char> a;
    for(int i = 0;i < A.size();i++){
        if(a.empty() || a.top() != A[i]){
            a.push(A[i])
        }else{
            a.pop();
        }
    }
    string ans = "";
    while(!s.empty()){
        ans.push_back(a.top());
        a.pop();
    }
    reverse(ans.begin(),ans.end());
    return ans;
}


string removeAdj(string A){
    int stkptr = -1;
    for(int i = 0;i < A.size();i++){
        if(stkptr == -1 || A[stkptr] != A[i]){
            stkptr++;
            A[stkptr] = A[i];
        }else{
            stkptr--;
        }
    }
    string ans = "";
    for(int i = 0;i <= stkptr;i++){
        ans.push_back(A[i]);
    }
    return ans;
}


int partition(int a[],int s,int e){
    int i = s;
    int pivot = a[e];
    for(int j = s;j <= e-1;j++){
        if(a[j] < pivot){
            swap(a[j],a[i]);
            i++;
        }
    }
    swap(a[e],a[i]);
    return i;
}
void quickSort(int a[],int s,int e){
    if(s >= e){
        return ;
    }
    int p = partition(a,s,e);
    quickSort(a,s,p-1);
    quickSort(a,p+1,e);
}

void printPermu(char name[],int i = 0){
    if(name[i] == '\0'){
        cout<<name;
        return ;
    }
    for(int j = i; name[j] != '\0' ;j++){
        swap(name[i],name[j]);
        printPermu(name,i+1);
        swap(name[i],name[j]);
    }
}
class Node{
    public : 
    int data;
    Node *next;
    
    Node(int data){
        this->data = data;
        next = NULL;
    }
}
void print(Node *head){
    if(head == NULL) return ;

    Node *temp = head;
    while(temp){
        cout<<temp->data<<endl;
        temp = temp->next;
    }
}
void takeInput2(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* tail = NULL;
    while(data != -1){
        Node *n = new Node(data);
        if(head == NULL){
            head = n;
            tail = n;
        }else{
            n->next = head;
            head = n;
        }
        cin>>data;
    }
    return head;
}
int length(Node * head){
    if(head == NULL) return ;

    int count = 0;
    Node *temp = head;
    while(temp != NULL){
        count++;
        temp = temp->next;
    }
    return count;
}

void printIthNode(Node * head){
    if(head == NULL) return ;

    Node *temp = head;
    int count = 1;
    while(count <= i && temp != NULL){
        temp = temp->next;
        count++;
    }
    if(temp){
        cout<<temp->data;
    }else{
        cout<<"-1";
    }
}

void insertAtIthPos(Node* head,int data,int i){
    if(head == NULL) return ;

    Node *temp = head;
    int count = 1;
    if(i == 0){
        Node *n = new Node(data);
        n->next = head;
        head = n;
        return head;
    }
    while(count < i && temp != NULL){
        temp=temp->next;
        count++;
    }
    if(temp){
        Node *n = new Node(data);
        Node *hello = temp->next;
        temp->next = n;
        n->next = hello;
        return head;
    }
}

void deleteIthNode(Node *head,int i){
    if(head == NULL) return ;

    int count = 1;
    Node *temp = head;
    if(i == 0){
        Node *hello = head->next;
        head = head->next;
        hello->next = NULL;
        delete hello;
        return head;
    }
    while(count < i && temp != NULL){
        temp = temp->next;
        count++;
    }
    if(temp && temp->next){
        Node *hello = temp->next;
        temp->next = temp->next->next;
        hello->next = NULL;
        delete hello;
        return head;
    }
}

int length2(Node *head){
    if(head == NULL) return 0;

    int small = length2(head->next);
    return small+1;
}
bool isPresent(Node *head,int data){
    if(head == NULL) return false;
    if(head->data == data) return true;
    return isPresent(head->next,data);
}

int middleLL(Node *head){
    if(head == NULL) return -1;

    Node *slow = head;
    Node *fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    if(fast){
        return slow->next->data;
    }else{
        return slow->data;
    }
}

Node* removeKthNode(Node *head , int k){
    if(head == NULL) return NULL;

    Node *first = head;
    Node *second = head;
    while(k--){
        second = second->next;
    }
    if(second == NULL){
        return first->next;
    }
    while(second->next != NULL){
        first = first->next;
        second = second->next;
    }
    first->next = first->next->next;
    return head;
}

Node *reverseLL(Node *head){
    if(head == NULL) return ;

    Node *prev = NULL;
    Node *curr = NULL;
    
    while(curr != NULL){
        Node *n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;   
    }

    return prev;

}
void takeInput(){
    int data;
    cin>>data;
    Node* head = NULL;
    Node* currNode = NULL;
    while(data != -1){
        Node *n = new Node(data);
        if(head == NULL){
            head = n;
            currNode = n;
        }else{
            currNode->next = n;
            currNode = n;
        }
        cin>>data;
    }
    return head;
}

listNode* mergeList(listNode *a , listNode *b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    listNode *finalHead = NULL;
    if(a->val < b->val){
        finalHead = a;
        finalHead->next = mergeList(a->next,b);
    }else{
        finalHead = b;
        finalHead->next = mergeList(a,b->next);
    }
    return finalHead;
}

listNode* sortList(listNode *head){
    if(head == NULL) return NULL;

    listNode *slow = head;
    listNode *fast = head->next;

    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }

    listNode *n = slow->next;
    slow->next = NULL;
    
    listNode *a = sortList(head);
    listNode *b = sortList(n);

    head = mergeTwoLists(n,head);
    return head;
    
}


int partition(int a[],int s,int e){
    int i = s;
    int pivot = a[e];
    for(int j = s;j <= e-1;j++){
        if(a[j] < pivot){
            swap(a[j],a[i]);
            i++;
        }
    }
    swap(a[i],a[e]);
    return i;
}

void quickSort(int a[],int s,int e){
    if(s >= e){
        return ;
    }
    int i = partition(a,s,e);
    quickSort(a,s,p-1);
    quickSort(a,p+1,e);
    
}

class Queue{
    public :
        int nextIndex = 0;
        int firstIndex = -1;
        int capacity = 0;
        int size = 0;
        int *arr;

        Queue(){
            nextIndex= 0;
            firstIndex = -1;
            capacity = 0;
            size = 0;
            arr = new int[5];
        }

        Queue(int cap){
            nextIndex= 0;
            firstIndex = -1;
            capacity = cap;
            size = 0;
            arr = new int[cap];
        }

        int getSize(){
            return size;
        }
        
        bool isEmpty(){
            return size == 0;
        }

        void push(int element){
            if(size == capacity){
                int *newArr  =  new int[2*capacity];
                int j = 0;
                for(int i = firstIndex;i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0;i < firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                firstIndex = 0;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex = (nextIndex+1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
        }

        void pop(){
            if(isEmpty()){
                cout<<"Queue is empty"<<endl;
                return ;
            }
            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }

        int front(){
            if(isEmpty()){
                cout<<"queue is empty"<<endl;
                return -1;
            }
            return arr[nextIndex - 1];
            

        }
}


class Queue{
    int nextIndex;
    int firstIndex;
    int capacity;
    int size;
    int *arr;
    Queue(){
        arr = new int[5];
        firstIndex = -1;
        nextIndex = 0;
        capacity = 5;
        size = 0;
    }
    Queue(int c){
        arr = new int[c];
        firstIndex = -1;
        nextIndex = 0;
        capacity = c;
        size = 0;
    }

    bool isEmpty(){
        return size == 0;
    }
    int getSize(){
        return size;
    }
    void push(int elem){
        if(size == capacity){
            cout<<"Queue is full"<<endl;
            return ;
        }
        arr[nextIndex] = elem;
        nextIndex = (nextIndex+1)%capacity;
        if(firstIndex == -1){
            firstIndex = 0;
        }
        size++;
    }
    void pop(){
        if(isEmpty()){
            cout<<"Queue is empty"<<endl;
            return ;
        }
        firstIndex = (firstIndex+1)%capacity;
        size--;
        if(size == 0){
            firstIndex = -1;
            nextIndex = 0;
        }
    }
    int front(){
        if(isEmpty()){
            cout<<"Queue is empty"<<endl;
            return -1;
        }
        return arr[firstIndex];
    }
}

int partition(int arr[],int s,int e){
    int i = s;
    int pivot = arr[e];
    for(int j = s;j <= e-1;j++){
        if(a[j] < pivot){
            swap(a[j],a[i]);
            i++;
        }
    }
    swap(a[e],a[i]);
    return i ;
}
void quickSort(int arr[],int s,int e){
    if(s >= e){
        return ;
    }
    int p = partition(arr,s,e);
    quickSort(arr,s,p-1);
    quickSort(arr,p+1,e);
}

class Stack{
    int capacity;
    int nextIndex;
    int *arr;

    Stack(){
        capacity = 5;
        arr = new int[capacity];
        nextIndex = 0;
    }
    Stack(int c){
        capacity = c;
        arr = new int[capacity];
        nextIndex = 0;
    }

    int getSize(){
        return nextIndex;
    }

    bool isEmpty(){
        return nextIndex == 0;
    }
    void push(int element){
        if(nextIndex == capacity){
            cout<<"Stack is full";
            return ;
        }
        arr[nextIndex] = element;
        nextIndex++;
    }
    void pop(){
        if(isEmpty()){
            cout<<"Stack is empty"<<endl;
            return ;
        }
        nextIndex--;
    }
    int top(){
        if(isEmpty()){
            cout<<"Stack is empty"<<endl;
            return 0;
        }
        return arr[nextIndex -1];
    }

}


tree practice from here

template<typename T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> children;

        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(){
            for(int i = 0;i < children.size();i++){
                delete children[i];
            }
        }
}

TreeNode* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    TreeNode<int> *root = new TreeNode<int>(rootData);
    if(root == -1){
        return NULL;
    }
    int numChild;
    cout<<"Enter number of child of "<<rootData<<" : ";
    cin>>numChild;
    for(int i = 1;i <= numChild;i++){
        TreeNode<int>* child = takeInput();
        root->children.push_back(child);
    }
    return root;
}

TreeNode* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root Data : ";
    cin>>rootData;
    TreeNode<int> *root = new TreeNode<int>(rootData);
    queue<TreeNode<int>*> q;
    q.push(root);

    while(!q.empty()){
        TreeNode<int>* front = q.front();
        q.pop();
        int numChild;
        cout<<"Enter number of child for "<<front->data<<" : ";
        cin>>numChild;
        int childData;
        for(int i = 1;i <= numChild;i++){
            cout<<"Enter "<<i<<"th child data : ";
            cin>>childData;
            TreeNode<int> *child = TreeNode<int>(childData);
            front->children.push_back(child);
            q.push(child);
        }
    }
    return root;
}

void print(TreeNode<int>* root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<" , ";
    }
    for(int i = 0;i < root->children.size();i++){
        print(root->children[i]);
    }
}

int countNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int count = 1;
    for(int i = 0;i < root->children.size();i++){
        count += countNode(root->children[i]);
    }
    return count;
}

void printLevelWise(TreeNode<int>* root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int>* front= q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->children.size();i++){
            cout<<front->children[i]->data<<", ";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

int getFirst(vector<int> &nums,int target){
    int s = 0;
    int e = nums.size() -1;
    int ans = 0;
    while(s <= e){
        int mid = (s+e)/2;
        if(nums[mid] == target){
            ans = mid;
            e = mid-1;
        }else if(nums[mid] < target){
            s = mid+1;
        }else{
            end = mid-1;
        }
    }
    return ans;
}

int searchMajority(vector<int> &a){
    int cand = a[0];
    int count = 1;
    int n = a.size();
    for(int i = 1;i < a.size();i++){
        if(a[i] == cand){
            count++;
        }else{
            count--;
            if(count == 0){
                cand = a[i];
                count = 1;
            }
        }
    }
    int count2 = 0;
    for(int i = 0;i < a.size();i++){
        if(cand == a[i]){
            count2++;
        }
    }
    if(count2 >= n/2){
        return cand;
    }else{
        return -1;
    }
}
int mySearch(vector<int> &a , int key){
    int s = 0;
    int e = a.size() -1;
    int n = a.size();
    while(s >= e){
        int mid = (s+e)/2;
        if(a[mid] == key){
            return  mid;
        }else if(a[s] <= a[mid]){
            if(key >= a[s] && key <= mid){
                e = mid-1;
            }else{
                s = mid+1;
            }
        }else{
            if(key >= a[mid] && key <= a[e]){
                s = mid+1;
            }else{
                e = mid-1;
            }
        }
    }
    return -1;   
}

int removeDuplicates(vector<int> &a){
    int n = a.size();
    int pos = 0;
    for(int i = 0;i < n-1;i++){
        if(a[i] != a[i+1]){
            a[++pos] = a[i+1];
        }
    }
    return pos+1;
}

int height(TreeNode* root){
    if(root == NULL){
        return 0;
    }
    int mx = 0;
    for(int i = 0;i <root->children.size();i++){
        mx = max(mx,height(root->children[i]));
    }
    return mx+1;
}

void printAtLevelK(TreeNode* root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data;
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k-1);
    }
}

Node* reverseLL(Node* head){
    if(head == NULL){
        return NULL;
    }
    Node *curr = head;
    Node *prev = NULL;  
    while(curr != NULL){
        Node *n = curr->next;
        curr->next = prev;
        prev = curr;
        curr = n;
    }
    return prev;
}

Node* mergeList(Node *a,Node *b){
    if(a == NULL) return b;
    if(b == NULL) return a;

    Node *copyhead = NULL;
    if(a->data < b->data){
        copyhead = a;
        copyhead->next = mergeList(a->next,b);
    }else{
        copyhead = b;
        copyhead->next = mergeList(a,b->next);
    }
    return copyhead;
}

Node* sortList(Node *a){
    if(a == NULL) return NULL;

    Node *slow = a;
    Node *fast = a->next;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
    }
    Node *n = slow->next;
    slow->next = NULL;

    Node *hel = sortList(n);
    Node *wor = sortList(a);
    
}
int countLeafNode(TreeNode* root){
    if(root == NULL){
        return 0;
    }
    if(root->children.size() == 0){
        return 1;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNode(root->children[i]);
    }
    return ans+1;
}

void preOrder(TreeNode* root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<endl;
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }
}
void postOrder(TreeNode* root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        postOrder(root->children[i]);
    }
    cout<<root->data<<endl;
}

void deleteTree(TreeNode *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        delete root->children[i];
    }
    delete root;
}

template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;

        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }

        ~BTNode(){
            delete left;
            delete right;
        }
}
void printBTreeRecursive(BTNode *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    if(root->left != NULL){
        cout<<root->left->data<<", ";
    }
    if(root->right != NULL){
        cout<<root->right->data;
    }
    cout<<endl;
    printBTreeRecursive(root->left);
    printBTreeRecursive(root->right);
    
}

void printBTreeLevelWise(TreeNode* root){
    if(root == NULL){
        return ;
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        cout<<front->left->data<<", ";
        cout<<front->right->data<<;
        cout<<endl;
        q.push(front->left);
        q.push(front->right);
    }
}

BTNode* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = takeInput();
    root->right = takeInput();
    return root;
}

BTNode* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = new BTNode<int>(rootData);
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int>* front = q.front();
        q.pop();
        cout<<"Enter left data for <<front->data<<" : ";
        int leftData;
        cin>>leftData;
        if(leftData != -1){
            BTNode<int> *left = new BTNode<int>(leftData);
            front->left = left;
            q.push(left);
        }
        cout<<"Enter right data for <<front->data<<" : ";
        int rightData;
        cin>>rightData;
        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            front->right = right;
            q.push(right);
        }
    }
    cout<<endl;
    return root;
}

bool searchNode(BTNode<int> *root,int key){
    if(root == NULL){
        return false;
    }
    if(root->data == key){
        return true;
    }
    return (searchNode(root->left,key) || searchNode(root->right,key) );
}

int minValue(BTNode<int>* root){
    if(root == NULL){
        return INT_MAX;
    }
    int leftMin = minValue(root->left);
    int rightMin = minValue(root->right);
    return min(root->data,min(leftMin,rightMin));
}
int maxValue(BTNode<int>* root){
    if(root == NULL){
        return INT_MIN;
    }
    int leftMax = maxValue(root->left);
    int rightMax = maxValue(root->right);
    return max(root->data,max(leftMax,rightMax));
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right) ;
}
template<typename T>
class TreeNode{
    public :
    T data;
    vector<TreeNode<T>*> children;
    TreeNode(T data){
        this->data = data;
    }
    ~TreeNode(){
        for(int i = 0;i < children.size();i++){
            delete children[i];
        }
    }
}

void printRecursive(TreeNode* root){
    if(root == NULL) return ;

    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<", ";
    }
    cout<<endl;
    for(int i =0 ;i< root->children.size();i++){
        printRecursive(root->children[i]);
    }
}

TreeNode<int>* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        TreeNode<int>* root = new TreeNode<int>(rootData);
    }
    int numChildren;
    cout<<"Enter number of children of "<<rootData;
    cin>>numChildren;

    for(int i = 1;i <= numChildren;i++){
        TreeNode<int> *child = takeInput();
        root->children.push_back(child);
    }
    return root;
}
int countNodes(TreeNode<int>* root){
    if(root == NULL) return 0;
    ans = 1;
    for(int i = 0;i < root->children.size();i++){
        ans += countNode(root->children[i]);
    }
    return ans+1;
}

void printLevelWise(TreeNode<int>* root){
    if(root == NULL) return ;
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->children.size();i++){
            cout<<front->children[i]->data<<" ,";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

int height(TreeNode<int>* root){
    if(root == NULL) return 0;

    int mx = 0;
    for(int i = 0;i < root->children.size();i++){
        mx = max(mx,root->children[i]);
    }
    return mx+1;
}

void printAtLevelK(TreeNode<int>* root,int k){
    if(root == NULL) return ;
    if(k == 0){
        cout<<root->data<<endl;
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k-1);
    }
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL) return 0;
    if(root->children.size() == 0){
        return 1;
    }
    ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNode(root->children[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL) return ;
    cout<<root->data;
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL) return ;
    for(int i = 0;i < root->children.size();i++){
        deleteTree(root->children[i]);
    }
    delete root;
}

template<typname T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> children;
        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(){
            for(int i = 0;i < children.size();i++){
                delete children[i];
            }
        }
}

void print(TreeNode<int>* root){
    if(root == NULL) return ;
    cout<<root->data<<" : ";
    for(int i = 0;i < root->children.size();i++){
        cout<<root->children[i]->data<<" ";
    }
    cout<<endl;
    for(int i = 0;i < root->children.size();i++){
        print(root->children[i]);
    }
}
TreeNode<int>* takeInput(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    TreeNode<int> *root = new TreeNode<int>(rootData);
    cout<<"Enter number of childrens for "<<rootData<<" : ";
    int numChild;
    cin>>numChild;
    for(int i = 0;i < numChild;i++){
        TreeNode<int> *child = takeInput();
        root->children.push_back(child);
    }
    return root;
}
TreeNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    TreeNode<int> *root = new TreeNode<int>(rootData);
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        int numChild;
        cout<<"Enter num of child of "<<front->data<<" : ";
        cin>>numChild;
        for(int i = 0;i < numChild;i++){
            int childData;
            cout<<"Enter "<<i<<"th child of <<front->data<<" : ";
            cin>>childData;
            TreeNode<int> *child = new TreeNode<int>(childData);
            front->children.push_back(child);
            q.push(child);
        }
    }
    return root;
}

int countNodes(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countNodes(root->children[i]);
    }
    return small+1;
}

void printLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int>* front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->children.size();i++){
            cout<<front->children[i]->data<<", ";
            q.push(front->children[i]);
        }
        cout<<endl;
    }
}

int height(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans = max(ans,height(root->children[i]));
    }
    return ans+1;
}

void printAtLevelK(TreeNode<int> *root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data<<endl;
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        printAtLevelK(root->children[i],k-1);
    }
}

int countLeafNodes(TreeNode<int>* root){
    if(root == NULL){
        return 0;
    }
    if(root->children.size() == 0){
        return 1;
    }
    int ans = 0;
    for(int i = 0;i < root->children.size();i++){
        ans += countLeafNodes(root->children[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" ";
    for(int i = 0;i < root->children.size();i++){
        preOrder(root->children[i]);
    }
}
void postOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->children.size();i++){
        postOrder(root->children[i]);
    }
    cout<<root->data<<" ";
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL) return ;

    for(int i = 0;i < root->children.size();i++){
        delete root->children[i];
    }
    delete root;
}

template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
        ~BTNode(){
            delete left;
            delete right;
        }
}

void printBTreeRecursive(BTNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : L "<<root->left->data<<" R "<<root->right->data;
    cout<<endl;
    printBTreeRecursive(root->left);
    printBTreeRecursive(root->right);
}

void printBTreeLevelWise(BTNode<int> *root){
    if(root == NULL) return ; 
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : "<<"L "<<front->left->data<<" R "<<front->right->data;
        q.push(front->left);
        q.push(front->right);
    }
    cout<<endl;
}

BTNode<int>* takeInputRecursive(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        BTNode<int> *root = new BTNode<int>(rootData);
        root->left = takeInputRecursive();
        root->right = takeInputRecursive();
    }else{
        return NULL;
    }
    return root;
}


BTNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        BTNode<int> *root = new BTNode<int>(rootData);
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left data for "<<front->data<<" : ";
        cin>>leftData;
        if(leftData != -1){
            BTNode<int> *left = new BTNode<int>(leftData);
            front->left = left;
            q.push(left)
        }
        int rightData;
        cout<<"Enter right data for "<<front->data<<" : ";
        cin>>rightData;
        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            front->right = right;
            q.push(right)
        }
    }
    cout<<endl;
    return root;
}

bool searchNode(BTNode<int> *root,int key){
    if(root == NULL) return false;
    if(root == key) return true;
    return searchNode(root->left,key) || searchNode(root->right,key);
}


int minValue(BTNode<int> *root){
    if(root == NULL){
        return INT_MAX;
    }
    return min(root->data,min(minValue(root->right),minValue(root->left)));
}

int countLeafNode(BTNode<int> *root){
    if(root == NULL) return -1;
    if(root->left == NULL && root->right == NULL ){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right); 
}

template<typename T>
class Queue{
    public :
        T *arr;
        int nextIndex = 0;
        int firstIndex = -1;
        int size;
        int capacity;
        Queue(){
            capacity = 5;
            arr = new T[capacity];
            size = 0;
            firstIndex = -1;
            nextIndex = 0;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size==0;
        }
        void push(T element){
            if(size == capacity){
                T *newArr = new T[2*capacity];
                int j = 0;
                for(int i = firstIndex;i < capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0;i < firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                firstIndex = 0;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex = (nextIndex + 1)%capacity;
            if(firstIndex == -1){
                firstIndex = 0
            }
            size++;
        }
        void pop(){
            if(isEmpty()){
                cout<<"queue is empty ";
                return ;
            }
            firstIndex = (firstIndex + 1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }
        T front(){
            if(isEmpty()){
                cout<<"queue is empty";
                return ;
            }
            return arr[firstIndex] ;
        }
}

template<typename T>
Class BTNode{
    T data;
    BTNode *left;
    BTNode *right;
    BTNode(int data){
        this->data = data;
        left = NULL;
        right = NULL;
    }
    ~BTNode(){
        delete left;
        delete right;
    }
}

BTNode<int>* takeInput(){
    int data;
    cout<<"Enter root value : ";
    cin>>data;
    if(data != NULL){
        BTNode<int>* root = new BTNode(data);
    }
    root->left = takeInput();
    root->right = takeInput();
    return root;
}

BTNode<int>* takeInputLevelWise(){
    int data;
    cout<<"Enter root data : ";
    cin>>data;
    if(data != NULL){
        BTNode<int> *root = new BTNode<int>(data);
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left data for "<<front->data<<" : ";
        cin>>leftData;
        if(leftData != NULL){
            front->left = BTNode<int>(leftData);
            q.push(front->left);
        }
        int rightData;
        cout<<"Enter right data for "<<front->data<<" : ";
        cin>>rightData;
        if(rightData != NULL){
            front->right = BTNode<int>(rightData);
            q.push(front->right);    
        }
    }
    cout<<endl;
    return root;
}

bool searchNode(BTNode<int> *root,int data){
    if(root == NULL){
        return false;
    }
    if(root->data == data){
        return true;
    }
    return searchNode(root->left) || searchNode(root->right);
}

int minValue(BTNode<int> *root){
    if(root == NULL){
        return INT_MAX;
    }

    return  min(root->data , min(minValue(root->left),minValue(root->right)));
}

int countLeafNode(BTNode<int>* root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right);
}

BTNode<int>* buildTreeHelper(vector<int> &inOrder,vector<int> &preOrder,int inS,int inE,int preS,int preE){
    if(inS > inE){
        return NULL;
    }   
    int rootData = preOrder[preS];
    int rootIndex = -1;
    for(int i = inS ; i <= inE;i++){
        if(inOrder[i] == rootData){
            rootIndex = i;
        }
    }

    int leftPreS = preS + 1;
    int leftPreE = leftPreS + leftInE - leftInS;
    int leftInS = inS;
    int leftInE = rootIndex -1;


    int rightPreS = leftPreE + 1;
    int rightPreE = preE;
    int rightInS = rootIndex+1;
    int rightInE = inE;

    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = buildTreeHelper(inOrder,preOrder,leftInS,leftInE,leftPreS,leftPreE);
    root->right = buildTreeHelper(inOrder,preOrder,rightInS,rightInE,rightPreS,rightPreE);
    return root;
}

BTNode<int>* buildTree(vector<int> &inorder,vector<int> &preorder){
    int n = inorder.size();
    BTNode<int>* root = buildTreeHelper(inorder,preorder,0,n-1,0,n-1);
}




#include<bits/stdc++.h>
template<typename T>
class TreeNode{
    public :
        T data;
        vector<TreeNode<T>*> child;
        TreeNode(T data){
            this->data = data;
        }
        ~TreeNode(){
            for(int i = 0;i < child.size();i++){
                delete child[i];
            }
        }
}

void printRecursive(TreeNode<int>* root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    for(int i = 0;i < root->child.size();i++){
        cout<<root->child[i]->data<<", ";
    }
    cout<<endl;
    for(int i = 0;i < root->child.size();i++){
        printRecursive(root->child[i]);
    }
}

void printLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        for(int i = 0;i < front->child.size();i++){
            cout<<front->child[i]->data<<", ";
            q.push(front->child[i]);
        }
        cout<<endl;
    }
}

TreeNode<int>* takeInputRecursive(){
    int data;
    cout<<"Enter data : ";
    cin>>data;
    if(data != -1){
        TreeNode<int> *root = new TreeNode<int>(data);
    }
    int n;
    cout<<"Enter number of child of "<<root->data;
    cin>>n;
    for(int i = 1;i <= n;i++){
        cout<<"Enter "<<i<<"th data of "<<root->data<<" : ";
        TreeNode<int> *children = takeInputRecursive();
        root->child.push_back(children);
    }
    return root;
}


TreeNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    if(rootData != -1){
        TreeNode<int> *root = new TreeNode<int>(rootData);
    }    
    queue<TreeNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        TreeNode<int> *front = q.front();
        q.pop();
        cout<<"Enter number of children of "<<front->data<<;
        int n;
        cin>>n;
        int childData;
        for(int i = 1;i <= n;i++){
            cout<<"Enter "<<i<<"th child data for "<<front->data;
            cin>>childData;
            if(childData != -1){
                TreeNode<int> *child = new TreeNode<int>(childData);
                q.push(child);
                front->child.push_back(child);
            }
        }
    }
    return root;
}

int countNodes(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    int ans = 0;
    for(int i = 0;i < root->child.size();i++){
        ans += countNodes(root->child[i]);
    }
    return ans+1;
}

int height(TreeNode<int>* root){
    if(root == NULL){
        return 0;
    }
    int mx = 0;
    for(int i = 0 ;i < root.child.size();i++){
        mx = max(mx,height(root->child[i]));
    }
    return mx+1;
}

void printAtLevelK(TreeNode<int> *root,int k){
    if(root == NULL){
        return ;
    }
    if(k == 0){
        cout<<root->data;
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        printAtLevelK(root->child[i],k-1);
    }
}

int countLeafNode(TreeNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->child.size() == 0){
        return 1;
    }
    int ans = 0;
    for(int i = 0;i < root->child.size();i++){
        ans += countLeafNode(root->child[i]);
    }
    return ans;
}

void preOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<", ";
    for(int i = 0;i < root->child.size();i++){
        preOrder(root->child[i]);
    }
}
void postOrder(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        preOrder(root->child[i]);
    }
    cout<<root->data<<", ";
}

void deleteTree(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    for(int i = 0;i < root->child.size();i++){
        delete root->child[i];
    }
    delete root;
}

template<typename T>
class BTNode{
    public :
        T data;
        BTNode *left;
        BTNode *right;
        BTNode(int data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
}

void printBTreeRecursive(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    cout<<root->data<<" : ";
    cout<<root->left->data<<","<<root->right->data;
    cout<<endl;
    printBTreeRecursive(root->left);
    printBTreeRecursive(root->right);
}


void printTreeLevelWise(TreeNode<int> *root){
    if(root == NULL){
        return ;
    }
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        cout<<front->data<<" : ";
        if(front->left != NULL){
            cout<<" L "<<front->left->data<<", ";
            q.push(front->left);
        }
        if(front->right != NULL){
            cout<<" R "<<front->right->data<<", ";
            q.push(front->right);
        }
        cout<<endl;
    }
}

BTNode<int> * takeInputRecursive(){
    int rootData ;
    cout<<"Enter data ";
    cin>>rootData;
    if(rootData == -1){
        return NULL;
    }
    BTNode<int> *root = BTNode<int>(rootData);
    root->left = takeInputRecursive();
    root->right = takeInputRecursive();
    return root;
}


BTNode<int>* takeInputLevelWise(){
    int rootData;
    cout<<"Enter root data : ";
    cin>>rootData;
    BTNode<int> *root = new BTNode<int>(rootData);
    queue<BTNode<int>*> q;
    q.push(root);
    while(!q.empty()){
        BTNode<int> *front = q.front();
        q.pop();
        int leftData;
        cout<<"Enter left data for "<<front->data;
        cin>>leftData;
        if(leftData != -1){
            BTNode<int> *left = new BTNode<int>(leftData);
            front->left = left;
            q.push(left);
        }
        int rightData;
        cout<<"Enter right data for "<<front->data;
        cin>>rightData;
        if(rightData != -1){
            BTNode<int> *right = new BTNode<int>(rightData);
            front->left = right;
            q.push(right);
        }
        cout<<endl;
    }
    return root;
}


bool searchNode(BTNode<int> *root,int key){
    if(root == NULL){
        return false;
    }
    if(root->data == key){
        return true;
    }
    return searchNode(root->left) || searchNode(root->right);
}

int minValue(TreeNode<int>* root){
    if(root == NULL){
        return INT_MAX;
    }
    return min(root->data,min(minValue(root->left),minValue(root->right)));
}

int countLeafNode(BTNode<int> *root){
    if(root == NULL){
        return 0;
    }
    if(root->left == NULL && root->right == NULL){
        return 1;
    }
    return countLeafNode(root->left) + countLeafNode(root->right) ;
}

// implementing BST

template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
}

class Pair{
    BTNode<int> *head;
    BTNode<int> *tail;
}

class BST{
    BTNode<int> *root;
    void printTree(BTNode<int> *root){
        if(root == NULL){
            return ;
        }
        cout<<root->data<<" : ";
        if(root->left != NULL){
            cout<<" L "<<root->left->data<<",";
        }
        if(root->right != NULL){
            cout<<" R "<<root->right->data<<;
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }   
    bool hasData(BTNode<int> *root,int data){
        if(root == NULL){
            return false;
        }
        if(root->data == data){
            return true;
        }
        if(root->data > data){
            return hasData(root->left);
        }else{
            return hasData(root->left)    
        }
    }
    BTNode<int>* insert(BTNode<int> *root , int data){
        if(root == NULL){
            BTNode<int> *n = new BTNode<int>(data);
            return n;
        }
        if(root->data < data){
            root->right = insert(root->right,data);
        }else{
            root->left = insert(root->left,data);
        }
        return root;
    }
    BTNode<int>* deleteData(BTNode<int>* root , int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data > data){
            return deleteData(root->left,data);
        }else if(root->data < data){
            return deleteData(root->right,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                delete root;
                return NULL;
            }else if(root->right == NULL){
                BTNode<int> *temp = root->left;
                root->left = NULL;
                delete root;
                return temp;
            }else if(root->left == NULL){
                BTNode<int> *temp = root->right;
                root->right = NULL;
                delete root;
                return temp;
            }else{
                int minNode = root->right;
                while(minNode->left != NULL){
                    minNode = minNode->left;
                }
                int rightMin = minNode->data;
                root->data = rightMin;
                root->right = deleteData(root->right,rightMin);
            }
        }
        return root;
    }
    Pair convertToLL(BTNode<int>* root){
        if(root == NULL){
            Pair ans ;
            ans.head = NULL;
            ans.tail = NULL;
            return ans;
        }
        if(root->right == NULL && root->left == NULL){
            Pair ans;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->right == NULL && root->left != NULL){
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;

        }else if(root->right != NULL && root->left == NULL){
            Pair rightLL = convertToLL(root->right);
            root->right = rightLL.head;
            Pair ans;
            ans.head = root;
            ans.tail = rightLL.tail;
            return ans;
        }else{
            Pair leftLL = convertToLL(root->left);
            Pair rightLL = convertToLL(root->right);
            leftLL.tail->right = root;
            root->right = rightLL.head;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }

}

TreeNode* buildTreeHelper(vector<int> &inorder , vector<int> &postOrder, int inS,int inE,int postS,int postE){
    if(inS > inE){
        return NULL;
    }

    int rootData = postOrder[postE];
    int rootIndex = -1;
    for(int i = inS,i <= inE;i++){
        if(inorder[i] == rootData){
            rootIndex = i;
            break ;
        }
    }

    int leftInS = inS;
    int leftInE = rootIndex -1;
    int leftPostS = postS;
    int leftPostE = leftPostS + leftInE - leftInS ;

    int rightInS = rootIndex + 1;
    int rightInE = inE;
    int rightPostS = leftPostE +1;
    int rightPostE = postE - 1;

    TreeNode* root = new TreeNode(rootData);
    root->left = buildTreeHelper(inorder,postOrder,leftInS,leftInE,leftPostS,leftPostE);
    root->right = buildTreeHelper(inorder,postOrder,rightInS,rightInE,rightPostS,rightPostE);
    return root;
}


TreeNode* buildTree(vector<int> &postOrder , vector<int> &inOrder){
    int n = postOrder.size();
    TreeNode* root = buildTreeHelper(inOrder,postOrder,0,n-1,0,n-1);
    return root;
}

bool isSymmetricHelper(TreeNode* leftTree,TreeNode* rightTree){
    if(leftTree == NULL && rightTree != NULL ) return false;
    if(leftTree != NULL && rightTree == NULL ) return false;
    if(leftTree == NULL && rightTree == NULL ) return true;
    if(leftTree->val != rightTree->val) return false;

    return isSymmetricHelper(leftTree->left,rightTree->right) && isSymmetricHelper(leftTree->right,rightTree->left);
}

bool isSymmetric(TreeNode* root){
    if(root == NULL) return true;
    return isSymmetricHelper(root->left,root->right);
}


bool getPath(TreeNode* root, int val ,vector<int> &ans){
    if(root == NULL) return false;
    ans.push_back(root->val);
    if(root-> val == val){
        returnt true;
    }
    bool left = getPath(root->left,val,ans);
    bool right = getPath(root->right,val,ans);

    if(left || right){
        return true;
    }
    ans.pop_back();
    return false;
}

int getDiameter(TreeNode* root){
    if(root == NULL){
        return 0;
    }

    int option1 = height(root->left) + height(root->right);
    int option2 = getDiameter(root->left);
    int option3 = getDiameter(root->right);

    return max(option1,max(option2,option3));
}


template<typename T>
class Queue{
    public :
        int nextIndex ;
        int firstIndex ;
        int capacity;
        int size;
        T *arr;
        Queue(int capacity){
            this->capacity = capacity;
            size = 0;
            nextIndex = 0;
            firstIndex = -1;
            arr = new T[capacity];
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size == 0;
        }
        void push(T element){
            if(size == capacity){
                T *newArr = new T[2*capacity];
                int j =0;
                for(int i = firstIndex ; i<capacity;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                for(int i = 0 ; i<firstIndex;i++){
                    newArr[j] = arr[i];
                    j++;
                }
                nextIndex = capacity;
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
                firstIndex = 0;
            }
            arr[nextIndex] = element;
            nextIndex = (nextIndex+1)%capacity;
            size++;
            if(firstIndex == -1){
                firstIndex = 0;
            }
        }
        void pop(){
            if(isEmpty()){
                cout<<"queue is empty";
                return ;
            }
            firstIndex = (firstIndex+1)%capacity;
            size--;
            if(size == 0){
                firstIndex = -1;
                nextIndex = 0;
            }
        }
        T front(){
            if(isEmpty()){
                cout<<"queue is empty";
                return 0;
            }
            return arr[firstIndex];
        }


}

class Node{
    public :
        int data;
        Node* next;
        Node(int data){
            this->data = data;
            next = NULL;
        }
}

class Queue{
    Node* head;
    Node* tail;
    int size;
    public :
        Queue(){
            head = NULL;
            tail = NULL;
            size = 0;
        }
        int getSize(){
            return size;
        }
        bool isEmpty(){
            return size == 0;
        }
        void push(int data){
            Node *n = new Node(data);
            if(head == NULL){
                head = n;
                tail = n;
            }else{
                tail->next = n;
                tail = n;
            }
            size++;
        }
        int front(){
            if(isEmpty()){
                cout<<"queue is empty";
                return 0;
            }
            return head->data;
        }
        void pop(){
            if(isEmpty()){
                cout<<"queue is empty";
                return ;
            }
            Node *temp = head;
            head = head->next;
            temp->next = NULL;
            delete temp;
            size--;
        }

}


template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            left = NULL;
            right = NULL;
        }
        ~BTNode(){
            delete left;
            delete right;
        }
}

class Pair{
    public :
    BTNode<int> *head;
    BTNode<int> *tail;
}


class BST{
    BTNode<int> *head;

    void printTree(BTNode<int>* root){
        if(root == NULL){
            return ;
        }
        cout<<root->data<<" : ";
        
        if(root->left != NULL){
            cout<<" L "<<root->left->data<<", ";
        }
        if(root->right != NULL){
            cout<<" R "<<root->right->data;
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }

    bool hasData(BTNode<int> *root,int data){
        if(root == NULL){
            return false;
        }
        if(root->data == data){
            return true;
        }
        if(root->data > data){
            return hasData(root->left , data)
        }else{
            return hasData(root->right,data);
        }
    }

    BTNode<int>* insert(BTNode<int>* root,int data){
        if(root == NULL){
            BTNode<int> *n = new BTNode<int>(data);
            return n;
        }
        if(root->data > data){
            root->left = insert(root->left,data);
        }else{
            root->right = insert(root->right,data);
        }
        return root;
    }

    BTNode<int>* deleteData(BTNode<int>* root , int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data > data){
            root->left = deleteData(root->left , data);
        }else if(root->data < data){
            root->right = deleteData(root->right,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                delete root;
                return NULL;
            }else if(root->left == NULL){
                BTNode<int> *temp = root->right;
                root->right = NULL;
                delete root;
                return temp;
            }else if(root->right == NULL){
                BTNode<int> *temp = root->left;
                root->left = NULL;
                delete root;
                return temp;
            }else{
                BTNode<int> *minNode = root->right;
                while(minNode->left != NULL){
                    minNode = minNode->left;
                }
                int minData = minNode->data;
                root->data = minData;
                root->right = deleteData(root->right,minData);
                return root;
            }
        }
        return root;
    }
    Pair convertToLL(BTNode<int> *root){
        if(root == NULL){
            Pair ans ;
            ans.head = NULL;
            ans.tail = NULL;
            return ans;
        }
        if(root->left == NULL && root->right == NULL){
            Pair ans ;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->left != NULL){
            Pair ans;
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;
        }else if(root->right != NULL){
            Pair ans;
            Pair rightLL = convertToLL(root->right);
            root->right = rightLL.head;
            ans.head = root;
            ans.tail = rightLL.tail;
            return ans;
        }else{
            Pair leftLL = convertToLL(root->left);
            Pair rightLL = convertToLL(root->right);
            leftLL.tail->right = root;
            root->right = rightLL.head;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }
}


int rangeSumInBST(BTNode<int> *root,int L,int R){
    if(root == NULL){
        return 0;
    }
    int sum = 0;
    if(root->val >= L && root->val <= R){
        sum += root->val;
    }
    if(root->val < L){
        sum += rangeSumInBST(root->right,L,R);
    }else if(root->val > R){
        sum += rangeSumInBST(root->left,L,R);
    }else{
        sum += rangeSumInBST(root->right,L,R) + rangeSumInBST(root->left,L,R);
    }
    return sum;
}

BTNode<int>* convertSortedArrToBST(vector<int> &nums,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    int rootData = nums[mid];
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = convertSortedArrToBST(nums,s,mid-1);
    root->right = convertSortedArrToBST(nums,mid+1,e);
    return root;
}

bool rootToNodePath(BTNode<int> *root , int data,vector<int> &ans ){
    if(root == NULL){
        return false;
    }
    ans.push_back(root->val);
    if(root->val == data){
        return true;
    }
    bool left = rootToNodePath(root->left,data,ans);
    bool right = rootToNodePath(root->right,data,ans);
    if(left || right){
        return true;
    }
    ans.pop_back();
    return false;
}


class Stack{
    public :
        int *arr;
        int capacity;
        int nextIndex;
        Stack(){
            arr = new int[5];
            capacity = 5;
            nextIndex = 0;
        }
        Stack(int cap){
            arr = new int[cap];
            capacity = cap;
            nextIndex = 0;
        }
        int getSize(){
            return nextIndex;
        }
        bool isEmpty(){
            return nextIndex == 0;
        }
        void push(int data){
            if(nextIndex == capacity){
                int *newArr = new int[2*capacity];
                for(int i = 0;i < capacity;i++){
                    newArr[i] = arr[i];
                }
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = element;
            nextIndex++;
        }
        int top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            return arr[nextIndex - 1];
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            nextIndex--;
        }
}

class Stack{
    public :
        Node *head;
        int size;
        Stack(){
            head = NULL;
            size = 0;
        }
        bool isEmpty(){
            return size == 0;
        }
        int getSize(){
            return size;
        }
        void push(int data){
            Node *n = new Node(data);
            n->next = head;
            head = n;
            size++;
        }
        void pop(){
            Node *temp = head;
            temp->next = NULL;
            delete temp;
            head = head->next;
            size--;
        }
        int top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return 0;
            }
            return head->data;
        }
}


template<typename T>
class BTNode{
    public :
        T data;
        BTNode<T> *left;
        BTNode<T> *right;
        BTNode(T data){
            this->data = data;
            this->left = NULL;
            this->right = NULL;
        }
        ~BTNode(){
            delete left;
            delete right;
        }
}


class Pair{
    public :
        BTNode<int> *head;
        BTNode<int> *tail;
}

class BST{
    BTNode<int> *root;

    void printTree(BTNode<int> *root){
        if(root == NULL) return ;
        cout<<root->data<<" : ";
        if(root->left){
            cout<<root->left->data<<", ";
        }
        if(root->right){
            cout<<root->right->data<<", ";
        }
        cout<<endl;
        printTree(root->left);
        printTree(root->right);
    }

    bool hasData(BTNode<int> *root,int data){
        if(root == NULL) return false;
        if(root->data == data) return true;
        if(data < root->data){
            return hasData(root->left);
        }else{
            return hasData(root->right);
        }
    }

    BTNode<int>* insert(BTNode<int> *root ,int data){
        if(root == NULL){
            BTNode<int> *n = new BTNode<int>(data);
            return n;
        }
        if(root->data > data){
            root->left = insert(root->left,data);
        }else{
            root->right = insert(root->right,data);
        }
        return root;
    }

    BTNode<int>* deleteData(BTNode<int> *root,int data){
        if(root == NULL){
            return NULL;
        }
        if(root->data < data){
            root->right = deleteData(root->right,data);
        }else if(root->data > data){
            root->left = deleteData(root->left,data);
        }else{
            if(root->left == NULL && root->right == NULL){
                root->data = NULL;
                return root;
            }else if(root->left == NULL){
                Node<int> *temp = root;
                root = root->right;
                temp->right = NULL;
                delete temp;
                return root;
            }else if(root->right == NULL){
                Node<int> *temp = root;
                root = root->left;
                temp->left = NULL;
                delete temp;
                return root;
            }else{
                BTNode<int> *minNode = root->right;
                while(minNode->left != NULL){
                    minNode = minNode->left;
                }
                int minData = minNode->data;
                root->data = minData;
                root->right = deleteData(root->right,minData);
                return root;
            }
        }
    }
    Pair convertToLL(BTNode<int> *root){
        if(root == NULL){
            Pair ans;
            ans.head = NULL;
            ans.tail = NULL;
            retur ans;    
        }
        if(root->left == NULL && root->right == NULL){
            Pair ans;
            ans.head = root;
            ans.tail = root;
            return ans;
        }else if(root->left == NULL){
            Pair ans;
            Pair rightLL= convertToLL(root->right);
            root->right = rightLL.head;
            ans.head = root;
            ans.tail = rightLL.tail;
            return ans;
        }else if(root->right == NULL){
            Pair ans;
            Pair leftLL = convertToLL(root->left);
            leftLL.tail->right = root;
            ans.head = leftLL.head;
            ans.tail = root;
            return ans;
        }else{
            Pair rightLL = convertToLL(root->right);
            Pair leftLL = convertToLL(root->left);
            lefLL.tail->right = root;
            root->right = rightLL.head;
            Pair ans;
            ans.head = leftLL.head;
            ans.tail = rightLL.tail;
            return ans;
        }
    }

    public :
        BST(){
            root = NULL;
        }
        ~BST(){
            delete root;
        }
        BTNode<int>* insert(int data){
            return insert(root,data);
        }
        BTNode<int>* delete(int data){
            return deleteData(root,data);
        }
        bool hasData(int data){
            return hasData(root,data);
        }
        void printTree(){
            printTree(root);
        }
        BTNode<int>* convertToLL(){
            Pair p = convertToLL(root);
            BTNode<int> *tmp = p.head;
            while(tmp != NULL){
                tmp->left = NULL;
                tmp = tmp->right;
            }
            return p.head;
        }
}

BTNode<int>* helper(vector<int> &nums,int s,int e){
    if(s > e){
        return NULL;
    }
    int mid = (s+e)/2;
    int rootData = nums[mid];
    BTNode<int> *root = new BTNode<int>(rootData);
    root->left = helper(nums,s,mid-1);
    root->right = helper(nums,mid+1,e);
    return root;
}


BTNode<int>* convertSortedArrayToBST(vector<int> &nums){
        n = nums.size();
        BTNode<int> *root = helper(nums,0,n-1);
        return root;
}

int maxInBST(BTNode<int> *root){
    if(root = NULL){
        return -1;
    }

    int max = INT_MIN;
    while(root != NULL){
        max = root->data;
        root = root->right;
    }
    return max;
}
bool searchInBST(BTNode<int> *root,int data){
    if(root == NULL) return false;
    if(root->data == data) return true;
    if(root->data < data){
        return searchInBST(root->right,data);
    }else{
        return searchInBST(root->left,data);
    }
}

int rangeSumInBST(BTNode<int> *root,int L,int R){
    if(root == NULL) return 0;
    int sum = 0;
    if(root->data >= L && root->data <= R){
        sum += root->data;
    }
    if(root->data < L){
        sum += rangeSumInBST(root->right,L,R);
    }else if(root->data > R){
        sum += rangeSumInBST(root->left,L,R);
    }else{
        sum += rangeSumInBST(root->right,L,R) + rangeSumInBST(root->left,L,R);
    }
    return sum;
}

bool helper(BTNode<int> *root,long long minV = -10000000000,long long maxV = 10000000000){
    if(root == NULL) return true;
    bool left = helper(root->left,minV,root->val);
    bool right = helper(root->right,root->val,maxV);
    if(left && right && root->val > minV && root->val < maxV) return true;
    else return false;
}

bool validateBST(BTNode<int> *root){
    return helper(root);
}

class Stack{
    public :
        int nextIndex;
        int *arr;
        int capacity;
        Stack(){
            capacity = 5;
            arr = new int[capacity];
            nextIndex= 0;
        }
        Stack(int cap){
            capacity = cap;
            arr = new int[capacity];
            nextIndex= 0;
        }
        int getSize(){
            return nextIndex;
        }
        bool isEmpty(){
            return nextIndex == 0;
        }
        void push(int data){
            if(capacity == nextIndex){
                int *newArr = new int[2*capacity];
                for(int i=0;i < nextIndex;i++){
                    newArr[i] = arr[i];
                }
                capacity = 2*capacity;
                delete []arr;
                arr = newArr;
            }
            arr[nextIndex] = data;
            nextIndex++;
        }
        void pop(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return ;
            }
            nextIndex--;
        }
        int top(){
            if(isEmpty()){
                cout<<"Stack is empty";
                return -1;
            }
            return arr[nextIndex-1];
        }
}



void removeAdjacentDuplicates2(string input){
    stack<char> s;
    for(int i = 0;i < input.size();i++){
        if(s.empty() || s.top() != input[i]){
            s.push_back(input[i]);
        }
    }
    
}
void removeAdjacentDuplicates(string input){
    int strptr = -1;
    int n = input.size();
    //string ans;
    for(int i = 0;i < n;i++){
        if(strptr == -1 || input[i] != input[strptr]){
            strptr++;
            input[strptr] = input[i];
        }else{
            strptr--;
        }
    }
    string ans = "";
    for(int i = 0;i <= strptr;i++){
        ans.push_back(input[i]);
    }
    return ans;
}


template<typename T>
class MapNode{
    public :
        string key;
        T value;
        MapNode* next;
        MapNode(string key,V value){
            this->key = key;
            this->value = value;
            this->next = NULL;
        }
        ~MapNode(){
            delete next;
        }
}

template<typename T>
class Mymap{
    int numBuckets ;
    MapNode<T> ** buckets;
    int count;
    int getBucketIndex(string key){
        int hashcode = 0;
        int base = 1;
        int p = 37;
        for(int i = 0;i < key.size();i++){
            hashcode += key[i] * base;
            base = base*p;
            hashcode = hashcode%numBuckets;
            base = base%numBuckets;
        }
        return hashcode%numBuckets;
    }

    void rehash(){
        MapNode<T> **temp = buckets;
        buckets = new MapNode<T>*[2*numBuckets];
        int oldBucketSize = numBuckets;
        numBuckets *= 2;
        count = 0;
        for(int i = 0;i < 2*numBuckets;i++){
            buckets[i] = NULL;
        }
        for(int i=0;i <oldBucketSize;i++){
            MapNode<T> *head = temp[i];
            while(head != NULL){
                V value = head->value;
                string key = head->key;
                insert(key,value);
                head=head->next;
            }
        }
        for(int i = 0;i < oldBucketSize;i++){
            delete temp[i];
        }
        delete []temp;
    }
    public :
        Mymap(){
            count = 0;
            numBuckets = 5;
            buckets = new MapNode<T>*[numBuckets];
            for(int i = 0;i < numBuckets;i++){
                buckets[i] = NULL;
            }
        }
        ~Mymap(){
            for(int i = 0;i < numBuckets;i++){
                delete buckets[i];
            }
            delete []buckets;
        }
        int size(){
            return count;
        }
        V getValue(string key){
            int keyIndex = getBucketIndex(key);
            MapNode<T> *head = buckets[keyIndex];
            while(head != NULL){
                if(head->key = key){
                    return head->value;
                }
                head = head->next;
            }
            return NULL;
        }
        void insert(string key, T value){
            int keyIndex = getBucketIndex(key);
            MapNode<T> *head = buckets[keyIndex];
            while(head != NULL){
                if(head->key == key){
                    head->value = value;
                }
                head = head->next;
            }
            MapNode<T> *n = new MapNode<T>(key,value);
            n->next = buckets[keyIndex];
            bucket[keyIndex] = n;
            count++;
            if(getLoadFactor() > 0.7){
                rehash();
            }
        }
        V remove(string key){
            int keyIndex = getBucketIndex(key);
            MapNode<V> *head = buckets[keyIndex];
            MapNode<V> *prev = NULL;
            while(head != NULL){
                if(head->key == key){
                    if(prev == NULL){
                        buckets[keyIndex] = head->next
                    }else{
                        prev->next = head->next;
                    }
                    V value = head->value;
                    head->next = NULL;
                    delete head;
                    count--;
                    return value;
                }
                prev = head;
                head = head->next;
            }
        }
        double getLoadFactor(){
            return (1.0)*count/numBuckets;
        }
}

template<typename T>
class MapNode{
    public :
        string key;
        T value;
        MapNode<T> *next;
        MapNode(string key,T value){
            this->key = key;
            this->value = value;
        }
        ~MapNode(){
            delete next;
        }
}

template<typename T>
class MyMap{
    private : 
        MapNode<T>** buckets;
        int count;
        int numBuckets;

        int getBucketIndex(string key){
            int hashcode = 0;
            int p = 37;
            int base = 1;
            for(int i = key.size() - 1;i >= 0;i--){
                hashcode += key[i]*base;
                base = base*p;
                hashcode = hashcode%numBuckets;
                base = base%numBuckets;
            }
            return hashcode%numBuckets;
        }

        void rehash(){
            MapNode<T> **
        }

    public :
        MyMap(){
            numBuckets = 5;
            buckets = new MapNode*<T>[numBuckets];
            size = 0;
        }
        ~MyMap(){
            for(int i = 0;i < numBuckets;i++){
                delete buckets[i];
            }
        }
        int size(){
            return count;
        }
        V getValue(string key){
            int bucketIndex = getBucketIndex(key);
            MapNode<V> *head = buckets[bucketIndex];
            while(head != NULL){
                if(head->key == key){
                    return head->value;
                }
                head = head->next;
            }
            return 0;
        }
        void insert(string key,V value){
            int bucketIndex = getBucketIndex(key);
            MapNode<T> *head = buckets[bucketIndex];
            while(head != NULL){
                if(head->key == key){
                    head->value = value;
                    return ;
                }
                head = head->next;
            }
            MapNode<V>* n = new MapNode<V>(key,value);
            n->next = buckets[bucketIndex];
            bucket[bucketIndex] = n;
            count++;
            if(getLoadFactor() >= 0.7){
                rehash();
            }
        }
        V remove(string key){
            int bucketIndex = getBucketIndex(key);
            MapNode<T> *head = bucket[bucketIndex];
            MapNode<T> *prev;
            while(head != NULL){
                if(head->key == key){
                    if(prev == NULL){
                        bucket[bucketIndex] = head->next;
                    }else{
                        prev->next = head->next;
                    }
                    head->next = NULL;
                    V value = head->value;
                    delete head;
                    count--;
                    return value;
                }
                prev = head;
                head = head->next;
            }
            return 0;
        }
        double getLoadFactor(){
            return (1.0)*count/numBuckets;
        }
}